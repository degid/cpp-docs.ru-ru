---
title: Ошибки компилятора с C3500 по C3999
ms.date: 04/21/2019
f1_keywords:
- C3502
- C3503
- C3504
- C3511
- C3512
- C3513
- C3514
- C3515
- C3516
- C3517
- C3518
- C3520
- C3521
- C3522
- C3523
- C3524
- C3525
- C3526
- C3527
- C3528
- C3529
- C3534
- C3542
- C3543
- C3544
- C3545
- C3546
- C3547
- C3548
- C3549
- C3557
- C3558
- C3559
- C3560
- C3561
- C3562
- C3563
- C3564
- C3565
- C3566
- C3567
- C3568
- C3569
- C3570
- C3571
- C3572
- C3573
- C3574
- C3575
- C3576
- C3577
- C3578
- C3579
- C3580
- C3581
- C3582
- C3583
- C3584
- C3585
- C3586
- C3587
- C3588
- C3589
- C3590
- C3591
- C3592
- C3593
- C3594
- C3595
- C3596
- C3597
- C3598
- C3599
- C3600
- C3601
- C3602
- C3604
- C3605
- C3613
- C3614
- C3616
- C3620
- C3621
- C3635
- C3636
- C3649
- C3658
- C3659
- C3660
- C3663
- C3664
- C3667
- C3674
- C3676
- C3677
- C3678
- C3679
- C3680
- C3681
- C3682
- C3683
- C3684
- C3685
- C3686
- C3687
- C3688
- C3689
- C3690
- C3691
- C3696
- C3716
- C3720
- C3725
- C3726
- C3729
- C3730
- C3735
- C3742
- C3746
- C3750
- C3751
- C3756
- C3757
- C3758
- C3759
- C3760
- C3770
- C3773
- C3774
- C3775
- C3776
- C3777
- C3778
- C3779
- C3780
- C3781
- C3782
- C3783
- C3784
- C3785
- C3786
- C3787
- C3801
- C3802
- C3806
- C3811
- C3814
- C3819
- C3822
- C3823
- C3826
- C3827
- C3829
- C3837
- C3840
- C3841
- C3843
- C3844
- C3845
- C3863
- C3870
- C3871
- C3875
- C3879
- C3881
- C3882
- C3884
- C3885
- C3897
- C3905
- C3906
- C3916
- C3921
- C3924
- C3925
- C3926
- C3927
- C3928
- C3930
- C3931
- C3932
- C3933
- C3934
- C3935
- C3936
- C3937
- C3938
- C3939
- C3940
- C3941
- C3945
- C3946
- C3947
- C3948
- C3949
- C3950
- C3951
- C3952
- C3953
- C3954
- C3955
- C3956
- C3957
- C3958
- C3959
- C3960
- C3961
- C3962
- C3963
- C3964
- C3965
- C3966
- C3967
- C3968
- C3969
- C3970
- C3971
- C3972
- C3975
- C3976
- C3977
- C3978
- C3979
- C3980
- C3981
- C3982
- C3983
- C3984
- C3985
- C3986
- C3987
- C3988
- C3989
- C3990
- C3991
- C3992
- C3993
- C3994
- C3995
- C3996
- C3997
- C3998
- C3999
ms.assetid: bd6f23ad-b300-4e07-8e35-9661cab1585f
ms.openlocfilehash: eddadeeeb014c6b64376554f7ff025a06e8935c9
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79446936"
---
# <a name="compiler-errors-c3500-through-c3999"></a>Ошибки компилятора с C3500 по C3999

В статьях этого раздела документации описывается подмножество сообщений об ошибках, создаваемых компилятором.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Сообщения об ошибках

|Ошибка|Сообщение|
|-----------|-------------|
|[Ошибка компилятора C3500](compiler-error-c3500.md)|недопустимый ProgID "*ProgID*"|
|[Ошибка компилятора C3501](compiler-error-c3501.md)|нет библиотеки типов, зарегистрированной для ProgID "*ProgID*"|
|Ошибка компилятора C3502|не удается получить LIBID для ProgID "*ProgID*"|
|Ошибка компилятора C3503|использование символа "0x*value*" в литерале необработанной строки не допускается|
|Ошибка компилятора C3504|не удается создать GUID из строки "*String*"|
|[Ошибка компилятора C3505](compiler-error-c3505.md)|не удается загрузить библиотеку типов "*Библиотека*"|
|[Ошибка компилятора C3506](compiler-error-c3506.md)|отсутствует библиотека типов, зарегистрированная для LIBID "*Library*"|
|[Ошибка компилятора C3507](compiler-error-c3507.md)|Идентификатор ProgID может содержать не более 39 символов "*ProgID*"; и не содержат знаков препинания, отличных от "."; или не начинаться с цифры|
|[Ошибка компилятора C3508](compiler-error-c3508.md)|"*тип*": не является допустимым типом автоматизации|
|[Ошибка компилятора C3509](compiler-error-c3509.md)|"*тип*": недопустимый возвращаемый тип автоматизации; Если параметр помечен как "retval", возвращаемый тип должен быть "void", "HRESULT" или "SCODE"|
|[Ошибка компилятора C3510](compiler-error-c3510.md)|не удается выполнить обнаружение *библиотеки* зависимых библиотек типов|
|Ошибка компилятора C3511|"*идентификатор*": вызов делегированного конструктора должен быть единственным инициализатором членов|
|Ошибка компилятора C3512|Длина последовательности символов для необработанного строкового литерала не должна превышать 16 символов.|
|Ошибка компилятора C3513|"*строка*": неподдерживаемый символ разделителя необработанных строковых литералов|
|Ошибка компилятора C3514|"*символ*" (*значение*): неподдерживаемый символ-разделитель литерала необработанной строки|
|Ошибка компилятора C3515|Если аргумент частичной специализации шаблона класса является расширением пакета, он должен быть последним аргументом|
|Ошибка компилятора C3516|обнаружен непредвиденный конец файла при обработке литерала необработанной строки; не найдена последовательность разделителей "*строка*"|
|Ошибка компилятора C3517|"*идентификатор*" объявление псевдонима не может иметь тип, содержащий "Auto"|
|Ошибка компилятора C3518|"*идентификатор*": в контексте инициализации прямого списка тип для "*тип*" может быть выведен только из выражения с одним инициализатором|
|[Ошибка компилятора C3519](compiler-error-c3519.md)|"*параметр*": недопустимый параметр для embedded_idl атрибута|
|Ошибка компилятора C3520|"*идентификатор*": пакет параметров должен быть расширен в этом контексте|
|Ошибка компилятора C3521|"*идентификатор*" не является пакетом параметров|
|Ошибка компилятора C3522|"*тип*": пакет параметров не может быть расширен в этом контексте|
|Ошибка компилятора C3523|"sizeof..." в качестве аргумента необходимо указать нераскрытый пакет параметров|
|Ошибка компилятора C3524|"*идентификатор*": "sizeof" не может быть применен к пакету параметров. Вы хотели бы использовать "sizeof..."?|
|Ошибка компилятора C3525|"*параметр*": Если шаблон класса содержит пакет параметров шаблона, он должен находиться в конце списка параметров шаблона.|
|Ошибка компилятора C3526|'...' невозможно применить к "this"|
|Ошибка компилятора C3527|"*идентификатор*" не является допустимым операндом для "sizeof...". Вы хотели бы использовать "sizeof"?|
|Ошибка компилятора C3528|"*идентификатор1*": число элементов в расширении этого пакета не совпадает с числом элементов в "*идентификатор2*"|
|Ошибка компилятора C3529|"*параметр*": пакет параметров шаблона не может иметь аргумент по умолчанию|
|[Ошибка компилятора C3530](compiler-error-c3530.md)|"*тип*" не может использоваться вместе с любым другим описателем типа|
|[Ошибка компилятора C3531](compiler-error-c3531.md)|"*идентификатор*": символ, тип которого содержит "*Type*", должен иметь инициализатор|
|[Ошибка компилятора C3532](compiler-error-c3532.md)|Тип элемента массива не может быть типом, содержащим "*Type*"|
|[Ошибка компилятора C3533](compiler-error-c3533.md)|параметр не может иметь тип, содержащий "*тип*"|
|Ошибка компилятора C3534|Устаревшее.|
|[Ошибка компилятора C3535](compiler-error-c3535.md)|невозможно вывести тип для "*тип1*" из "*тип2*"|
|[Ошибка компилятора C3536](compiler-error-c3536.md)|"*идентификатор*": не может использоваться до инициализации|
|[Ошибка компилятора C3537](compiler-error-c3537.md)|невозможно привести к типу, содержащему "*тип*"|
|[Ошибка компилятора C3538](compiler-error-c3538.md)|в списке деклараторов "*тип*" должен всегда вычислять один и тот же тип|
|[Ошибка компилятора C3539](compiler-error-c3539.md)|аргумент-шаблон не может быть типом, содержащим "*тип*"|
|[Ошибка компилятора C3540](compiler-error-c3540.md)|sizeof нельзя применить к типу, содержащему "*тип*"|
|[Ошибка компилятора C3541](compiler-error-c3541.md)|typeid нельзя применять к типу, содержащему "*тип*"|
|Ошибка компилятора C3542|"*идентификатор*": виртуальная функция-член не должна иметь возвращаемый тип, содержащий "*тип*"|
|Ошибка компилятора C3543|"*тип*": не содержит пакет параметров|
|Ошибка компилятора C3544|"*параметр*": пакет параметров принимает аргумент шаблона типа|
|Ошибка компилятора C3545|"*параметр*": пакет параметров принимает аргумент шаблона, не являющийся типом|
|Ошибка компилятора C3546|"...": нет доступных пакетов параметров для расширения|
|Ошибка компилятора C3547|Параметр шаблона "*параметр*" не может использоваться, так как он соответствует пакету параметров шаблона и не может быть выведен из параметров функции "*Function*"|
|Ошибка компилятора C3548|"*идентификатор*": пакет параметров не может использоваться в этом контексте|
|Ошибка компилятора C3549|"*значение*": пакет параметров функции не может иметь аргумент по умолчанию|
|[Ошибка компилятора C3550](compiler-error-c3550.md)|только неструктурированный описатель "decltype(auto)" разрешен в этом контексте|
|[Ошибка компилятора C3551](compiler-error-c3551.md)|Если используется завершающий возвращаемый тип, то первым возвращаемым типом должен быть спецификатор "Auto" (не "*тип*")|
|[Ошибка компилятора C3552](compiler-error-c3552.md)|требуется "decltype (Auto)"|
|[Ошибка компилятора C3553](compiler-error-c3553.md)|для "decltype" требуется выражение, а не тип|
|[Ошибка компилятора C3554](compiler-error-c3554.md)|"*тип*" не может использоваться вместе с любым другим описателем типа|
|[Ошибка компилятора C3555](compiler-error-c3555.md)|неправильный аргумент для "decltype"|
|[Ошибка компилятора C3556](compiler-error-c3556.md)|"*выражение*": неправильный аргумент для "decltype"|
|Ошибка компилятора C3557|Устаревшее.|
|Ошибка компилятора C3558|Устаревшее.|
|Ошибка компилятора C3559|рекурсивный вызов "*функция*": рекурсия обнаруживается при компиляции графа вызовов для concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3560|"*функция*": IL недоступен при компиляции графа вызовов concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3561|Операция барьера плиток обнаружена в потоке управления, которая не является единообразной при компиляции графа вызовов для Concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3562|подставляемая функция "*функция*" ограничена *числом* параметров.|
|Ошибка компилятора C3563|Обнаружен бесконечный цикл при компиляции графа вызовов для Concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3564|чтение неинициализированного значения при компиляции графа вызовов для Concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3565|Общий объем tile_static памяти (*число* байт) превышает предельное *число* байтов при компиляции графа вызовов для Concurrency::p arallel_for_each|
|Ошибка компилятора C3566|блоки с побочными эффектами имеют слишком глубокий уровень вложения при компиляции графа вызовов для Concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3567|обнаружено деление или остаток на ноль при компиляции графа вызовов для Concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3568|сумма регистров превышает предельное *число* при компиляции графа вызовов для concurrency::p arallel_for_each. Упростите программу.|
|Ошибка компилятора C3569|обнаружено состояние гонки при компиляции графа вызовов для Concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3570|Недопустимое использование ограниченной области amp при компиляции с параметром/CLR|
|Ошибка компилятора C3571|"*тип*": недопустимый аргумент домена вычислений; не является типом класса|
|Ошибка компилятора C3572|"*тип*": недопустимый аргумент домена вычислений; отсутствует открытый член: "статический const int Rank" или значение ранга не является положительным|
|Ошибка компилятора C3573|Число экземпляров concurrency::graphics:: образец, переданный в Concurrency::p arallel_for_each не может превышать *число*|
|Ошибка компилятора C3574|"*тип*": недопустимые экстенты плитки: должны быть положительными и (1) Z < = *число*; (2) Z*Y*X < = *число*|
|Ошибка компилятора C3575|"*тип*": недопустимый аргумент домена вычислений; отсутствует открытый член: "Concurrency:: index <*номер*> _map_index (const Concurrency:: index <*Number*> &) restrict (amp)"|
|Ошибка компилятора C3576|"*тип*": concurrency::d состояния:: _Parallel_for_each аргумент #*Number* имеет неподдерживаемый тип|
|Ошибка компилятора C3577|Недопустимый параметр Concurrency::p arallel_for_each аргумент ядра: невозможно разрешить вызов члена "void operator () (*Type*) restrict (amp)"|
|Ошибка компилятора C3578|Размер объекта функции, переданного в Concurrency::p arallel_for_each не может превышать *число* байтов|
|Ошибка компилятора C3579|Количество экземпляров, доступного только для чтения, Concurrency:: Array и concurrency::graphics:: текстура, переданных в Concurrency::p arallel_for_each не может превышать *число*|
|Ошибка компилятора C3580|Количество доступных для записи экземпляров Concurrency:: Array и concurrency::graphics:: текстуры, переданных в Concurrency::p arallel_for_each не может превышать *число*|
|Ошибка компилятора C3581|"*тип*": неподдерживаемый тип в коде, ограниченном amp|
|Ошибка компилятора C3582|Устаревшее.|
|Ошибка компилятора C3583|"*идентификатор*": размер переменной (*числа* байтов) превышает максимальный размер (*число* байт), поддерживаемый в коде, ограниченном amp|
|Ошибка компилятора C3584|Неподдерживаемое использование tile_static для "*идентификатор*"|
|Ошибка компилятора C3585|"*идентификатор*" имеет неподдерживаемый класс хранения в коде, ограниченном amp|
|Ошибка компилятора C3586|"*идентификатор*": использование глобальных или статических переменных не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3587|dynamic_cast не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3588|приведение типа "*тип1*" к "*тип2*" не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3589|"*строка*": неподдерживаемое использование строковых литералов в коде, ограниченном amp|
|Ошибка компилятора C3590|"*Token*": захват по ссылке или этот захват "this" не поддерживается, если лямбда-выражение ограничено amp|
|Ошибка компилятора C3591|Оператор typeid не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3592|Встроенная собственная сборка ("__asm") не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3593|оператор "goto" не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3594|Обработка исключений (TRY, catch, Throw и т. д.) не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3595|постоянное значение выходит за пределы поддерживаемого диапазона в коде, ограниченном amp|
|Ошибка компилятора C3596|"*параметр*" ("*тип*"): переменная, захваченная лямбда-выражением, имеет неподдерживаемый тип в коде, ограниченном amp|
|Ошибка компилятора C3597|"*параметр*": "*идентификатор*" не может быть захвачен по значению, если лямбда-выражение ограничено amp|
|Ошибка компилятора C3598|Оператор Label не поддерживается в коде, ограниченном amp|
|Ошибка компилятора C3599|"*оператор*": невозможно выполнять арифметические операции с указателями на bool в коде, ограниченном amp|
|Ошибка компилятора C3600|"*функция*": используется плитка\_статическая память, обнаруженная при компиляции графа вызовов для параллелизма без мозаичного заполнения::p араллел\_for_each в: "*функция*"|
|Ошибка компилятора C3601|"*тип*": недопустимый тип аргумента для диагностической функции amp "*функция*"|
|Ошибка компилятора C3602|Обнаружен неподдерживаемый поток управления при компиляции графа вызовов для Concurrency::p arallel_for_each в: "*функция*"|
|[Ошибка компилятора C3603](compiler-error-c3603.md)|"*символ*": тип "*тип*" пока не поддерживается|
|Ошибка компилятора C3604|"*идентификатор*": можно создать только управляемый объект в куче сборщика мусора|
|Ошибка компилятора C3605|Общее число образцов (*число* зарегистрированных и *число* предопределенных) превышает *число* при компиляции графа вызовов для Concurrency::p arallel_for_each в: "*функция*"|
|Ошибка компилятора C3606|Устаревшее.|
|Ошибка компилятора C3607|Устаревшее.|
|Ошибка компилятора C3608|Устаревшее.|
|[Ошибка компилятора C3609](compiler-error-c3609.md)|"*идентификатор*": функция "Sealed/Final" должна быть виртуальной|
|[Ошибка компилятора C3610](compiler-error-c3610.md)|"*идентификатор*": тип значения должен быть "упакован", прежде чем можно будет вызвать метод "*метод*"|
|[Ошибка компилятора C3611](compiler-error-c3611.md)|"*идентификатор*": запечатанная функция не может иметь чистый спецификатор|
|[Ошибка компилятора C3612](compiler-error-c3612.md)|"*идентификатор*": запечатанный класс не может иметь чистые виртуальные методы|
|Ошибка компилятора C3613|отсутствует возвращаемый тип после "->" (предполагается "int")|
|Ошибка компилятора C3614|Различные значения для размера пакета в пределах одного класса; предыдущим значением было "*value*", новое значение — "*value*"|
|[Ошибка компилятора C3615](compiler-error-c3615.md)|Функция constexpr "*функция*" не может привести к константному выражению|
|Ошибка компилятора C3616|Устаревшее.|
|Ошибка компилятора C3617|Устаревшее.|
|[Ошибка компилятора C3618](compiler-error-c3618.md)|"*объявление*": метод, помеченный как dllimport, не может быть определен|
|[Ошибка компилятора C3619](compiler-error-c3619.md)|шаблон не может быть объявлен в управляемом или WinRT типе|
|Ошибка компилятора C3620|"*тип*": Задание выравнивания не разрешено для типов WinRT|
|Ошибка компилятора C3621|"*тип*": для типов WinRT допускается только значение упаковки по умолчанию (*Number*)|
|[Ошибка компилятора C3622](compiler-error-c3622.md)|*тип*": не удается создать экземпляр класса, объявленного как"*ключевое слово*"|
|[Ошибка компилятора C3623](compiler-error-c3623.md)|"*идентификатор*": битовые поля не поддерживаются в типах управляемых и WinRT|
|[Ошибка компилятора C3624](compiler-error-c3624.md)|"*тип*": для использования этого типа требуется ссылка на сборку или модуль "*идентификатор*"|
|[Ошибка компилятора C3625](compiler-error-c3625.md)|"*класс*": собственный тип не может быть производным от типа управляемого или WinRT "*тип*"|
|[Ошибка компилятора C3626](compiler-error-c3626.md)|"*идентификатор*": ключевое слово "*keyword*" можно использовать только в интерфейсах COM, функциях-членах и членах данных, которые являются указателями на делегаты|
|[Ошибка компилятора C3627](compiler-error-c3627.md)|Только тип значения можно упаковать|
|[Ошибка компилятора C3628](compiler-error-c3628.md)|"*класс*": классы Managed/WinRT поддерживают только открытое наследование|
|Ошибка компилятора C3629|"*токен*": значение по умолчанию для записи может находиться только в начале списка записи в лямбда-выражении|
|[Ошибка компилятора C3630](compiler-error-c3630.md)|Ошибка при обработке токена "*Token*"|
|[Ошибка компилятора C3631](compiler-error-c3631.md)|"*событие*": невозможно перегрузить события управляемого или WinRT|
|[Ошибка компилятора C3632](compiler-error-c3632.md)|"*событие*": недопустимый стиль события для *конструкции*|
|[Ошибка компилятора C3633](compiler-error-c3633.md)|невозможно определить "*идентификатор*" как член управляемого "*класса*"|
|[Ошибка компилятора C3634](compiler-error-c3634.md)|"*член*": невозможно определить абстрактный метод управляемого класса/WinRT|
|Ошибка компилятора C3635|"*идентификатор*": не может применяться к управляемому или классу WinRT (вместо него используется "*идентификатор*")|
|Ошибка компилятора C3636|"*идентификатор*": не может применяться к этому типу|
|[Ошибка компилятора C3637](compiler-error-c3637.md)|"*функция*": определение дружественной функции не может быть специализацией шаблона функции или универсального класса|
|[Ошибка компилятора C3638](compiler-error-c3638.md)|"*оператор*": стандартные операторы преобразования упаковки и распаковки не могут быть переопределены|
|Ошибка компилятора C3639|Устаревшее.|
|[Ошибка компилятора C3640](compiler-error-c3640.md)|"*член*": необходимо определить ссылочную или виртуальную функцию-член локального класса|
|[Ошибка компилятора C3641](compiler-error-c3641.md)|"*функция*": недопустимое соглашение о вызовах "*соглашение*" для функции, скомпилированной с параметрами/clr: pure или/CLR: Сейф|
|[Ошибка компилятора C3642](compiler-error-c3642.md)|"*функция*": невозможно вызвать функцию с соглашением о вызове __clrcall из машинного кода|
|Ошибка компилятора C3643|Устаревшее.|
|[Ошибка компилятора C3644](compiler-error-c3644.md)|"*функция*": не удается скомпилировать функцию для создания управляемого кода|
|[Ошибка компилятора C3645](compiler-error-c3645.md)|"*функция*": __clrcall нельзя использовать для функций, скомпилированных в машинный код|
|[Ошибка компилятора C3646](compiler-error-c3646.md)|"*идентификатор*": Неизвестный спецификатор переопределения|
|Ошибка компилятора C3647|Устаревшее.|
|[Ошибка компилятора C3648](compiler-error-c3648.md)|Этот синтаксис явного переопределения не поддерживается для управляемых типов|
|Ошибка компилятора C3649|Этот синтаксис явного переопределения не разрешен с помощью/ZW|
|[Ошибка компилятора C3650](compiler-error-c3650.md)|"*член*": не может использоваться как явное переопределение, должно быть виртуальной функцией-членом базового класса|
|[Ошибка компилятора C3651](compiler-error-c3651.md)|"*член*": не может использоваться как явное переопределение, должен быть членом базового класса|
|[Ошибка компилятора C3652](compiler-error-c3652.md)|"*член*": функция, явно переопределяющая, должна быть виртуальной|
|[Ошибка компилятора C3653](compiler-error-c3653.md)|"*идентификатор*": не может использоваться как именованное переопределение: переопределяемая функция не найдена; забыли явно задать имя функции с помощью оператора::?|
|[Ошибка компилятора C3654](compiler-error-c3654.md)|"*токен*": синтаксическая ошибка в явном переопределении|
|[Ошибка компилятора C3655](compiler-error-c3655.md)|"*член*": функция уже явно переопределена|
|[Ошибка компилятора C3656](compiler-error-c3656.md)|"*ключевое слово*": спецификатор переопределения не может повторяться|
|[Ошибка компилятора C3657](compiler-error-c3657.md)|деструктор или метод завершения не может явно переопределять или быть явно переопределен|
|Ошибка компилятора C3658|Устаревшее.|
|Ошибка компилятора C3659|"*член*": спецификатор переопределения "*ключевое слово*" не поддерживается|
|Ошибка компилятора C3660|"*member1*": скрывает наследуемый член "*член2*"|
|[Ошибка компилятора C3661](compiler-error-c3661.md)|в списке явных переопределений не найдены методы для переопределения|
|[Ошибка компилятора C3662](compiler-error-c3662.md)|"*член*": спецификатор переопределения "*ключевое слово*" допускается только для функций-членов классов Managed/WinRT|
|Ошибка компилятора C3663|Устаревшее.|
|Ошибка компилятора C3664|"*член*": не может использоваться как явное переопределение, должен иметь доступность "Public" или "Protected"|
|[Ошибка компилятора C3665](compiler-error-c3665.md)|"*член*": спецификатор переопределения "*ключевое слово*" не допускается в деструкторе или методе завершения|
|[Ошибка компилятора C3666](compiler-error-c3666.md)|"*конструктор*": спецификатор переопределения "*ключевое слово*" не допускается в конструкторе|
|Ошибка компилятора C3667|"*атрибут*": атрибут не поддерживает расширение пакета|
|[Ошибка компилятора C3668](compiler-error-c3668.md)|"*член*": метод с описателем переопределения "override" не переопределяет методы базового класса|
|[Ошибка компилятора C3669](compiler-error-c3669.md)|"*член*": спецификатор переопределения "override" не допускается в статических функциях или конструкторах членов|
|[Ошибка компилятора C3670](compiler-error-c3670.md)|"*член*": невозможно переопределить недоступный метод базового класса "*член*"|
|[Ошибка компилятора C3671](compiler-error-c3671.md)|"*член*": функция не переопределяет "*член*"|
|[Ошибка компилятора C3672](compiler-error-c3672.md)|выражение псевдо-деструктора может использоваться только как часть вызова функции|
|[Ошибка компилятора C3673](compiler-error-c3673.md)|"*класс*": у класса нет конструктора копии|
|Ошибка компилятора C3674|не удалось найти модуль стандартной библиотеки "*модуль*"|
|[Ошибка компилятора C3675](compiler-error-c3675.md)|"*функция*": зарезервировано, так как определено "*свойство*"|
|Ошибка компилятора C3676|"*класс*": ссылочный класс и базовый класс имеют несовместимые атрибуты "[*Attribute*]"|
|Ошибка компилятора C3677|строковый литерал после "operator" не может иметь префикс кодировки|
|Ошибка компилятора C3678|строковый литерал после "operator" должен быть пустой строкой "" "" ""|
|Ошибка компилятора C3679|требуется идентификатор литерального суффикса после "operator" "" ""|
|Ошибка компилятора C3680|невозможно объединить определяемые пользователем строковые литералы с несовпадающими идентификаторами литерального суффикса|
|Ошибка компилятора C3681|"fallthrough": атрибут может присутствовать только во включающем операторе switch|
|Ошибка компилятора C3682|" *идентификатор*оператора": литеральный оператор или шаблон литерального оператора не может быть объявлен с "C компоновкой"|
|Ошибка компилятора C3683|невозможно определить как необработанный литеральный оператор, так и шаблон литерального оператора с одинаковым идентификатором литерального суффикса|
|Ошибка компилятора C3684|" *идентификатор*оператора": объявление литерального оператора имеет недопустимый список параметров|
|Ошибка компилятора C3685|" *идентификатор*оператора": шаблон литерального оператора не может иметь параметров функции|
|Ошибка компилятора C3686|" *идентификатор*оператора": шаблон литерального оператора должен иметь ровно один параметр шаблона, который является пакетом параметров|
|Ошибка компилятора C3687|" *идентификатор*оператора": шаблон литерального оператора должен иметь параметр шаблона типа "char", не являющийся типом|
|Ошибка компилятора C3688|Недопустимый литеральный суффикс "*суффикс*"; литеральный оператор или шаблон литерального оператора " *идентификатор*оператора" не найден|
|Ошибка компилятора C3689|" *идентификатор*оператора": литеральный оператор или шаблон литерального оператора должен находиться в глобальной области видимости или область пространства имен|
|Ошибка компилятора C3690|Ожидался строковый литерал, но вместо этого обнаружен определенный пользователем строковый литерал|
|Ошибка компилятора C3691|Недопустимый префикс литерала "*префикс*"|
|Ошибка компилятора C3692|Устаревшее.|
|Ошибка компилятора C3693|Устаревшее.|
|Ошибка компилятора C3694|Устаревшее.|
|Ошибка компилятора C3695|Устаревшее.|
|Ошибка компилятора C3696|"*ключевое слово*": нельзя использовать этот квалификатор в "%"|
|[Ошибка компилятора C3697](compiler-error-c3697.md)|"*ключевое слово*": нельзя использовать этот квалификатор в "^"|
|[Ошибка компилятора C3698](compiler-error-c3698.md)|"*тип*": этот тип нельзя использовать в качестве аргумента "*operator*"|
|[Ошибка компилятора C3699](compiler-error-c3699.md)|"*оператор*": невозможно использовать это косвенное обращение для типа "*тип*"|
|Ошибка компилятора C3700|Устаревшее.|
|[Ошибка компилятора C3701](compiler-error-c3701.md)|"*функция*": источник события не имеет событий|
|[Ошибка компилятора C3702](compiler-error-c3702.md)|ATL требуется для событий COM|
|[Ошибка компилятора C3703](compiler-error-c3703.md)|"*event_handler*": метод обработчика событий должен иметь тот же класс хранения, что и источник "*событие*"|
|[Ошибка компилятора C3704](compiler-error-c3704.md)|"*член*": метод vararg не может порождать события|
|[Ошибка компилятора C3705](compiler-error-c3705.md)|"*функция*": не удается найти интерфейс событий|
|[Ошибка компилятора C3706](compiler-error-c3706.md)|"*функция*": должен быть COM-интерфейсом для запуска COM-событий|
|[Ошибка компилятора C3707](compiler-error-c3707.md)|"*член*": метод disp-интерфейса должен иметь DISPID|
|[Ошибка компилятора C3708](compiler-error-c3708.md)|"*функция*": неправильное использование "*ключевого слова*"; должен быть членом совместимого источника событий|
|[Ошибка компилятора C3709](compiler-error-c3709.md)|"*функция*": неправильный синтаксис для указания события в __hook или __unhook|
|[Ошибка компилятора C3710](compiler-error-c3710.md)|"*функция*": неправильный синтаксис для указания обработчика событий в __hook или __unhook|
|[Ошибка компилятора C3711](compiler-error-c3711.md)|"*событие*": неуправляемый метод источника события должен возвращать значение void или целочисленный тип|
|[Ошибка компилятора C3712](compiler-error-c3712.md)|"*event_handler*": метод обработчика событий должен возвращать тот же тип, что и источник "*событие*"|
|[Ошибка компилятора C3713](compiler-error-c3713.md)|"*event_handler*": метод обработчика событий должен иметь те же параметры функции, что и источник "*событие*"|
|[Ошибка компилятора C3714](compiler-error-c3714.md)|"*event_handler*": метод обработчика событий должен иметь то же соглашение о вызовах, что и источник "*событие*"|
|[Ошибка компилятора C3715](compiler-error-c3715.md)|"*указатель*": должен быть указателем на "*тип*"|
|Ошибка компилятора C3716|Устаревшее.|
|[Ошибка компилятора C3717](compiler-error-c3717.md)|"*член*": метод, порождающий события, не может быть определен|
|[Ошибка компилятора C3718](compiler-error-c3718.md)|в контексте функции-члена принимающего класса можно вызвать только "__*ключевое слово*"|
|[Ошибка компилятора C3719](compiler-error-c3719.md)|"*член*": источник событий на основе интерфейса может использоваться только для событий COM|
|Ошибка компилятора C3720|"*тип*": интерфейс IDispatch может быть реализован только на сдвоенном или DISP-интерфейсе|
|[Ошибка компилятора C3721](compiler-error-c3721.md)|"*Signature*": несовместимая сигнатура для события|
|[Ошибка компилятора C3722](compiler-error-c3722.md)|универсальное событие не разрешено|
|[Ошибка компилятора C3723](compiler-error-c3723.md)|"*функция*": не удалось разрешить событие|
|[Ошибка компилятора C3724](compiler-error-c3724.md)|для использования многопоточности с событиями необходимо #include \<Windows.h >|
|Ошибка компилятора C3725|Устаревшее.|
|Ошибка компилятора C3726|Устаревшее.|
|[Ошибка компилятора C3727](compiler-error-c3727.md)|"*событие*": управляемое событие должно быть функцией-членом или элементом данных, который является указателем на делегат|
|[Ошибка компилятора C3728](compiler-error-c3728.md)|"*событие*": событие не имеет метода Raise|
|Ошибка компилятора C3729|Устаревшее.|
|Ошибка компилятора C3730|Устаревшее.|
|[Ошибка компилятора C3731](compiler-error-c3731.md)|несовместимое событие "*событие*" и обработчик "*event_handler*"; Источник события и обработчик событий должны иметь одинаковый тип событий|
|[Ошибка компилятора C3732](compiler-error-c3732.md)|"*интерфейс*": Пользовательский интерфейс, порождающий COM-события, не может наследовать от IDispatch|
|[Ошибка компилятора C3733](compiler-error-c3733.md)|"*событие*": неправильный синтаксис для указания события com; Вы забыли "__interface"?|
|[Ошибка компилятора C3734](compiler-error-c3734.md)|"*класс*": управляемый класс/WinRT не может быть компонентным классом|
|Ошибка компилятора C3735|Устаревшее.|
|[Ошибка компилятора C3736](compiler-error-c3736.md)|"*член*": должен быть методом или, в случае с управляемыми событиями, необязательный элемент данных|
|[Ошибка компилятора C3737](compiler-error-c3737.md)|"*идентификатор*": делегат не может иметь явное соглашение о вызовах|
|[Ошибка компилятора C3738](compiler-error-c3738.md)|"*соглашение*": соглашение о вызовах для явного создания экземпляра должно соответствовать соглашению при создании экземпляра шаблона|
|[Ошибка компилятора C3739](compiler-error-c3739.md)|"*класс*": синтаксис поддерживается только в том случае, если параметр "Layout\_зависимый" event_receiver имеет значение true|
|[Ошибка компилятора C3740](compiler-error-c3740.md)|"*шаблон*": шаблоны не могут принимать события источника или получения|
|[Ошибка компилятора C3741](compiler-error-c3741.md)|"*класс*": должен быть коклассом, если параметр "Layout\_dependent" event_receiver имеет значение true|
|Ошибка компилятора C3742|"*токен1*": несбалансированная последовательность токенов в аргументе атрибута "*атрибут*", ожидается "*токен2*"|
|[Ошибка компилятора C3743](compiler-error-c3743.md)|можно только подключить или отсоединить весь интерфейс, если параметр "layout_dependent" event_receiver имеет значение true|
|[Ошибка компилятора C3744](compiler-error-c3744.md)|__unhook должны иметь по крайней мере 3 аргумента для управляемых событий|
|[Ошибка компилятора C3745](compiler-error-c3745.md)|"*функция*": только событие может быть "порождено"|
|Ошибка компилятора C3746|Стандартный атрибут "*идентификатор*" может отображаться в списке атрибутов не более одного раза|
|[Ошибка компилятора C3747](compiler-error-c3747.md)|отсутствует шаблон по умолчанию или универсальный параметр: *номер* параметра|
|[Ошибка компилятора C3748](compiler-error-c3748.md)|"*интерфейс*": неуправляемые интерфейсы не могут порождать события|
|[Ошибка компилятора C3749](compiler-error-c3749.md)|"*атрибут*": настраиваемый атрибут не может использоваться внутри функции|
|Ошибка компилятора C3750|"*токен*": непредвиденная лексема в списке атрибутов|
|Ошибка компилятора C3751|"*идентификатор*": непредвиденный идентификатор в списке атрибутов|
|[Ошибка компилятора C3752](compiler-error-c3752.md)|"*атрибут*": не удается классифицировать атрибут; *ключевое слово "keyword*" не должно использоваться в этом контексте|
|[Ошибка компилятора C3753](compiler-error-c3753.md)|универсальное свойство не допускается|
|[Ошибка компилятора C3754](compiler-error-c3754.md)|конструктор делегата: функция члена "*member*" не может быть вызвана для экземпляра типа "*тип*"|
|[Ошибка компилятора C3755](compiler-error-c3755.md)|"*идентификатор*": делегат не может быть определен|
|Ошибка компилятора C3756|Устаревшее.|
|Ошибка компилятора C3757|"*тип*": тип не допускается для функции "constexpr"|
|Ошибка компилятора C3758|"*член*": виртуальная функция не может быть объявлена как "constexpr"|
|Ошибка компилятора C3759|"*член*": функция-член типа, не являющегося литералом, не может быть объявлена как "constexpr"|
|Ошибка компилятора C3760|Используйте ключевое слово __property для объявления свойства в Managed/WinRT "*класс*".|
|[Ошибка компилятора C3761](compiler-error-c3761.md)|"*функция*": "retval" может использоваться только в последнем аргументе функции|
|[Ошибка компилятора C3762](compiler-error-c3762.md)|не удается обработать атрибут "*атрибут*"|
|[Ошибка компилятора C3763](compiler-error-c3763.md)|"*тип*": "retval" и "out" могут использоваться только в типе указателя данных|
|[Ошибка компилятора C3764](compiler-error-c3764.md)|"*член*": не удается переопределить метод базового класса "*член*"|
|[Ошибка компилятора C3765](compiler-error-c3765.md)|"*событие*": невозможно определить событие в классе или структуре "*тип*", помеченной как event_receiver|
|[Ошибка компилятора C3766](compiler-error-c3766.md)|"*тип*" должен предоставлять реализацию метода интерфейса "*функция*"|
|[Ошибка компилятора C3767](compiler-error-c3767.md)|"*функция*": функции-кандидаты недоступны|
|[Ошибка компилятора C3768](compiler-error-c3768.md)|невозможно получить адрес виртуальной функции vararg в чистом управляемом коде|
|[Ошибка компилятора C3769](compiler-error-c3769.md)|"*идентификатор*": вложенный класс не может иметь то же имя, что и непосредственно включающий класс|
|Ошибка компилятора C3770|"*тип*": не является допустимым базовым классом|
|[Ошибка компилятора C3771](compiler-error-c3771.md)|"*идентификатор*": дружественное объявление не найдено в ближайшей области видимости пространства имен|
|[Ошибка компилятора C3772](compiler-error-c3772.md)|"*идентификатор*": недопустимое объявление дружественного шаблона|
|Ошибка компилятора C3773|для включения соподпрограмм используйте параметр компилятора/await.|
|Ошибка компилятора C3774|не удается найти "*Scope*::*identifier*": добавьте заголовок *заголовка*|
|Ошибка компилятора C3775|Тип возвращаемого значения "*функция*" не должен быть "*тип*"|
|Ошибка компилятора C3776|невозможно вернуть выражение типа void в соподпрограмме с типом возвращаемого значения, отличным от void|
|Ошибка компилятора C3777|"*функция*": соподпрограмма не может принимать переменный список аргументов|
|Ошибка компилятора C3778|Alloc: не может использоваться в соподпрограмме|
|Ошибка компилятора C3779|"*функция*": функция, возвращающая "*тип*", не может быть использована до ее определения|
|Ошибка компилятора C3780|"*функция*": функцию преобразования, возвращающую "*тип*", нельзя использовать до ее определения|
|Ошибка компилятора C3781|"*ключевое слово*": не может использоваться в соподпрограмме типа "*тип*". В связанном promise_type должен присутствовать либо *ключевое слово* , либо *ключевое слово*|
|Ошибка компилятора C3782|*тип*: обещание соподпрограммы не может одновременно содержать *ключевое слово* и *ключевое слово*|
|Ошибка компилятора C3783|"*идентификатор*": не может быть соподпрограммой|
|Ошибка компилятора C3784|выражение *ключевого слова* не может присутствовать в этом контексте|
|Ошибка компилятора C3785|Первый аргумент шаблона для "std:: integer_sequence" должен быть целочисленным типом|
|Ошибка компилятора C3786|второй аргумент шаблона для "std:: make_integer_sequence" должен быть целочисленной константой, которая больше или равна нулю|
|Ошибка компилятора C3787|не удается вывести тип возвращаемого значения этой соподпрограммы|
|Ошибка компилятора C3788|Устаревшее.|
|Ошибка компилятора C3789|Устаревшее.|
|Ошибка компилятора C3790|Устаревшее.|
|Ошибка компилятора C3791|Устаревшее.|
|Ошибка компилятора C3792|Устаревшее.|
|Ошибка компилятора C3793|Устаревшее.|
|Ошибка компилятора C3794|Устаревшее.|
|Ошибка компилятора C3795|Устаревшее.|
|Ошибка компилятора C3796|Устаревшее.|
|[Ошибка компилятора C3797](compiler-error-c3797.md)|"*ключевое слово*": объявление события не может иметь спецификатор переопределения (следует размещать в методах Add/Remove/raise события)|
|[Ошибка компилятора C3798](compiler-error-c3798.md)|"*ключевое слово*": объявление свойства не может иметь спецификатор переопределения (вместо него следует размещать методы Get/Set)|
|[Ошибка компилятора C3799](compiler-error-c3799.md)|индексированное свойство не может иметь пустой список параметров|
|[Ошибка компилятора C3800](compiler-error-c3800.md)|"*объявление*": невозможно смешивать свойства и события|
|Ошибка компилятора C3801|"*атрибут*": атрибут не может содержать предложение Argument|
|Ошибка компилятора C3802|Устаревшее.|
|[Ошибка компилятора C3803](compiler-error-c3803.md)|"*свойство*": свойство имеет тип, который несовместим с одним из*его методов доступа*|
|[Ошибка компилятора C3804](compiler-error-c3804.md)|"*член*": методы доступа для свойства должны быть либо статическими, либо не статическими|
|[Ошибка компилятора C3805](compiler-error-c3805.md)|"*токен*": непредвиденная лексема, ожидается "}" или ","|
|Ошибка компилятора C3806|"*токен*": непредвиденная лексема, ожидается либо "{", либо инициализатор членов|
|[Ошибка компилятора C3807](compiler-error-c3807.md)|"*тип*": класс с атрибутом ComImport не может быть производным от "*тип*", допускается только реализация интерфейса|
|[Ошибка компилятора C3808](compiler-error-c3808.md)|"*тип*": класс с атрибутом ComImport не может определять член "*член*", разрешены только абстрактные функции или возможности dllimport|
|[Ошибка компилятора C3809](compiler-error-c3809.md)|"*тип*": тип управляемого или WinRT не может иметь дружественные функции, классы и интерфейсы|
|Ошибка компилятора C3810|Устаревшее.|
|Ошибка компилятора C3811|Устаревшее.|
|[Ошибка компилятора C3812](compiler-error-c3812.md)|"__property" должен быть первым токеном в объявлении свойства|
|[Ошибка компилятора C3813](compiler-error-c3813.md)|объявление свойства может использоваться только в пределах определения типа управляемого или WinRT|
|Ошибка компилятора C3814|Устаревшее.|
|[Ошибка компилятора C3815](compiler-error-c3815.md)|Тип возвращаемого значения метода "*member*" должен соответствовать типу последнего параметра Setter|
|[Ошибка компилятора C3816](compiler-error-c3816.md)|"класс или *член*структуры" был ранее объявлен или определен с другим модификатором управляемого или WinRT|
|[Ошибка компилятора C3817](compiler-error-c3817.md)|"*объявление*": свойство может применяться только к функции|
|[Ошибка компилятора C3818](compiler-error-c3818.md)|объявление свойства массива "*свойство*" не должно перегружать свойство индекса "*свойство*"|
|Ошибка компилятора C3819|Устаревшее.|
|[Ошибка компилятора C3820](compiler-error-c3820.md)|"*идентификатор*": инициализаторы должны быть управляемыми|
|[Ошибка компилятора C3821](compiler-error-c3821.md)|"*функция*": управляемый тип или функция не могут использоваться в неуправляемой функции|
|Ошибка компилятора C3822|Устаревшее.|
|Ошибка компилятора C3823|Устаревшее.|
|[Ошибка компилятора C3824](compiler-error-c3824.md)|"*тип*": этот тип не может использоваться в этом контексте (параметр функции, возвращаемый тип или статический элемент)|
|[Ошибка компилятора C3825](compiler-error-c3825.md)|"*тип*": управляемый класс/WinRT может поддерживать только события управляемого или WinRT|
|Ошибка компилятора C3826|Устаревшее.|
|Ошибка компилятора C3827|Стандартный атрибут "устарел" может не иметь аргументов или одного строкового литерала, описывающего причину|
|[Ошибка компилятора C3828](compiler-error-c3828.md)|аргументы размещения не могут быть указаны для выражения "*keyword*" для типа "*тип*"|
|Ошибка компилятора C3829|Стандартный атрибут "noreturn" может применяться только к функциям|
|[Ошибка компилятора C3830](compiler-error-c3830.md)|"*тип1*": невозможно наследовать от "*тип2*", типы значений могут наследовать только от классов интерфейса|
|[Ошибка компилятора C3831](compiler-error-c3831.md)|"*идентификатор*": "*тип*" не может иметь закрепленный элемент данных или функцию-член, возвращающую закрепляющий указатель|
|[Ошибка компилятора C3832](compiler-error-c3832.md)|"*typelib*": Библиотека типов выглядит так, как если бы она была построена для 32-разрядных указателей; Измените квалификатор "ptrsize".|
|[Ошибка компилятора C3833](compiler-error-c3833.md)|"*тип*": недопустимый тип целевого объекта для *идентификатора*|
|[Ошибка компилятора C3834](compiler-error-c3834.md)|недопустимое явное приведение к закрепленному указателю; Вместо этого используйте закрепленную локальную переменную|
|Ошибка компилятора C3835|Устаревшее.|
|[Ошибка компилятора C3836](compiler-error-c3836.md)|статический конструктор не может иметь список инициализаторов членов|
|Ошибка компилятора C3837|Использование атрибутов в этом контексте не допускается|
|[Ошибка компилятора C3838](compiler-error-c3838.md)|Невозможно наследовать от "*тип*"|
|[Ошибка компилятора C3839](compiler-error-c3839.md)|невозможно изменить выравнивание в управляемом типе/WinRT|
|Ошибка компилятора C3840|Устаревшее.|
|Ошибка компилятора C3841|Устаревшее.|
|[Ошибка компилятора C3842](compiler-error-c3842.md)|"*идентификатор*": квалификаторы Const и volatile для функций-членов управляемых типов/WinRT не поддерживаются|
|Ошибка компилятора C3843|"*идентификатор*": квалификаторы ref в функциях-членах управляемых типов/WinRT не поддерживаются|
|Ошибка компилятора C3844|"*идентификатор*": невозможно импортировать символ из "*Source*": "*идентификатор*" уже существует в текущей области видимости|
|Ошибка компилятора C3845|Устаревшее.|
|[Ошибка компилятора C3846](compiler-error-c3846.md)|"*идентификатор*": невозможно импортировать символ из "*Source*": так как "*идентификатор*" уже был импортирован из другой сборки "*Сборка*"|
|Ошибка компилятора C3847|Устаревшее.|
|[Ошибка компилятора C3848](compiler-error-c3848.md)|выражение HAVING типа "*тип*" потеряет некоторые квалификаторы const-volatile для вызова "*identifier*"|
|[Ошибка компилятора C3849](compiler-error-c3849.md)|вызов в стиле функции в выражении типа "*тип*" приведет к потере квалификаторов const и/или volatile *для всех доступных* перегрузок операторов|
|[Ошибка компилятора C3850](compiler-error-c3850.md)|"*Token*": универсальное имя символа указывает недопустимый символ|
|[Ошибка компилятора C3851](compiler-error-c3851.md)|"*токен*": универсальное имя символа не может обозначать символ в базовом наборе символов|
|[Ошибка компилятора C3852](compiler-error-c3852.md)|"*член*" имеет тип "*тип*": агрегатная инициализация не смогла инициализировать этот элемент|
|[Ошибка компилятора C3853](compiler-error-c3853.md)|"=": повторная инициализация ссылки или присваивания через ссылку на функцию недопустима|
|[Ошибка компилятора C3854](compiler-error-c3854.md)|выражение слева от "=" вычисляется как функция. Не удается присвоить значение функции (функция не является l-значением)|
|[Ошибка компилятора C3855](compiler-error-c3855.md)|"*функция*": шаблон или универсальный параметр "*идентификатор*" несовместим с объявлением|
|[Ошибка компилятора C3856](compiler-error-c3856.md)|"*класс*": класс не является шаблоном класса или универсальным|
|[Ошибка компилятора C3857](compiler-error-c3857.md)|"*шаблон*": несколько списков шаблонов или универсальных параметров не допускаются|
|[Ошибка компилятора C3858](compiler-error-c3858.md)|"*идентификатор*": невозможно повторно объявить в текущей области|
|[Ошибка компилятора C3859](compiler-error-c3859.md)|Превышен диапазон виртуальной памяти для PCH; Выполните повторную компиляцию с параметром командной строки "-ZM*Number*" или выше|
|[Ошибка компилятора C3860](compiler-error-c3860.md)|список аргументов Template или generic, следующий за шаблоном класса или универсальным именем, должен перечислять параметры в порядке, используемом в списке шаблонов или общих параметров.|
|[Ошибка компилятора C3861](compiler-error-c3861.md)|"*идентификатор*": идентификатор не найден|
|[Ошибка компилятора C3862](compiler-error-c3862.md)|"*функция*": невозможно скомпилировать неуправляемую функцию с параметрами/clr: pure или/CLR: Сейф|
|Ошибка компилятора C3863|тип массива "*тип*" не может быть назначен|
|Ошибка компилятора C3864|Устаревшее.|
|[Ошибка компилятора C3865](compiler-error-c3865.md)|"*ключевое слово*": может использоваться только в собственных функциях элементов|
|[Ошибка компилятора C3866](compiler-error-c3866.md)|в вызове деструктора или метода завершения отсутствует список аргументов|
|[Ошибка компилятора C3867](compiler-error-c3867.md)|"*функция*": нестандартный синтаксис; Используйте "&" для создания указателя на член|
|[Ошибка компилятора C3868](compiler-error-c3868.md)|"*тип*": ограничения для универсального параметра "*параметр*" отличаются от ограничений в объявлении|
|[Ошибка компилятора C3869](compiler-error-c3869.md)|в ограничении gcnew отсутствует пустой список параметров "()"|
|Ошибка компилятора C3870|"*параметр*": "__declspec (*спецификатор*)" может применяться только к параметрам целочисленного типа|
|Ошибка компилятора C3871|"*параметр*": "__declspec (Guard (Overflow))" поддерживается только для первых 64 параметров функции|
|[Ошибка компилятора C3872](compiler-error-c3872.md)|"0x*значение*": этот символ не допускается в идентификаторе|
|[Ошибка компилятора C3873](compiler-error-c3873.md)|"0x*значение*": этот символ не допускается в качестве первого символа идентификатора|
|[Ошибка компилятора C3874](compiler-error-c3874.md)|возвращаемый тип "*идентификатор*" должен быть "*тип1*", а не "*тип2*"|
|Ошибка компилятора C3875|в вызове нестатической функции-члена отсутствует список аргументов|
|Ошибка компилятора C3876|Устаревшее.|
|Ошибка компилятора C3877|Устаревшее.|
|Ошибка компилятора C3878|Устаревшее.|
|Ошибка компилятора C3879|"*член*": не может быть членом данных initonly|
|[Ошибка компилятора C3880](compiler-error-c3880.md)|"*член*": не может быть литеральным элементом данных|
|Ошибка компилятора C3881|Конструктор можно наследовать только от прямого базового класса|
|Ошибка компилятора C3882|"*класс*": конструктор уже унаследован от "*класс*"|
|Ошибка компилятора C3883|"*член*": статические данные члена initonly должны быть инициализированы|
|Ошибка компилятора C3884|"*тип*": массив с неизвестным размером не может инициализироваться значением|
|Ошибка компилятора C3885|"*тип*": массив с неизвестным размером не может быть инициализирован с помощью пустого списка инициализаторов|
|[Ошибка компилятора C3886](compiler-error-c3886.md)|"*член*": необходимо инициализировать литеральный элемент данных|
|[Ошибка компилятора C3887](compiler-error-c3887.md)|"*член*": инициализатор для литерального элемента данных должен быть константным выражением|
|[Ошибка компилятора C3888](compiler-error-c3888.md)|"*член*": выражение const, связанное с данным членом литерала, не C++поддерживается в/CLI|
|Ошибка компилятора C3889|Устаревшее.|
|[Ошибка компилятора C3890](compiler-error-c3890.md)|"*член*": невозможно получить адрес литеральных данных-члена|
|[Ошибка компилятора C3891](compiler-error-c3891.md)|"*член*": литеральный элемент данных нельзя использовать в качестве l-значения|
|[Ошибка компилятора C3892](compiler-error-c3892.md)|"*переменная*": нельзя присвоить значение переменной, которая является константой|
|[Ошибка компилятора C3893](compiler-error-c3893.md)|"*член*": использование l-value элемента данных initonly допускается только в конструкторе экземпляра класса "*класс*"|
|[Ошибка компилятора C3894](compiler-error-c3894.md)|"*член*": использование параметра "l-value" статического элемента данных initonly допускается только в конструкторе класса класса "*класс*"|
|[Ошибка компилятора C3895](compiler-error-c3895.md)|"*член*": элементы данных *типа* не могут быть "volatile"|
|[Ошибка компилятора C3896](compiler-error-c3896.md)|"*член*": недопустимый инициализатор: этот элемент данных литерала можно инициализировать только с помощью nullptr|
|Ошибка компилятора C3897|Устаревшее.|
|[Ошибка компилятора C3898](compiler-error-c3898.md)|"*член*": элементы данных *типа* могут быть только членами управляемых типов|
|[Ошибка компилятора C3899](compiler-error-c3899.md)|"*член*": использование l-value элемента данных initonly не допускается непосредственно в параллельной области в классе "*класс*"|
|[Ошибка компилятора C3900](compiler-error-c3900.md)|"*член*": не допускается в текущей области|
|[Ошибка компилятора C3901](compiler-error-c3901.md)|"*функция*": должен иметь возвращаемый тип "*тип*"|
|[Ошибка компилятора C3902](compiler-error-c3902.md)|"*функция*": тип последнего параметра должен быть "*тип*"|
|[Ошибка компилятора C3903](compiler-error-c3903.md)|"*свойство*": не имеет метода Set или Get|
|[Ошибка компилятора C3904](compiler-error-c3904.md)|"*свойство*": необходимо указать *числовые* параметры|
|Ошибка компилятора C3905|несогласованные права доступа не поддерживаются для подставляемого типа "*тип*"|
|Ошибка компилятора C3906|внутренний тип "*тип*" не является поддерживаемым типом возвращаемого значения или аргумента для функций vararg или unprototype|
|Ошибка компилятора C3907|Устаревшее.|
|[Ошибка компилятора C3908](compiler-error-c3908.md)|менее ограничиваемый уровень доступа, чем "*идентификатор*"|
|[Ошибка компилятора C3909](compiler-error-c3909.md)|объявление события управляемого или WinRT должно находиться в управляемом или WinRT типе|
|[Ошибка компилятора C3910](compiler-error-c3910.md)|"*событие*": необходимо определить член "*member*"|
|[Ошибка компилятора C3911](compiler-error-c3911.md)|"*член*": функция должна иметь тип "*тип*"|
|[Ошибка компилятора C3912](compiler-error-c3912.md)|"*событие*": тип события должен быть типом делегата|
|[Ошибка компилятора C3913](compiler-error-c3913.md)|свойство по умолчанию должно быть индексировано|
|[Ошибка компилятора C3914](compiler-error-c3914.md)|свойство по умолчанию не может быть статическим|
|[Ошибка компилятора C3915](compiler-error-c3915.md)|"*идентификатор*" не имеет индексированного свойства по умолчанию (индексатора класса)|
|Ошибка компилятора C3916|Устаревшее.|
|[Ошибка компилятора C3917](compiler-error-c3917.md)|"*токен*": устаревший стиль объявления *конструкции* (возможно, вы использовали "[" "]" вместо него?)|
|[Ошибка компилятора C3918](compiler-error-c3918.md)|для использования требуется "*идентификатор*" в качестве члена данных|
|[Ошибка компилятора C3919](compiler-error-c3919.md)|"*функция*": функция должна иметь тип "*return_type* (*тип*)"|
|[Ошибка компилятора C3920](compiler-error-c3920.md)|"*оператор*": не удается определить постфиксный оператор инкремента или декремента CLR/WinRT вызов постфиксного оператора CLR/WinRT вызовет соответствующий префиксный оператор CLR/winrt (op_Increment/op_Decrement), но с постфиксной семантикой|
|Ошибка компилятора C3921|Устаревшее.|
|Ошибка компилятора C3922|Устаревшее.|
|[Ошибка компилятора C3923](compiler-error-c3923.md)|"*член*": определения локального класса, структуры или объединения не допускаются в функции-члене класса Managed/WinRT|
|Ошибка компилятора C3924|Ошибка в аргументе #*число* вызовов конструктора делегата "*constructor*":|
|Ошибка компилятора C3925|Ожидался цикл (для, while или do) после директивы "*директива*"|
|Ошибка компилятора C3926|Недопустимая константа в директиве Parallel|
|Ошибка компилятора C3927|"->": замыкающий тип возвращаемого значения не допускается после декларатора, не относящегося к функции|
|Ошибка компилятора C3928|"->": замыкающий тип возвращаемого значения не допускается после декларатора в скобках|
|Ошибка компилятора C3929|Устаревшее.|
|Ошибка компилятора C3930|"*функция*": ни одна перегруженная функция не имеет спецификаторов ограничений, совместимых с окружающим контекстом "*контекст*"|
|Ошибка компилятора C3931|"*тип*": невозможно вызвать функцию, имеющую спецификаторы ограничений, несовместимые с окружающим контекстом|
|Ошибка компилятора C3932|Устаревшее.|
|Ошибка компилятора C3933|"*класс*": описатели ограничений деструктора должны охватывать объединение ограничений для всех конструкторов|
|Ошибка компилятора C3934|функция, которая находится в любой форме "Main", не может иметь спецификаторы ограничений, отличные от "ограничить" (ЦП)|
|Ошибка компилятора C3935|"*идентификатор*": переопределение; перекрывающиеся описатели ограничений|
|Ошибка компилятора C3936|"*идентификатор*": нераспознанный спецификатор ограничений|
|Ошибка компилятора C3937|пустой спецификатор ограничений не допускается|
|Ошибка компилятора C3938|"*идентификатор*": несколько описателей ограничений не поддерживаются в функциях с модификатором extern \042C\042|
|Ошибка компилятора C3939|"*идентификатор*": указатели на функции элементов, указатели на функции, ссылки на функции с описателем ограничения "amp" запрещены|
|Ошибка компилятора C3940|"*идентификатор*": идентификатор не найден — возможно, несоответствие версий компилятора и библиотеки. Убедитесь, что vccorlib.h/. lib, vccorlib120. dll и c1xx. dll совпадают|
|Ошибка компилятора C3941|"*условие*": требуется параметр командной строки "/CLR"|
|Ошибка компилятора C3942|Устаревшее.|
|Ошибка компилятора C3943|Устаревшее.|
|Ошибка компилятора C3944|Устаревшее.|
|Ошибка компилятора C3945|"*тип*": не удается создать или перехватить объект WinRT, который не является производным от Platform:: Exception|
|Ошибка компилятора C3946|"*тип*": typeid нельзя применять к этому типу|
|Ошибка компилятора C3947|*typeid*: typeid нельзя применять к раскрытию пакета|
|Ошибка компилятора C3948|"*ключевое слово*": расширение пакета не может присутствовать в этом контексте|
|Ошибка компилятора C3949|расширение пакета "..." не может использоваться в объявлении абстрактного объявления в скобках|
|Ошибка компилятора C3950|Устаревшее.|
|Ошибка компилятора C3951|Невозможно использовать указатель на член в проектируемом типе WinRT "*тип*". Вместо этого используйте делегат.|
|Ошибка компилятора C3952|"*тип*": WinRT не поддерживает массивы "in/out". Используйте "const Array\<T > ^" для "in" и "WriteOnlyArray\<T >" или "Array\<T > ^ *" для "out" в общедоступных API|
|Ошибка компилятора C3953|Невозможно использовать управляемый класс "*Type*" в модуле WinRT.|
|Ошибка компилятора C3954|"*тип*": массив, возвращаемый из опубликованного метода в типе WinRT, должен использовать форму "Array\<t > ^"|
|Ошибка компилятора C3955|"*тип*": открытый конструктор не может содержать параметр "out" или "WriteOnlyArray\<t >"|
|Ошибка компилятора C3956|"*тип*": тип помечен как эксклюзивный для "*тип*" и не может использоваться в качестве основания "*derived_type*"|
|Ошибка компилятора C3957|"*тип*": нельзя использовать "New" для типа WinRT; Вместо этого используйте "ref new"|
|Ошибка компилятора C3958|"*тип*": нельзя использовать "gcnew" для типа WinRT; Вместо этого используйте "ref new"|
|Ошибка компилятора C3959|"ref new" можно использовать только для создания объекта с типом WinRT|
|Ошибка компилятора C3960|Устаревшее.|
|Ошибка компилятора C3961|статический конструктор не поддерживается|
|Ошибка компилятора C3962|универсальный класс не поддерживается|
|Ошибка компилятора C3963|многомерный массив не поддерживается|
|Ошибка компилятора C3964|немассивный массив не поддерживается|
|Ошибка компилятора C3965|массив параметров не поддерживается|
|Ошибка компилятора C3966|"*функция*": универсальная функция не поддерживается|
|Ошибка компилятора C3967|Ошибка при импорте "*идентификатора*" из модуля "*модуль*"|
|Ошибка компилятора C3968|токен "*Token*" недопустим в качестве разделителя имени модуля; Вместо этого используйте точку (".")|
|Ошибка компилятора C3969|непоследовательные имена модулей: "*Module1*" и "*Module1*"|
|Ошибка компилятора C3970|"*идентификатор*": "*ключевое слово*" можно применять только к "ref class" или "ref struct" в глобальной области видимости или области пространства имен|
|Ошибка компилятора C3971|"*тип*": частичное определение не может располагаться после полного определения|
|Ошибка компилятора C3972|"*тип*": "partial" можно применять только к объявлениям или определениям классов|
|Ошибка компилятора C3973|Устаревшее.|
|Ошибка компилятора C3974|Устаревшее.|
|Ошибка компилятора C3975|" *идентификатор*класса или структуры" был ранее объявлен или определен с другим модификатором|
|Ошибка компилятора C3976|"*идентификатор1*" должен быть объявлен как "Public", чтобы использовать "*идентификатор2*"|
|Ошибка компилятора C3977|Для использования требуется ссылка на сборку, определяющую "*идентификатор*"|
|Ошибка компилятора C3978|"*идентификатор*": статическое свойство не допускается в качестве члена интерфейса WinRT или типа значения|
|Ошибка компилятора C3979|"*тип*": Используйте атрибут "*Attribute*" вместо "*value*"|
|Ошибка компилятора C3980|"*тип*" не может быть передан в метаданные|
|Ошибка компилятора C3981|"*тип*": тип значения не может иметь статические элементы данных "*идентификатор*"|
|Ошибка компилятора C3982|"*тип*": тип значения не может иметь неоткрытые элементы данных "*идентификатор*"|
|Ошибка компилятора C3983|"*тип*": тип значения не может иметь открытые элементы "*идентификатор*", не являющиеся элементами данных|
|Ошибка компилятора C3984|"*тип*": тип, не являющийся типом значения, не может иметь открытые элементы данных "*идентификатор*"|
|Ошибка компилятора C3985|"*идентификатор*": сигнатура открытого члена содержит частный тип "*член*"|
|Ошибка компилятора C3986|"*идентификатор*": сигнатура открытого члена содержит собственный тип "*member*"|
|Ошибка компилятора C3987|"*идентификатор*": сигнатура открытого члена содержит собственный тип "*тип*"|
|Ошибка компилятора C3988|"*тип*": собственный тип не может быть открытым|
|Ошибка компилятора C3989|"*тип*": вложенный тип не может быть открытым|
|Ошибка компилятора C3990|"*тип*": атрибут "*атрибут*" не может быть закрытым или вложенным|
|Ошибка компилятора C3991|"*тип*": невозможно реализовать не открытый или вложенный интерфейс "*интерфейс*"|
|Ошибка компилятора C3992|"*идентификатор*": сигнатура открытого члена содержит недопустимый тип "*тип*"|
|Ошибка компилятора C3993|"*тип*": тип значения должен содержать по крайней мере одно открытое поле|
|Ошибка компилятора C3994|"*тип*": тип значения не может реализовывать интерфейсы или иметь виртуальные функции|
|Ошибка компилятора C3995|"*тип*": тип значения не может иметь члены события "*идентификатор*"|
|Ошибка компилятора C3996|Устаревшее.|
|Ошибка компилятора C3998|"c++*Version*": неподдерживаемая C++ версия; по умолчанию используется "c++*Version*"|
|Ошибка компилятора C3999|Неизвестная ошибка. выберите команду "Техническая поддержка" C++ в меню "Справка" или откройте справочный файл технической поддержки для получения дополнительных сведений|

## <a name="see-also"></a>См. также раздел

[Ошибки иC++ предупреждения средств разработки C/компилятора и сборки](../compiler-errors-1/c-cpp-build-errors.md) \
[Ошибки компилятора C2000-C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
