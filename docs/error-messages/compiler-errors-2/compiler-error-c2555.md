---
title: Ошибка компилятора C2555
description: Справочник по ошибке компилятора Visual Studio C++ C2555.
ms.date: 03/30/2020
f1_keywords:
- C2555
helpviewer_keywords:
- C2555
ms.assetid: 5e49ebb8-7c90-457a-aa12-7ca7ab6574b2
ms.openlocfilehash: ecac92bc663a6344e9ddafe13c194a92ab944c51
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87207801"
---
# <a name="compiler-error-c2555"></a>Ошибка компилятора C2555

> "*Class1*::*функция1*": переопределяющий тип возвращаемого значения виртуальной функции отличается от "*Class2*::*функция2*", не является ковариантным

Виртуальная функция и производная переопределяемая функция имеют идентичные списки параметров, но различные типы возвращаемых значения.

## <a name="remarks"></a>Примечания

В C++ переопределяющая функция в производном классе не может отличаться только типом возвращаемого значения от виртуальной функции в базовом классе.

Существует исключение из этого правила для определенных типов возвращаемых значения. Когда производный класс переопределяет открытый базовый класс, он может вернуть указатель или ссылку на производный класс, а не на указатель или ссылку базового класса. Эти типы возвращаемых данных называются *ковариантными*, так как они различаются вместе с типом. Это исключение правила не разрешает ковариантные ссылки на указатели или указатели на указатели.

Одним из способов устранения этой ошибки является возврат того же типа, что и у базового класса. Затем приведите возвращаемое значение после вызова виртуальной функции. Другой — также изменить список параметров, чтобы сделать член производного класса перегрузкой вместо переопределения.

## <a name="examples"></a>Примеры

Эта ошибка может появиться при компиляции с помощью **`/clr`** . Например, C++ эквивалентно приведенному ниже объявлению C#:

```csharp
Guid[] CheckSources(Guid sourceID, Guid[] carouselIDs);
```

is

```cpp
Guid CheckSources(Guid sourceID, Guid carouselIDs[]) [];
```

Следующий пример приводит к возникновению ошибки C2555:

```cpp
// C2555.cpp
// compile with: /c
struct X {
   virtual void func();
};
struct Y : X {
   char func();  // C2555
   void func2();   // OK
};
```

Чтобы устранить эту проблему, измените тип возвращаемого значения `Y::func` на **`void`** .
