---
title: '&lt;mutex&gt;'
ms.date: 11/04/2016
f1_keywords:
- <mutex>
ms.assetid: efb60c89-687a-4e38-8fe4-694e11c4e8a3
ms.openlocfilehash: d5ff6f2a81a5caa564792e2c0cb43b7722c3e1dd
ms.sourcegitcommit: ec6dd97ef3d10b44e0fedaa8e53f41696f49ac7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88838558"
---
# <a name="ltmutexgt"></a>&lt;mutex&gt;

Включите стандартный заголовок \<mutex> для определения классов,, `mutex` `recursive_mutex` и, `timed_mutex` `recursive_timed_mutex` шаблонов и, а также `lock_guard` `unique_lock` вспомогательных типов и функций, определяющих области кода взаимного исключения.

> [!WARNING]
> Начиная с Visual Studio 2015 типы синхронизации стандартной библиотеки C++ основываются на примитивах синхронизации Windows и больше не используют ConcRT (за исключением случаев, когда Целевая платформа является Windows XP). Типы, определенные в \<mutex> , не следует использовать с типами или функциями ConcRT.

## <a name="requirements"></a>Требования

**Заголовок:**\<mutex>

**Пространство имен:** std

## <a name="remarks"></a>Примечания

> [!NOTE]
> В коде, компилируемом с помощью **/CLR**, этот заголовок блокируется.

Классы `mutex` и `recursive_mutex` имеют *тип мьютекса*. Тип мьютекса содержит конструктор по умолчанию и деструктор, который не вызывает исключения. Эти объекты содержат методы, обеспечивающие взаимное исключение в случаях, когда несколько потоков пытаются заблокировать один объект. В частности, тип мьютекса содержит методы `lock`, `try_lock` и `unlock`:

- Метод `lock` блокирует вызывающий поток до тех пор, пока этот поток не получит права владения мьютексом. Его возвращаемое значение игнорируется.

- Метод `try_lock` пытается получить права владения мьютексом без блокировки. Его возвращаемый тип преобразуется в **`bool`** и имеет значение **`true`** , если метод получает владение, но в противном случае **`false`** .

- Метод `unlock` выпускает права владения мьютексом из вызывающего потока.

Вы можете использовать типы мьютекса в качестве аргументов для создания экземпляров шаблонов `lock_guard` и `unique_lock`. Вы можете использовать объекты этих типов в качестве аргумента `Lock` для функций-членов wait в шаблоне [condition_variable_any](../standard-library/condition-variable-any-class.md).

*Тип мьютекса с ограничением по времени* удовлетворяет требованиям к типу мьютексов. Кроме того, у него есть `try_lock_for` `try_lock_until` методы и, которые должны быть вызываемыми с помощью одного аргумента и должны возвращать тип, преобразуемый в **`bool`** . Тип мьютекса с ограничением по времени может определять эти функции с помощью дополнительных аргументов, если эти дополнительные аргументы имеют значения по умолчанию.

- Метод `try_lock_for` должен иметь возможность вызова с одним аргументом `Rel_time`, тип которого является экземпляром [chrono::duration](../standard-library/duration-class.md). Метод пытается получить права владения мьютексом, но возвращается в период времени, назначенный `Rel_time`, независимо от успешности выполнения операции. Возвращаемое значение преобразуется в, **`true`** Если метод получает владение; в противном случае возвращаемое значение преобразуется в **`false`** .

- Метод `try_lock_until` должен быть доступен для вызова с одним аргументом `Abs_time`, тип которого является экземпляром [chrono::time_point](../standard-library/time-point-class.md). Метод пытается получить права владения мьютексом, но возвращается раньше окончания периода, назначенного `Abs_time`, независимо от успешности выполнения операции. Возвращаемое значение преобразуется в, **`true`** Если метод получает владение; в противном случае возвращаемое значение преобразуется в **`false`** .

Тип мьютекса также известен как *блокируемый тип*. Если он не предоставляет функцию-член `try_lock`, это *базовый блокируемый тип*. Мьютекс с ограничением по времени также известен как *блокируемый тип с ограничением по времени *.

## <a name="members"></a>Элементы

### <a name="classes"></a>Классы

|Имя|Описание|
|-|-|
|[Класс lock_guard](../standard-library/lock-guard-class.md)|Представляет шаблон, для которого можно создать экземпляры и объект, деструктор которого разблокирует `mutex`.|
|[Класс Mutex (стандартная библиотека C++)](../standard-library/mutex-class-stl.md)|Представляет тип мьютекса. Используйте объекты этого типа для принудительного взаимного исключения в программе.|
|[Класс recursive_mutex](../standard-library/recursive-mutex-class.md)|Представляет тип мьютекса. В отличие от класса `mutex`, поведение вызывающих методов блокировки для объектов, которые уже заблокированы, четко определено.|
|[Класс recursive_timed_mutex](../standard-library/recursive-timed-mutex-class.md)|Представляет тип мьютекса с ограничением по времени. Используйте объекты этого типа для принудительного взаимного исключения с ограниченной по времени блокировкой в программе. В отличие от объектов типа `timed_mutex`, эффект вызова методов блокировки для объектов `recursive_timed_mutex` четко определен.|
|[Класс scoped_lock](../standard-library/scoped-lock-class.md)||
|[Класс timed_mutex](../standard-library/timed-mutex-class.md)|Представляет тип мьютекса с ограничением по времени. Используйте объекты этого типа для принудительного взаимного исключения с ограниченной по времени блокировкой в программе.|
|[Класс unique_lock](../standard-library/unique-lock-class.md)|Представляет шаблон, для которого можно создать экземпляры и объекты, управляющие блокировкой и разблокировкой `mutex`.|

### <a name="functions"></a>Функции

|Имя|Описание|
|-|-|
|[call_once](../standard-library/mutex-functions.md#call_once)|Предоставляет механизм для однократного вызова указанного объекта во время выполнения.|
|[lock](../standard-library/mutex-functions.md#lock)|Пытается заблокировать все аргументы без взаимоблокировки.|
|[swap](../standard-library/mutex-functions.md#swap)||
|[try_lock](../standard-library/mutex-functions.md#try_lock)||

### <a name="structs"></a>Структуры

|Имя|Описание|
|-|-|
|[Структура adopt_lock_t](../standard-library/adopt-lock-t-structure.md)|Представляет тип, который используется для определения `adopt_lock`.|
|[Структура defer_lock_t](../standard-library/defer-lock-t-structure.md)|Представляет тип, который определяет объект `defer_lock`, используемый для выбора одного из перегруженных конструкторов `unique_lock`.|
|[Структура once_flag](../standard-library/once-flag-structure.md)|Представляет объект **`struct`** , который используется с функцией-шаблоном `call_once` для того, чтобы код инициализации вызывался только один раз, даже при наличии нескольких потоков выполнения.|
|[Структура try_to_lock_t](../standard-library/try-to-lock-t-structure.md)|Представляет **`struct`** , определяющий `try_to_lock` объект и используемый для выбора одного из перегруженных конструкторов `unique_lock` .|

### <a name="variables"></a>Переменные

|Имя|Описание|
|-|-|
|[adopt_lock](../standard-library/mutex-functions.md#adopt_lock)|Представляет объект, который можно передать в конструкторы для `lock_guard` и `unique_lock`, чтобы указать на блокировку объекта мьютекса, также передаваемого в конструктор.|
|[defer_lock](../standard-library/mutex-functions.md#defer_lock)|Представляет объект, который можно передать в конструктор для `unique_lock`, чтобы указать, что конструктор не должен блокировать объект мьютекса, который также передается в него.|
|[try_to_lock](../standard-library/mutex-functions.md#try_to_lock)|Представляет объект, который можно передать в конструктор для `unique_lock`, чтобы указать, что конструктор должен попытаться разблокировать объект `mutex`, который также передается в него без блокировки.|

## <a name="see-also"></a>См. также раздел

[Справочник по файлам заголовков](../standard-library/cpp-standard-library-header-files.md)
