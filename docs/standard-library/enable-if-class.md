---
title: Класс enable_if
ms.date: 11/04/2016
f1_keywords:
- type_traits/std::enable_if
helpviewer_keywords:
- enable_if class
- enable_if
ms.assetid: c6b8d41c-a18f-4e30-a39e-b3aa0e8fd926
ms.openlocfilehash: 1017fc315a4440350a0190cf4b40e644cda16876
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87230043"
---
# <a name="enable_if-class"></a>Класс enable_if

Условно создает экземпляр типа для разрешения перегрузки SFINAE. Вложенное typedef `enable_if<Condition,Type>::type` существует — и является синонимом для `Type` — только в том случае, если `Condition` имеет значение **`true`** .

## <a name="syntax"></a>Синтаксис

```cpp
template <bool B, class T = void>
struct enable_if;
```

### <a name="parameters"></a>Параметры

*&*\
Значение, определяющее наличие результирующего типа.

*T*\
Тип для создания экземпляра, если *B* имеет значение true.

## <a name="remarks"></a>Примечания

Если *B* имеет значение true, то `enable_if<B, T>` имеет вложенное определение typedef с именем Type, которое является синонимом для *T*.

Если *B* имеет значение false, `enable_if<B, T>` не имеет вложенного typedef с именем Type.

Предоставляется следующий шаблон псевдонима.

```cpp
template <bool B, class T = void>
using enable_if_t = typename enable_if<B,T>::type;
```

В C++ ошибка замены параметров шаблона не является ошибкой — этот факт называют *SFINAE* (неудачная замена не ошибка). Обычно `enable_if` используется для удаления кандидатов из разрешения перегрузки, т. е. функция отбраковывает набор перегрузки, чтобы одно определение было отброшено в пользу другого. Это соответствует поведению SFINAE. Дополнительные сведения об SFINAE см. в статье [Ошибка замены не ошибка](https://go.microsoft.com/fwlink/p/?linkid=394798) на веб-сайте Википедии.

Вот 4 примера сценариев.

- Сценарий 1. Упаковка возвращаемого типа функции:

```cpp
    template <your_stuff>
typename enable_if<your_condition, your_return_type>::type
    yourfunction(args) {// ...
}
// The alias template makes it more concise:
    template <your_stuff>
enable_if_t<your_condition, your_return_type>
yourfunction(args) {// ...
}
```

- Сценарий 2. Добавление параметра функции с аргументом по умолчанию:

```cpp
    template <your_stuff>
your_return_type_if_present
    yourfunction(args, enable_if_t<your condition, FOO> = BAR) {// ...
}
```

- Сценарий 3. Добавление параметра шаблона с аргументом по умолчанию:

```cpp
    template <your_stuff, typename Dummy = enable_if_t<your_condition>>
rest_of_function_declaration_goes_here
```

- Сценарий 4. Если функция содержит аргумент без шаблона, ее тип можно упаковать:

```cpp
    template <typename T>
void your_function(const T& t,
    enable_if_t<is_something<T>::value, const string&>
s) {// ...
}
```

Сценарий 1 не применяется к конструкторам и операторам преобразования, так как у них нет возвращаемых типов.

В сценарии 2 параметр остается без имени. Можно использовать `::type Dummy = BAR`, но имя `Dummy` не играет роли, поэтому указание имени, вероятно, вызовет предупреждение о параметре без ссылки. Необходимо выбрать тип параметра функции `FOO` и аргумент по умолчанию `BAR`.  Можно сказать **`int`** `0` , что и, но затем пользователи кода могут случайно передать функции дополнительное целое число, которое будет пропущено. Вместо этого рекомендуется использовать `void **` и `0` или, **`nullptr`** поскольку почти ничего не может быть преобразовано в `void **` :

```cpp
template <your_stuff>
your_return_type_if_present
yourfunction(args, typename enable_if<your_condition, void **>::type = nullptr) {// ...
}
```

Сценарий 2 также подходит для обычных конструкторов.  Но он не работает с операторами преобразования, так как они не могут принимать дополнительные параметры.  Он также не подходит для конструкторов [с переменным числом аргументов](../cpp/ellipses-and-variadic-templates.md), так как из-за добавления параметров пакет параметров функции становится невыводимым контекстом, что противоречит цели `enable_if`.

В сценарии 3 используется имя `Dummy`, но это необязательно. Подойдет и просто "`typename = typename`", но, если вы считаете, что это выглядит странно, можно использовать имя-заглушку (только не применяйте имя, которое может использоваться в определении функции). Если не передать тип функции `enable_if`, по умолчанию используется тип void, и это вполне логично, так как `Dummy` не играет никакой роли. Такой метод подходит для всего, в том числе для операторов преобразования и конструкторов с [переменным числом аргументов](../cpp/ellipses-and-variadic-templates.md).

Сценарий 4 работает для конструкторов без возвращаемых типов, что устраняет ограничение упаковки сценария 1.  Однако сценарий 4 применяется только для аргументов функции без шаблонов, которые не всегда доступны.  (При использовании сценария 4 для аргументов функции на основе шаблона устранение аргументов шаблона не работает.)

`enable_if` — это мощное средство, которое может быть опасным при неправильном использовании.  Так как цель функции — удалить кандидаты до разрешения перегрузки, при ее неправильном применении результаты могут быть очень запутанными.  Вот несколько рекомендаций.

- Не используйте `enable_if` для выбора между реализациями во время компиляции. Не пишите одну функцию `enable_if` для `CONDITION` и другую для `!CONDITION`.  Используйте шаблон *отправки тегов*, например, алгоритм может выбирать реализации в зависимости от силы указанных итераторов.

- Не используйте `enable_if` для применения требований.  Если вы хотите проверить параметры шаблонов, но проверка завершается неудачно и вызывает ошибку вместо выбора другой реализации, используйте [static_assert](../cpp/static-assert.md).

- Используйте `enable_if` при наличии набора перегрузок, который делает код неоднозначным.  Чаще всего это происходит в конструкторах с неявным преобразованием.

## <a name="example"></a>Пример

В этом примере объясняется, как функция шаблона стандартной библиотеки C++ [std::make_pair()](../standard-library/utility-functions.md#make_pair) использует `enable_if`.

```cpp
void func(const pair<int, int>&);

void func(const pair<string, string>&);

func(make_pair("foo", "bar"));
```

В этом примере `make_pair("foo", "bar")` возвращает `pair<const char *, const char *>`. Разрешение перегрузок должно определить требуемую функцию `func()`. `pair<A, B>` содержит конструктор с неявным преобразованием из `pair<X, Y>`.  Это не новый элемент, он был представлен в C++98. Однако в C++98/03 сигнатура конструктора с неявным преобразованием всегда существует, даже если это `pair<int, int>(const pair<const char *, const char *>&)`.  Разрешение перегрузки не имеет значения, что попытка создать экземпляр конструктора разворачивает ужасно, так как `const char *` не может неявно преобразовываться в **`int`** , а только в сигнатурах, до создания экземпляров определений функций.  Поэтому этот пример кода неоднозначен, так как существуют сигнатуры для преобразования `pair<const char *, const char *>` в `pair<int, int>` и `pair<string, string>`.

В C++11 эта неоднозначность была устранена с помощью `enable_if`, чтобы конструкция `pair<A, B>(const pair<X, Y>&)` существовала **только**, если `const X&` неявно преобразуется в `A`, а `const Y&` неявно преобразуется в `B`.  Это позволяет процессу разрешения перегрузок определить, что `pair<const char *, const char *>` не преобразуется в `pair<int, int>` и что перегрузка, принимающая тип `pair<string, string>`, допустима.

## <a name="requirements"></a>Требования

**Заголовок:**\<type_traits>

**Пространство имен:** std

## <a name="see-also"></a>См. также раздел

[<type_traits>](../standard-library/type-traits.md)
