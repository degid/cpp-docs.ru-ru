---
title: Алгоритмы
ms.date: 10/18/2018
helpviewer_keywords:
- libraries [C++], C++ algorithm conventions
- algorithms [C++], C++
- C++ Standard Library, algorithms
- algorithm template function C++ library conventions
- conventions [C++], C++ algorithm
ms.assetid: dec9b373-7d5c-46cc-b7d2-21a938ecd0a6
ms.openlocfilehash: 6532cb56bb70c82525a13ba53efdd6203ebafb12
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87205227"
---
# <a name="algorithms"></a>Алгоритмы

Алгоритмы являются важнейшей частью стандартной библиотеки C++. Алгоритмы работают с контейнерами не самостоятельно, а с помощью итераторов. Поэтому один и тот же алгоритм можно использовать с большинством, а то и со всеми контейнерами стандартной библиотеки C++. В этом разделе рассматриваются правила и терминология алгоритмов стандартной библиотеки C++.

## <a name="remarks"></a>Примечания

В описаниях функций шаблонов алгоритмов используется ряд стандартных сокращенных фраз:

- Фраза "в диапазоне \[ *A*, *B*)" означает последовательность из нуля или более дискретных значений, начинающихся с *A* , но не включая *B*. Диапазон допустим, только если доступ к *B* возможен из *A;* можно сохранить в объекте *A* *n* (*n*  =  *A*), увеличить объект ноль или более раз (+ +*N*), а объект будет сравниваться со значением *B* после конечного числа инкрементов (*N*  ==  *B*).

- Фраза "каждый *N* в диапазоне \[ *A*, *B*)" означает, что *N* начинается со значения *A* и увеличивается ноль или более раз, пока не будет равно значению *B*. Вариант *N*  ==  *B* не входит в диапазон.

- Фраза «самое низкое значение *N* в диапазоне \[ *a*, *B*) таким образом, что *x*» означает, что условие *x* определяется для каждого *N* в диапазоне \[ *a*, *b*) до тех пор, пока не будет выполнено условие *x* .

- Фраза «наибольшее значение *N* в диапазоне \[ *A*, *B*) означает *, что* *x* определяется для каждого *N* в диапазоне \[ *A*, *b*). Функция сохраняет в *K* копию *N* каждый раз, когда достигается условие *X* . Если происходит такое хранилище, функция заменяет конечное значение *N*, которое равно *B*, значением *K*. Однако для двунаправленного или итератора произвольного доступа это также может означать, что *N* начинается с наибольшего значения в диапазоне и уменьшается в диапазоне до тех пор, пока не будет выполнено условие *X* .

- Такие выражения, как *x*  -  *Y*, где *x* и *Y* могут быть итераторами, отличными от итераторов произвольного доступа, предназначены в математическом смысле. Функция не обязательно вычисляет оператор, **-** если он должен определить такое значение. Это также справедливо для таких выражений, как *x*  +  *n* и *x*  -  *n*, где *N* — целочисленный тип.

Несколько алгоритмов используют предикат, который выполняет попарное сравнение, например с `operator==` , для получения **`bool`** результата. Функция предиката `operator==` или любая ее замена не должны изменять ни один из операндов. Он должен возвращать тот же **`bool`** результат при каждом вычислении, и он должен дать тот же результат, если для операнда заменяется копия любого из операндов.

Некоторые алгоритмы используют предикат, который налагает строгое слабое упорядочение к парам элементов из последовательности. Для предиката " *пред*" (*X*, *Y*):

- В-смысле, значение " *пред*" (*x*, *x*) равно "false".

- Слабое означает, что *X* и *y* имеют эквивалентное упорядочение, если " \! *пред*" (*x*, *Y*)  && " \! *пред*" (*y*, *x*) (*x*  ==  *Y* не требуется определять).

- Упорядочение означает *, что "пред"*(*x*, *Y*)  && " *пред*" (*y*, *z*) подразумевает " *пред*" (*x*, *z*).

Некоторые из этих алгоритмов неявно используют предикат *X* \< *Y*. Other predicates that typically satisfy the strict weak ordering requirement are *X* > *Y*, `less` (*x*, *y*) и `greater` (*x*, *y*). Однако обратите внимание, что такие предикаты, как *X* \<= *Y* and *X* > =  *Y* , не соответствуют этому требованию.

Последовательность элементов, обозначенных итераторами в диапазоне \[ *Первая*, *Последняя*) — это последовательность, упорядоченная по оператору **<** , если для каждого *N* в диапазоне \[ 0, *последний*  -  *первый*) и для каждого *M* в диапазоне (*N*, *last*  -  *first*) предикат \! ( \* (*first*  +  *M*) < \* (*первые*  +  *n*)) имеет значение true. (Обратите внимание, что элементы сортируются в порядке возрастания.) Функция предиката `operator<` или замена для нее не должны изменять ни один из своих операндов. Он должен возвращать тот же **`bool`** результат при каждом вычислении, и он должен дать тот же результат, если для операнда заменяется копия любого из операндов. Кроме того она должен применить строгого слабое упорядочение с операндами, которые она сравнивает.

Последовательность элементов, обозначенных итераторами в диапазоне \[ `First` , `Last` — это куча, упорядоченная по `operator<` , если для каждого *N* в диапазоне \[ 1, *последним*  -  *первым*) предикат \! ( \* _First_  <  \* (*first*  +  *N*)) имеет значение true. (Первый элемент является самым большим.) Его внутренняя структура в противном случае известна только для функций-шаблонов [make_heap](algorithm-functions.md#make_heap), [pop_heap](algorithm-functions.md#pop_heap)и [push_heap](algorithm-functions.md#push_heap). Как и в случае с упорядоченной последовательностью, функция предиката `operator<` или любая замена для нее не должна изменять ни один из своих операндов, и она должна накладывать строгое слабое упорядочивание сравниваемых операндов. Он должен возвращать тот же **`bool`** результат при каждом вычислении, и он должен дать тот же результат, если для операнда заменяется копия любого из операндов.

Алгоритмы стандартной библиотеки C++ находятся в [\<algorithm>](algorithm.md) [\<numeric>](numeric.md) файлах заголовка и.

## <a name="see-also"></a>См. также раздел

[Справочник по стандартной библиотеке C++](cpp-standard-library-reference.md)\
[Безопасность потоков в стандартной библиотеке C++](thread-safety-in-the-cpp-standard-library.md)
