---
title: '&lt;новые &gt; операторы и перечисления'
ms.date: 11/04/2016
f1_keywords:
- new/std::operator delete
- new/std::operator new
ms.assetid: d1af4b56-9a95-4c65-ab01-bf43e982c7bd
ms.openlocfilehash: 2af2b3bc24e045d66626607781bc97f83686d559
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87215638"
---
# <a name="ltnewgt-operators-and-enums"></a>&lt;новые &gt; операторы и перечисления

## <a name="enum-align_val_t"></a><a name="op_align_val_t"></a>Перечисление align_val_t

```cpp
enum class align_val_t : size_t {};
```

## <a name="operator-delete"></a><a name="op_delete"></a>оператор DELETE

Функция, вызываемая с помощью выражения DELETE для отмены выделения хранилища для отдельных объектов.

```cpp
void operator delete(void* ptr) throw();
void operator delete(void *, void*) throw();
void operator delete(void* ptr, const std::nothrow_t&) throw();
```

### <a name="parameters"></a>Параметры

*ptr*\
Указатель, значение которого при удалении устанавливается в недействительное.

### <a name="remarks"></a>Примечания

Первая функция вызывается выражением DELETE для визуализации значения *ptr* invalid. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принять значение типа *ptr* , которое равно null или было возвращено предыдущим вызовом [оператора New](../standard-library/new-operators.md#op_new)(**size_t**).

Поведение по умолчанию для значения NULL типа *ptr* — не выполнять никаких действий. Любое другое значение *типа PTR* должно быть возвращено ранее с помощью вызова, как описано выше. Поведение по умолчанию для такого значения *, не* равного null, — это освобождение хранилища, выделенного предыдущим вызовом. Он не указывается при условии, что часть условий или все освобожденное хранилище выделены последующим вызовом `operator new` (**size_t**) или с любым из `calloc` ( **size_t**), `malloc` ( **size_t**) или `realloc` ( **`void`** <strong>\*</strong> , **size_t**).

Вторая функция вызывается выражением удаления, соответствующим новому выражению формы **`new`** ( **std:: size_t**). Она ничего не делает.

Третья функция вызывается выражением с размещением DELETE, соответствующим новому выражению формы **`new`** ( **std:: size_t**, **констстд:: nothrow_t&**). Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение: принимать значение `ptr` — null или результат возврата предыдущего вызова `operator new`( **size_t**). Поведение по умолчанию — вычислить **`delete`** ( `ptr` ).

### <a name="example"></a>Пример

Пример использования **оператора delete**см. в разделе [оператор New](../standard-library/new-operators.md#op_new) .

## <a name="operator-delete"></a><a name="op_delete_arr"></a>Оператор delete []

Функция, вызываемая с помощью выражения delete для отмены выделения хранилища для массива объектов.

```cpp
void operator delete[](void* ptr) throw();
void operator delete[](void *, void*) throw();
void operator delete[](void* ptr, const std::nothrow_t&) throw();
```

### <a name="parameters"></a>Параметры

*ptr*\
Указатель, значение которого при удалении устанавливается в недействительное.

### <a name="remarks"></a>Примечания

Первая функция вызывается `delete[]` выражением для отображения значения *ptr* недопустимо. Это заменяемая функция, так как в программе можно определить функцию с сигнатурой этой функции, которая заменит версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принять значение типа *ptr* , которое равно null или было возвращено предыдущим вызовом [оператора new&#91;&#93;](../standard-library/new-operators.md#op_new_arr)(**size_t**). Поведение по умолчанию для значения NULL типа *ptr* — не выполнять никаких действий. Любое другое значение *типа PTR* должно быть возвращено ранее с помощью вызова, как описано выше. Поведение по умолчанию для такого значения типа *ptr* , отличное от NULL, — это освобождение хранилища, выделенного предыдущим вызовом. Он не указывается при условии, что часть условий или все освобожденное хранилище выделены последующим вызовом [оператора New](../standard-library/new-operators.md#op_new)(**size_t**) или любого из `calloc` (**size_t**), `malloc` (**size_t**) или `realloc` ( **`void`** <strong>\*</strong> , **size_t**).

Вторая функция вызывается выражением размещения, `delete[]` соответствующим `new[]` выражению в форме `new[]` (**std:: size_t**). Она ничего не делает.

Третья функция вызывается помещением выражения delete, соответствующего выражению `new[]` в форме `new[]`( **std::size_t**, **const std::nothrow_t&**). Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение — принять значение типа *ptr* , которое равно null или было возвращено предыдущим оператором call `new[]` (**size_t**). Поведение по умолчанию — вычислить `delete[]`( `ptr`).

### <a name="example"></a>Пример

См. раздел [Оператор new&#91;&#93;](../standard-library/new-operators.md#op_new_arr) с примерами использования `operator delete[]`.

## <a name="operator-new"></a><a name="op_new"></a>Оператор New

Функция вызывается выражением new для выделения памяти для отдельных объектов.

```cpp
void* operator new(std::size_t count) throw(bad_alloc);
void* operator new(std::size_t count, const std::nothrow_t&) throw();
void* operator new(std::size_t count, void* ptr) throw();
```

### <a name="parameters"></a>Параметры

*count*\
Количество байт памяти для выделения.

*ptr*\
Возвращаемый указатель.

### <a name="return-value"></a>Возвращаемое значение

Указатель на адрес младшего байта выделенной памяти. Или *ptr*.

### <a name="remarks"></a>Примечания

Первая функция вызывается выражением new для выделения `count` байт памяти, подходящим образом выровненных для представления любого объекта такого размера. Программа может определить альтернативную функцию с сигнатурой этой функции, что заменит версию по умолчанию из стандартной библиотеки C++, поэтому функция является заменяемой.

Требуемое поведение — возврат указателя, отличного от NULL, только в том случае, если хранилище может быть выделено по запросу. Каждое такое выделение выдает указатель на память, которая не пересекается ни с одной другой выделенной памятью. Порядок и непрерывность памяти, выделяемой последовательными вызовами, не уточняется. Начальное сохраненное значение не уточняется. Возвращаемый указатель указывает на начало (адрес младшего байта) выделенной памяти. Если счетчик равен нулю, возвращенное значение не будет равно ни одному другому значению, возвращенному функцией.

Поведение по умолчанию — выполнить цикл. Внутри цикла функция сначала пытается выделить запрошенную память. Будут ли эти попытки включать вызов `malloc`( **size_t**), не уточняется. Если попытка успешна, функция возвращает указатель на выделенную память. В противном случае функция вызывает назначенный [обработчик new](../standard-library/new-typedefs.md#new_handler). Если вызванная функция возвращает управление, цикл повторяется. Цикл прекращается, когда попытка выделения запрошенной памяти завершилась успехом или если вызванная функция не вернула управление.

Требуемое поведение обработчика new — выполнить одну из следующих операций:

- Сделать больше памяти, доступной для выделения, и завершить выполнение.

- Вызовите либо `abort` или `exit` .

- Создает объект типа `bad_alloc` .

Поведение по умолчанию для [обработчика new](../standard-library/new-typedefs.md#new_handler) — выдать объект типа `bad_alloc`. Пустой указатель обозначает обработчик new по умолчанию.

Порядок и непрерывность хранилища, выделенные последовательными вызовами `operator new` (**size_t**), не заданы, как и начальные значения, хранящиеся там.

Вторая функция вызывается выражением new для выделения `count` байт памяти, подходящим образом выровненных для представления любого объекта такого размера. Программа может определить альтернативную функцию с сигнатурой этой функции, что заменит версию по умолчанию из стандартной библиотеки C++, поэтому функция является заменяемой.

Поведение по умолчанию — возврат `operator new` ( `count` ), если эта функция выполнена. В противном случае метод возвращает пустой указатель.

Третья функция вызывается **`new`** выражением размещения формы `new ( args ) T` . Здесь *args* — указатель на единичный объект. Это может быть полезно для создания объекта по известному адресу. Функция возвращает *ptr*.

Чтобы освободить хранилище, выделенное **оператором new**, вызовите [оператор DELETE](../standard-library/new-operators.md#op_delete).

Сведения о вызове или невызове нового поведения New см. [в разделе операторы new и DELETE](../cpp/new-and-delete-operators.md).

### <a name="example"></a>Пример

```cpp
// new_op_new.cpp
// compile with: /EHsc
#include<new>
#include<iostream>

using namespace std;

class MyClass
{
public:
   MyClass( )
   {
      cout << "Construction MyClass." << this << endl;
   };

   ~MyClass( )
   {
      imember = 0; cout << "Destructing MyClass." << this << endl;
   };
   int imember;
};

int main( )
{
   // The first form of new delete
   MyClass* fPtr = new MyClass;
   delete fPtr;

   // The second form of new delete
   MyClass* fPtr2 = new( nothrow ) MyClass;
   delete fPtr2;

   // The third form of new delete
   char x[sizeof( MyClass )];
   MyClass* fPtr3 = new( &x[0] ) MyClass;
   fPtr3 -> ~MyClass();
   cout << "The address of x[0] is : " << ( void* )&x[0] << endl;
}
```

## <a name="operator-new"></a><a name="op_new_arr"></a>оператор new []

Функция выделения, вызываемая выражением new для выделения памяти для массива объектов.

```cpp
void* operator new[](std::size_t count) throw(std::bad_alloc);
void* operator new[](std::size_t count, const std::nothrow_t&) throw();
void* operator new[](std::size_t count, void* ptr) throw();
```

### <a name="parameters"></a>Параметры

*count*\
Число байт памяти, которые нужно выделить для объекта-массива.

*ptr*\
Возвращаемый указатель.

### <a name="return-value"></a>Возвращаемое значение

Указатель на адрес младшего байта выделенной памяти. Или *ptr*.

### <a name="remarks"></a>Примечания

Первая функция вызывается выражением `new[]` для выделения `count` байт памяти, подходящим образом выровненной для представления любого объекта-массива такого или меньшего размера. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Требуемое поведение аналогично поведению [оператора New](../standard-library/new-operators.md#op_new)(**size_t**). Поведение по умолчанию — вернуть `operator new`( `count`).

Вторая функция вызывается выражением `new[]` для выделения `count` байт памяти, подходящим образом выровненной для представления любого объекта-массива такого размера. Программа может определить функцию с помощью сигнатуры этой функции, которая заменяет версию по умолчанию из стандартной библиотеки C++. Поведение по умолчанию — вернуть **операторнев**( `count` ), если эта функция выполнена. В противном случае метод возвращает пустой указатель.

Третья функция вызывается `new[]` выражением размещения вида **`new`** ( *args*) **T**[ **N**]. Здесь *args* — указатель на единичный объект. Функция возвращает `ptr`.

Для освобождения памяти, выделенной `operator new[]`, вызовите [оператор delete&#91;&#93;](../standard-library/new-operators.md#op_delete_arr).

Для информации о поведении new с выдачей исключений и без выдачи исключений см. раздел [Операторы new и delete](../cpp/new-and-delete-operators.md).

### <a name="example"></a>Пример

```cpp
// new_op_alloc.cpp
// compile with: /EHsc
#include <new>
#include <iostream>

using namespace std;

class MyClass {
public:
   MyClass() {
      cout << "Construction MyClass." << this << endl;
   };

   ~MyClass() {
      imember = 0; cout << "Destructing MyClass." << this << endl;
      };
   int imember;
};

int main() {
   // The first form of new delete
   MyClass* fPtr = new MyClass[2];
   delete[ ] fPtr;

   // The second form of new delete
   char x[2 * sizeof( MyClass ) + sizeof(int)];

   MyClass* fPtr2 = new( &x[0] ) MyClass[2];
   fPtr2[1].~MyClass();
   fPtr2[0].~MyClass();
   cout << "The address of x[0] is : " << ( void* )&x[0] << endl;

   // The third form of new delete
   MyClass* fPtr3 = new( nothrow ) MyClass[2];
   delete[ ] fPtr3;
}
```
