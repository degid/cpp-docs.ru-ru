---
title: 'TN071: Реализация IOleCommandTarget в MFC'
ms.date: 06/28/2018
helpviewer_keywords:
- TN071 [MFC]
- IOleCommandTarget interface [MFC]
ms.assetid: 3eef571e-6357-444d-adbb-6f734a0c3161
ms.openlocfilehash: 56745e7985c8af97b0b628d148586ccef346d95a
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79442071"
---
# <a name="tn071-mfc-iolecommandtarget-implementation"></a>TN071: Реализация IOleCommandTarget в MFC

> [!NOTE]
> Следующее техническое примечание не было обновлено, поскольку сначала оно было включено в электронную документацию. В результате некоторые процедуры и разделы могут быть устаревшими или неверными. Для получения последних сведений рекомендуется выполнить поиск интересующей темы в алфавитном указателе документации в Интернете.

Интерфейс `IOleCommandTarget` позволяет объектам и их контейнерам отправлять команды друг другу. Например, панели инструментов объекта могут содержать кнопки для таких команд, как `Print`, `Print Preview`, `Save`, `New`и `Zoom`. Если такой объект был внедрен в контейнер, который поддерживает `IOleCommandTarget`, объект может включить свои кнопки и переслать команды в контейнер для обработки, когда пользователь нащелкнул их. Если контейнер хочет, чтобы внедренный объект печатал сам себя, он может сделать этот запрос, отправив команду через интерфейс `IOleCommandTarget` внедренного объекта.

`IOleCommandTarget` является интерфейсом, подобным автоматизации, в том, что он используется клиентом для вызова методов на сервере. Однако использование `IOleCommandTarget` экономит издержки на выполнение вызовов через интерфейсы автоматизации, так как программистам не нужно использовать часто дорогостоящий метод `Invoke` `IDispatch`.

В MFC интерфейс `IOleCommandTarget` используется серверами активных документов, чтобы разрешить контейнерам активных документов отправлять команды на сервер. Класс сервера Active Documents, `CDocObjectServerItem`, использует карты интерфейса MFC (см. [TN038: реализация IUnknown в MFC/OLE](../mfc/tn038-mfc-ole-iunknown-implementation.md)) для реализации интерфейса `IOleCommandTarget`.

`IOleCommandTarget` также реализуется в классе `COleFrameHook`. `COleFrameHook` является недокументированным классом MFC, который реализует функциональные возможности окна фрейма в контейнерах редактирования на месте. `COleFrameHook` также использует карты интерфейсов MFC для реализации интерфейса `IOleCommandTarget`. `COleFrameHook`реализация `IOleCommandTarget` пересылает команды OLE в контейнеры активных документов, наследуемые `COleDocObjectItem`. Это позволяет любому контейнеру активного документа MFC принимать сообщения из автономных серверов документов.

## <a name="mfc-ole-command-maps"></a>Карты команд MFC OLE

Разработчики MFC могут воспользоваться преимуществами `IOleCommandTarget` с помощью карт команд MFC OLE. Схемы команд OLE подобны схемам сообщений, так как они могут использоваться для сопоставления команд OLE с функциями-членами класса, который содержит карту команд. Чтобы выполнить эту работу, поместите макросы на карте команд, чтобы указать группу команд OLE команды, которую требуется обрабатывать, команду OLE и идентификатор команды [WM_COMMAND](/windows/win32/menurc/wm-command) сообщения, которое будет отправлено при получении команды OLE. MFC также предоставляет ряд стандартных макросов для стандартных команд OLE. Список стандартных команд OLE, изначально предназначенных для использования с Microsoft Office приложениями, см. в разделе Перечисление ОЛЕКМДИД, которое определено в докобж.h.

При получении команды OLE приложением MFC, содержащим карту команд OLE, MFC пытается найти идентификатор команды и группу команд для запрошенной команды на карте команд OLE приложения. Если совпадение найдено, в приложение, содержащее сопоставление команд с ИДЕНТИФИКАТОРом запрошенной команды, отправляется сообщение WM_COMMAND. (См. Описание `ON_OLECMD` ниже.) Таким образом, команды OLE, отправленные в приложение, преобразуются в WM_COMMAND сообщения MFC. Затем WM_COMMAND сообщения перенаправляются через схемы сообщений приложения с помощью стандартной архитектуры [маршрутизации команд](../mfc/command-routing.md) MFC.

В отличие от схем сообщений, карты команд MFC OLE не поддерживаются ClassWizard. Разработчики MFC должны добавить поддержку схемы команд OLE и записи схемы команд OLE вручную. Карты команд OLE можно добавлять в активные серверы документов MFC в любом классе, который находится в WM_COMMAND цепочке маршрутизации сообщений во время активного документа в контейнере. К этим классам относятся классы приложения, производные от [CWinApp](../mfc/reference/cwinapp-class.md), [CView](../mfc/reference/cview-class.md), [CDocument](../mfc/reference/cdocument-class.md)и [COleIPFrameWnd](../mfc/reference/coleipframewnd-class.md). В контейнерах активных документов сопоставления команд OLE можно добавлять только в класс, производный от [COleDocObjectItem](../mfc/reference/coledocobjectitem-class.md). Кроме того, в контейнерах активных документов WM_COMMAND сообщения будут отправлены только в схему сообщений в классе, производном от `COleDocObjectItem`.

## <a name="ole-command-map-macros"></a>Макросы схемы команд OLE

Используйте следующие макросы для добавления функциональных возможностей схемы команд в класс:

```cpp
DECLARE_OLECMD_MAP ()
```

Этот макрос перемещается в объявление класса (обычно в файле заголовка) класса, содержащего карту команд.

```cpp
BEGIN_OLECMD_MAP(theClass, baseClass)
```

*секласс*<br/>
Имя класса, содержащего карту команд.

*baseClass*<br/>
Имя базового класса класса, содержащего карту команд.

Этот макрос отмечает начало схемы команды. Используйте этот макрос в файле реализации для класса, содержащего карту команд.

```
END_OLECMD_MAP()
```

Этот макрос отмечает конец схемы команд. Используйте этот макрос в файле реализации для класса, содержащего карту команд. Этот макрос всегда должен следовать за макросом BEGIN_OLECMD_MAP.

```
ON_OLECMD(pguid, olecmdid, id)
```

*пгуид*<br/>
Указатель на идентификатор GUID группы команд команды OLE. Этот параметр имеет **значение NULL** для стандартной группы команд OLE.

*олекмдид*<br/>
Идентификатор команды OLE для вызываемой команды.

*идентификатор*<br/>
Идентификатор сообщения WM_COMMAND, которое будет отправлено приложению, содержащему карту команд при вызове этой команды OLE.

Используйте макрос ON_OLECMD на карте команд, чтобы добавить записи для команд OLE, которые требуется обменять. При получении команд OLE они преобразуются в указанное сообщение WM_COMMAND и направляются через схему сообщений приложения с помощью стандартной архитектуры маршрутизации команд MFC.

## <a name="example"></a>Пример

В следующем примере показано, как добавить возможность обработки команд OLE на сервер активного документа MFC для обработки команды [OLECMDID_PRINT](/windows/win32/api/docobj/ne-docobj-olecmdid) OLE. В этом примере предполагается, что вы использовали помощью мастера для создания приложения MFC, которое является сервером активных документов.

1. В файле заголовка класса, производного от `CView`, добавьте в объявление класса макрос DECLARE_OLECMD_MAP.

    > [!NOTE]
    > Используйте производный от `CView`класс, так как он является одним из классов на сервере активного документа, который находится в цепочке маршрутизации сообщений WM_COMMAND.

    ```cpp
    class CMyServerView : public CView
    {
    protected: // create from serialization only
        CMyServerView();
        DECLARE_DYNCREATE(CMyServerView)
        DECLARE_OLECMD_MAP()
        // . . .
    };
    ```

2. В файле реализации для класса, производного от `CView`, добавьте BEGIN_OLECMD_MAP и END_OLECMD_MAP макросы:

    ```cpp
    BEGIN_OLECMD_MAP(CMyServerView, CView)

    END_OLECMD_MAP()
    ```

3. Чтобы обрабатывалась стандартная команда OLE Print, добавьте [ON_OLECMDный](reference/message-map-macros-mfc.md#on_olecmd) макрос к карте команд, указав идентификатор команды OLE для стандартной команды print и **ID_FILE_PRINT** для идентификатора WM_COMMAND. **ID_FILE_PRINT** является СТАНДАРТным идентификатором команды печати, используемой приложениями MFC, созданными помощью мастера:

    ```
    BEGIN_OLECMD_MAP(CMyServerView, CView)
        ON_OLECMD(NULL, OLECMDID_PRINT, ID_FILE_PRINT)
    END_OLECMD_MAP()
    ```

Обратите внимание, что один из стандартных командных макросов OLE, определенных в афксдокоб.h, может использоваться вместо макроса ON_OLECMD, так как **OLECMDID_PRINT** является СТАНДАРТным идентификатором команды OLE. Макрос ON_OLECMD_PRINT будет выполнять ту же задачу, что и макрос ON_OLECMD, показанный выше.

Когда приложение-контейнер отправляет этому серверу команду **OLECMDID_PRINT** через интерфейс `IOleCommandTarget` сервера, обработчик команд печати MFC будет вызываться на сервере, что приведет к печати приложения на сервере. Код контейнера активного документа для вызова команды Print, добавленной в приведенных выше шагах, будет выглядеть примерно так:

```cpp
void CContainerCntrItem::DoOleCmd()
{
    IOleCommandTarget *pCmd = NULL;
    HRESULT hr = E_FAIL;
    OLECMD ocm={OLECMDID_PRINT, 0};

    hr = m_lpObject->QueryInterface(
        IID_IOleCommandTarget,reinterpret_cast<void**>(&pCmd));

    if (FAILED(hr))
        return;

    hr = pCmd->QueryStatus(NULL, 1, &ocm, NULL);

    if (SUCCEEDED(hr) && (ocm.cmdf& OLECMDF_ENABLED))
    {
        //Command is available and enabled so call it
        COleVariant vIn;
        COleVariant vOut;
        hr = pCmd->Exec(NULL, OLECMDID_PRINT,
            OLECMDEXECOPT_DODEFAULT, &vIn, &vOut);
        ASSERT(SUCCEEDED(hr));
    }
    pCmd->Release();
}
```

## <a name="see-also"></a>См. также раздел

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категории](../mfc/technical-notes-by-category.md)
