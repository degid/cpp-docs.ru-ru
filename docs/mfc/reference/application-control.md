---
title: Управление приложением
ms.date: 11/04/2016
helpviewer_keywords:
- application control [MFC]
ms.assetid: c1f69f15-e0fe-4515-9f36-d63d31869deb
ms.openlocfilehash: 40ac3b6871d13420797279629a2661b22545d1d8
ms.sourcegitcommit: ec6dd97ef3d10b44e0fedaa8e53f41696f49ac7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88832377"
---
# <a name="application-control"></a>Управление приложением

OLE требует значительного контроля над приложениями и их объектами. Библиотеки DLL системы OLE должны иметь возможность автоматически запускать и освобождать приложения, координировать свои производственные и модификации объектов и т. д. Функции в этом разделе соответствуют этим требованиям. В дополнение к вызову из системных библиотек OLE, эти функции иногда также вызываются приложениями.

### <a name="application-control"></a>Управление приложением

| Имя | Описание |
|-|-|
|[AfxOleCanExitApp](#afxolecanexitapp)|Указывает, может ли приложение завершить работу.|
|[AfxOleGetMessageFilter](#afxolegetmessagefilter)|Извлекает текущий фильтр сообщений приложения.|
|[AfxOleGetUserCtrl](#afxolegetuserctrl)|Возвращает текущий флаг пользовательского элемента управления.|
|[AfxOleSetUserCtrl](#afxolesetuserctrl)|Задает или очищает флаг пользовательского элемента управления.|
|[AfxOleLockApp](#afxolelockapp)|Увеличивает глобальное количество активных объектов в приложении платформы.|
|[AfxOleLockControl](#afxolelockcontrol)| Блокирует фабрику класса указанного элемента управления. |
|[AfxOleUnlockApp](#afxoleunlockapp)|Уменьшает количество активных объектов в приложении на платформе.|
|[AfxOleUnlockControl](#afxoleunlockcontrol)| Разблокирует фабрику класса указанного элемента управления. |
|[AfxOleRegisterServerClass](#afxoleregisterserverclass)|Регистрирует сервер в системном реестре OLE.|
|[AfxOleSetEditMenu](#afxoleseteditmenu)|Реализует пользовательский интерфейс для команды объекта *TypeName* .|

## <a name="afxolecanexitapp"></a><a name="afxolecanexitapp"></a> афксолеканекситапп

Указывает, может ли приложение завершить работу.

```
BOOL AFXAPI AfxOleCanExitApp();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если приложение может выйти; в противном случае — 0.

### <a name="remarks"></a>Примечания

Приложение не должно завершаться, если имеются необработанные ссылки на объекты. Глобальные функции, `AfxOleLockApp` `AfxOleUnlockApp` увеличивающие и уменьшающие соответственно, счетчик ссылок на объекты приложения. Приложение не должно завершаться, если этот счетчик не равен нулю. Если значение счетчика не равно нулю, главное окно приложения скрыто (не уничтожается), когда пользователь выбирает пункт Закрыть в меню система или выход из меню файл. Платформа вызывает эту функцию в `CFrameWnd::OnClose` .

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAutomation#2](../../mfc/codesnippet/cpp/application-control_1.cpp)]

## <a name="requirements"></a>Требования

**Заголовок**: афксдисп.h

## <a name="afxolegetmessagefilter"></a><a name="afxolegetmessagefilter"></a> афксолежетмессажефилтер

Извлекает текущий фильтр сообщений приложения.

```
COleMessageFilter* AFXAPI AfxOleGetMessageFilter();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на текущий фильтр сообщений.

### <a name="remarks"></a>Примечания

Вызывайте эту функцию для доступа к `COleMessageFilter` объекту, производному от CURRENT, так же, как при вызове метода `AfxGetApp` доступа к текущему объекту приложения.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAutomation#3](../../mfc/codesnippet/cpp/application-control_2.cpp)]

[!code-cpp[NVC_MFCAutomation#4](../../mfc/codesnippet/cpp/application-control_3.cpp)]

### <a name="requirements"></a>Требования

**Заголовок**: AFXWIN.h

## <a name="afxolegetuserctrl"></a><a name="afxolegetuserctrl"></a> афксолежетусерктрл

Возвращает текущий флаг пользовательского элемента управления.

```
BOOL AFXAPI AfxOleGetUserCtrl();
```

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если пользователь управляет приложением; в противном случае — 0.

### <a name="remarks"></a>Примечания

Пользователь управляет приложением, когда пользователь явно открыл или создал новый документ. Пользователь также управляет, если приложение не было запущено с помощью системных библиотек OLE, иными словами, если пользователь запустил приложение с помощью системной оболочки.

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп.h

## <a name="afxolesetuserctrl"></a><a name="afxolesetuserctrl"></a> афксолесетусерктрл

Задает или очищает флаг пользовательского элемента управления, который описывается в справочнике по `AfxOleGetUserCtrl` .

```cpp
void AFXAPI AfxOleSetUserCtrl(BOOL bUserCtrl);
```

### <a name="parameters"></a>Параметры

*бусерктрл*<br/>
Указывает, должен ли быть установлен или сброшен флаг пользовательского элемента управления.

### <a name="remarks"></a>Примечания

Платформа вызывает эту функцию, когда пользователь создает или загружает документ, но не при загрузке или создании документа с помощью непрямого действия, такого как загрузка внедренного объекта из приложения-контейнера.

Вызывайте эту функцию, если другие действия в приложении должны поместит пользователя в Управление приложением.

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп.h

## <a name="afxolelockapp"></a><a name="afxolelockapp"></a> AfxOleLockApp

Увеличивает глобальное количество активных объектов в приложении платформы.

```cpp
void AFXAPI AfxOleLockApp();
```

### <a name="remarks"></a>Примечания

Платформа хранит количество активных объектов в приложении. `AfxOleLockApp`Функции и `AfxOleUnlockApp` соответственно увеличивают и уменьшают этот счетчик.

Когда пользователь пытается закрыть приложение, имеющее активные объекты, — приложение, для которого число активных объектов не равно нулю, платформа скрывает приложение из представления пользователя, а не полностью завершает его работу. `AfxOleCanExitApp`Функция указывает, может ли приложение завершить работу.

Вызов `AfxOleLockApp` из любого объекта, предоставляющего интерфейсы OLE, в случае нежелательного уничтожения этого объекта, когда он по-прежнему используется клиентским приложением. Также вызывайте `AfxOleUnlockApp` в деструкторе любого объекта, который вызывает `AfxOleLockApp` конструктор. По умолчанию `COleDocument` (и производные классы) автоматически блокирует и разблокируйте приложение.

### <a name="example"></a>Пример

[!code-cpp[NVC_MFCAutomation#5](../../mfc/codesnippet/cpp/application-control_4.cpp)]

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп.h

## <a name="afxoleunlockapp"></a><a name="afxoleunlockapp"></a> AfxOleUnlockApp

Уменьшает число активных объектов в приложении.

```cpp
void AFXAPI AfxOleUnlockApp();
```

### <a name="remarks"></a>Примечания

Дополнительные `AfxOleLockApp` сведения см. в разделе.

Когда число активных объектов достигает нуля, `AfxOleOnReleaseAllObjects` вызывается.

### <a name="example"></a>Пример

См. пример для [AfxOleLockApp](#afxolelockapp).

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп.h

## <a name="afxolelockcontrol"></a>AfxOleLockControl

Блокирует фабрику класса указанного элемента управления таким образом, чтобы динамически создаваемые данные, связанные с элементом управления, оставались в памяти.

### <a name="syntax"></a>Синтаксис

```
BOOL AFXAPI AfxOleLockControl(  REFCLSID clsid  );
BOOL AFXAPI AfxOleLockControl( LPCTSTR lpszProgID );
```

### <a name="parameters"></a>Параметры

*этому*<br/>
Уникальный идентификатор класса элемента управления.

*лпсзпрогид*<br/>
Уникальный идентификатор программы элемента управления.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если фабрика класса элемента управления была успешно заблокирована; в противном случае — 0.

### <a name="remarks"></a>Примечания

Это может значительно ускорить отображение элементов управления. Например, после создания элемента управления в диалоговом окне и блокировки элемента управления с помощью `AfxOleLockControl` не нужно создавать и уничтожать его повторно при каждом отображении или уничтожении диалогового окна. Если пользователь открывает и закрывает диалоговое окно несколько раз, Блокировка элементов управления может значительно повысить производительность. Когда вы будете готовы уничтожить элемент управления, вызовите метод `AfxOleUnlockControl` .

### <a name="example"></a>Пример

```cpp
// Starts and locks control's (Microsoft Calendar) class factory.
// Control will remain in memory for lifetime of
// application or until AfxOleUnlockControl() is called.

AfxOleLockControl(_T("MSCAL.Calendar"));
```

### <a name="requirements"></a>Требования

**Заголовок:** afxwin.h

## <a name="afxoleregisterserverclass"></a><a name="afxoleregisterserverclass"></a> афксолерегистерсерверкласс

Эта функция позволяет зарегистрировать сервер в системном реестре OLE.

```
BOOL AFXAPI AfxOleRegisterServerClass(
    REFCLSID clsid,
    LPCTSTR lpszClassName,
    LPCTSTR lpszShortTypeName,
    LPCTSTR lpszLongTypeName,
    OLE_APPTYPE nAppType = OAT_SERVER,
    LPCTSTR* rglpszRegister = NULL,
    LPCTSTR* rglpszOverwrite = NULL);
```

### <a name="parameters"></a>Параметры

*этому*<br/>
Ссылка на идентификатор класса OLE сервера.

*лпсзкласснаме*<br/>
Указатель на строку, содержащую имя класса объектов сервера.

*лпсзшорттипенаме*<br/>
Указатель на строку, содержащую короткое имя типа объекта сервера, например "Диаграмма".

*лпсзлонгтипенаме*<br/>
Указатель на строку, содержащую длинное имя типа объекта сервера, например "Диаграмма Microsoft Excel 5,0".

*напптипе*<br/>
Значение, взятое из перечисления OLE_APPTYPE, с указанием типа приложения OLE. Возможны следующие значения:

- OAT_INPLACE_SERVER Server имеет полный пользовательский интерфейс сервера.

- Сервер OAT_SERVER поддерживает только внедрение.

- Контейнер OAT_CONTAINER поддерживает ссылки на внедрения.

- `IDispatch`Объект, поддерживающий OAT_DISPATCH_OBJECT.

*рглпсзрегистер*<br/>
Массив указателей на строки, представляющие ключи и значения, добавляемые в системный реестр OLE, если не найдены существующие значения для ключей.

*рглпсзоверврите*<br/>
Массив указателей на строки, представляющие ключи и значения, добавляемые в системный реестр OLE, если реестр содержит существующие значения для заданных ключей.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если серверный класс успешно зарегистрирован; в противном случае — 0.

### <a name="remarks"></a>Примечания

Большинство приложений могут использовать `COleTemplateServer::Register` для регистрации типов документов приложения. Если формат системного реестра приложения не соответствует стандартному шаблону, можно использовать `AfxOleRegisterServerClass` для большего контроля.

Реестр состоит из набора ключей и значений. Аргументы *рглпсзрегистер* и *рглпсзоверврите* — это массивы указателей на строки, каждый из которых состоит из ключа и значения, разделенные символом **null** ( `'\0'` ). Каждая из этих строк может содержать заменяемые параметры, места которых помечены последовательностями символов *%1* – *%5*.

Символы заполняются следующим образом:

|Символ|Значение|
|------------|-----------|
|%1|Идентификатор класса, отформатированный как строка|
|%2|Имя класса|
|%3|Путь к исполняемому файлу|
|%4|Короткое имя типа|
|%5|Имя типа long|

### <a name="requirements"></a>Требования

**Заголовок**: афксдисп.h

## <a name="afxoleseteditmenu"></a><a name="afxoleseteditmenu"></a> афксолесетедитмену

Реализует пользовательский интерфейс для команды объекта *TypeName* .

```cpp
void AFXAPI AfxOleSetEditMenu(
    COleClientItem* pClient,
    CMenu* pMenu,
    UINT iMenuItem,
    UINT nIDVerbMin,
    UINT nIDVerbMax = 0,
    UINT nIDConvert = 0);
```

### <a name="parameters"></a>Параметры

*пклиент*<br/>
Указатель на клиентский элемент OLE.

*пмену*<br/>
Указатель на обновляемый объект меню.

*именуитем*<br/>
Индекс обновляемого элемента меню.

*нидвербмин*<br/>
Идентификатор команды, соответствующий первичной команде.

*нидвербмакс*<br/>
Идентификатор команды, соответствующий последней команде.

*нидконверт*<br/>
Идентификатор элемента меню Convert.

### <a name="remarks"></a>Примечания

Если сервер распознает только первичную команду, пункт меню становится «объектом *TypeName* verb», а команда *нидвербмин* отправляется, когда пользователь выбирает команду. Если сервер распознает несколько глаголов, пункт меню становится "объектом *TypeName* ", а в подменю, в котором отображаются все команды, отображается, когда пользователь выбирает команду. Когда пользователь выбирает команду из подменю, *нидвербмин* отправляется, если выбрана первая команда, *нидвербмин* + 1 отправляется, если выбрана вторая команда и т. д. Реализация по умолчанию `COleDocument` автоматически обрабатывает эту функцию.

В скрипте ресурса приложения клиента должна быть следующая инструкция (. RC):

**#include \<afxolecl.rc>**

### <a name="requirements"></a>Требования

**Заголовок**: афксоле.h

## <a name="afxoleunlockcontrol"></a><a name="afxoleunlockcontrol"></a> афксолеунлоккконтрол

Разблокирует фабрику класса указанного элемента управления.

### <a name="syntax"></a>Синтаксис

```
BOOL AFXAPI AfxOleUnlockControl( REFCLSID clsid );
BOOL AFXAPI AfxOleUnlockControl( LPCTSTR lpszProgID );
```

### <a name="parameters"></a>Параметры

*этому*<br/>
Уникальный идентификатор класса элемента управления.

*лпсзпрогид*<br/>
Уникальный идентификатор программы элемента управления.

### <a name="return-value"></a>Возвращаемое значение

Ненулевое значение, если фабрика класса элемента управления была успешно разблокирована; в противном случае — 0.

### <a name="remarks"></a>Примечания

Элемент управления заблокирован с помощью `AfxOleLockControl` , поэтому динамически создаваемые данные, связанные с элементом управления, остаются в памяти. Это может значительно ускорить отображение элемента управления, поскольку элемент управления не должен создаваться и уничтожаться каждый раз при его отображении. Когда вы будете готовы уничтожить элемент управления, вызовите метод `AfxOleUnlockControl` .

### <a name="example"></a>Пример

```cpp
// Unlock control's (Microsoft Calendar Control) class factory.

AfxOleUnlockControl(_T("MSCAL.Calendar"));
```

### <a name="requirements"></a>Требования

**Заголовок:** afxwin.h

## <a name="see-also"></a>См. также раздел

[Макросы и глобальные объекты](mfc-macros-and-globals.md)<br/>
