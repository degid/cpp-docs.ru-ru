---
title: Схемы событий
ms.date: 09/07/2019
helpviewer_keywords:
- event maps [MFC]
ms.assetid: 1ed53aee-bc53-43cd-834a-6fb935c0d29b
ms.openlocfilehash: aa11dbe1a0a3dc45893d1a05cda0ef1addb9e665
ms.sourcegitcommit: ec6dd97ef3d10b44e0fedaa8e53f41696f49ac7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88837350"
---
# <a name="event-maps"></a>Схемы событий

Всякий раз, когда элемент управления хочет уведомить свой контейнер о том, что произошло какое-либо действие (которое определяется разработчиком элемента управления) (например, нажатие клавиши мыши или изменение состояния элемента управления), оно вызывает функцию, выполняющую события. Эта функция уведомляет контейнер элемента управления о том, что произошло определенное важное действие, выполнив соответствующее событие.

Библиотека Microsoft Foundation Class предлагает модель программирования, оптимизированную для срабатывания событий. В этой модели "карты событий" используются для обозначения того, какие функции инициируют события для конкретного элемента управления. Карты событий содержат по одному макросу для каждого события. Например, схема событий, которая вызывает событие щелчка склада, может выглядеть следующим образом:

[!code-cpp[NVC_MFCAxCtl#16](../../mfc/reference/codesnippet/cpp/event-maps_1.cpp)]

`EVENT_STOCK_CLICK`Макрос указывает, что элемент управления будет запускать событие щелчка акции при каждом обнаружении щелчка мышью. Более подробное описание других событий хранения см. в статье [элементы управления ActiveX: события](../../mfc/mfc-activex-controls-events.md). Также доступны макросы для указания пользовательских событий.

Хотя макросы схемы событий важны, обычно они не вставляются напрямую. Это происходит потому, что окно **свойств** (в **представление классов**) автоматически создает записи сопоставления событий в исходных файлах при его использовании для связывания функций, использующих события, с событиями. Каждый раз, когда требуется изменить или добавить запись схемы событий, можно использовать окно **Свойства** .

Для поддержки сопоставлений событий MFC предоставляет следующие макросы:

## <a name="event-map-macros"></a>Макросы схемы событий

### <a name="event-map-declaration-and-demarcation"></a>Объявление и разделительной схемы событий

|Имя|Описание|
|-|-|
|[DECLARE_EVENT_MAP](#declare_event_map)|Объявляет, что схема событий будет использоваться в классе для соотнесения событий с функциями обработки событий (должна использоваться в объявлении класса).|
|[BEGIN_EVENT_MAP](#begin_event_map)|Начинает определение схемы события (необходимо использовать в реализации класса).|
|[END_EVENT_MAP](#end_event_map)|Завершает определение схемы события (необходимо использовать в реализации класса).|

### <a name="event-mapping-macros"></a>Макросы сопоставления событий

|Имя|Описание|
|-|-|
|[EVENT_CUSTOM](#event_custom)|Указывает, какая функция вызывает событие, которая запускает указанное событие.|
|[EVENT_CUSTOM_ID](#event_custom_id)|Указывает, какая из функций обработки событий будет срабатывать указанное событие с назначенным ИДЕНТИФИКАТОРом диспетчеризации.|

### <a name="message-mapping-macros"></a>Макросы сопоставления сообщений

|Имя|Описание|
|-|-|
|[ON_OLEVERB](#on_oleverb)|Указывает пользовательскую команду, обрабатываемую элементом управления OLE.|
|[ON_STDOLEVERB](#on_stdoleverb)|Переопределяет стандартное сопоставление глагола для элемента управления OLE.|

## <a name="declare_event_map"></a><a name="declare_event_map"></a> DECLARE_EVENT_MAP

Каждый `COleControl` производный класс в программе может предоставить карту событий для указания событий, которые будет срабатывать элемент управления.

```cpp
DECLARE_EVENT_MAP()
```

### <a name="remarks"></a>Примечания

Используйте макрос DECLARE_EVENT_MAP в конце объявления класса. Затем в CPP файл, определяющий функции элементов для класса, используйте макрос BEGIN_EVENT_MAP, записи макросов для каждого события элемента управления и макрос END_EVENT_MAP, чтобы объявить конец списка событий.

Дополнительные сведения о сопоставлении событий см. в статье [элементы управления ActiveX: события](../../mfc/mfc-activex-controls-events.md).

### <a name="requirements"></a>Требования

**Заголовок** afxctl.h

## <a name="begin_event_map"></a><a name="begin_event_map"></a> BEGIN_EVENT_MAP

Начинает определение схемы событий.

```cpp
BEGIN_EVENT_MAP(theClass,  baseClass)
```

### <a name="parameters"></a>Параметры

*секласс*<br/>
Указывает имя класса элемента управления, сопоставленного с этим событием.

*baseClass*<br/>
Задает имя базового класса *секласс*.

### <a name="remarks"></a>Примечания

В файле реализации (. cpp), который определяет функции-члены для класса, запустите схему событий с помощью макроса BEGIN_EVENT_MAP, добавьте записи макросов для каждого события и завершите схему событий с помощью макроса END_EVENT_MAP.

Дополнительные сведения о сопоставлении событий и макросе BEGIN_EVENT_MAP см. в статье [элементы управления ActiveX: события](../../mfc/mfc-activex-controls-events.md).

### <a name="requirements"></a>Требования

**Заголовок** afxctl.h

## <a name="end_event_map"></a><a name="end_event_map"></a> END_EVENT_MAP

Используйте макрос END_EVENT_MAP, чтобы завершить определение схемы событий.

```cpp
END_EVENT_MAP()
```

### <a name="requirements"></a>Требования

**Заголовок** afxctl.h

## <a name="event_custom"></a><a name="event_custom"></a> EVENT_CUSTOM

Определяет запись схемы событий для пользовательского события.

```cpp
EVENT_CUSTOM(pszName, pfnFire,  vtsParams)
```

### <a name="parameters"></a>Параметры

*pszName*<br/>
Имя события.

*пфнфире*<br/>
Имя функции обработки события.

*втспарамс*<br/>
Список с разделителями-пробелами одной или нескольких констант, указывающих список параметров функции.

### <a name="remarks"></a>Примечания

Параметр *втспарамс* представляет собой разделенный пробелами список значений `VTS_` констант. Одно или несколько из этих значений, разделенных пробелами (а не запятыми), задает список параметров функции. Пример:

[!code-cpp[NVC_MFCActiveXControl#13](../../mfc/codesnippet/cpp/event-maps_2.cpp)]

Задает список, содержащий 32-разрядное целое число, представляющее значение цвета RGB, за которым следует указатель на `IFontDisp` интерфейс объекта ШРИФТА OLE.

`VTS_`Ниже приведены константы и их значения.

|Символ|Тип параметра|
|------------|--------------------|
|VTS_I2|**`short`**|
|VTS_I4|**`long`**|
|VTS_R4|**`float`**|
|VTS_R8|**`double`**|
|VTS_COLOR|OLE_COLOR|
|VTS_CY|ДЕНЕЖНАЯ ЕДИНИЦА|
|VTS_DATE|DATE|
|VTS_BSTR|**`const`**__тип \* char__|
|VTS_DISPATCH|лпдиспатч|
|VTS_FONT|`IFontDispatch*`|
|VTS_HANDLE|HANDLE|
|VTS_SCODE|SCODE|
|VTS_BOOL|BOOL|
|VTS_VARIANT|`const VARIANT*`|
|VTS_PVARIANT|`VARIANT*`|
|VTS_UNKNOWN|лпункновн|
|VTS_OPTEXCLUSIVE|OLE_OPTEXCLUSIVE|
|VTS_PICTURE|`IPictureDisp*`|
|VTS_TRISTATE|OLE_TRISTATE|
|VTS_XPOS_PIXELS|OLE_XPOS_PIXELS|
|VTS_YPOS_PIXELS|OLE_YPOS_PIXELS|
|VTS_XSIZE_PIXELS|OLE_XSIZE_PIXELS|
|VTS_YSIZE_PIXELS|OLE_YSIZE_PIXELS|
|TS_XPOS_HIMETRIC|OLE_XPOS_HIMETRIC|
|VTS_YPOS_HIMETRIC|OLE_YPOS_HIMETRIC|
|VTS_XSIZE_HIMETRIC|OLE_XSIZE_HIMETRIC|
|VTS_YSIZE_HIMETRIC|OLE_YSIZE_HIMETRIC|

> [!NOTE]
> Дополнительные константы типа Variant определены для всех типов Variant, за исключением VTS_FONT и VTS_PICTURE, которые предоставляют указатель на константу данных Variant. Эти константы именуются с помощью `VTS_Pconstantname` соглашения. Например, VTS_PCOLOR является указателем на VTS_COLORую константу.

### <a name="requirements"></a>Требования

**Заголовок** afxctl.h

## <a name="event_custom_id"></a><a name="event_custom_id"></a> EVENT_CUSTOM_ID

Определяет функцию обработки события для пользовательского события, принадлежащего ИДЕНТИФИКАТОРу диспетчеризации, заданному *DISPID*.

```cpp
EVENT_CUSTOM_ID(
    pszName,
    dispid,
    pfnFire,
    vtsParams)
```

### <a name="parameters"></a>Параметры

*pszName*<br/>
Имя события.

*DISPID*<br/>
Идентификатор диспетчеризации, используемый элементом управления при срабатывании события.

*пфнфире*<br/>
Имя функции обработки события.

*втспарамс*<br/>
Список переменных параметров, передаваемых в контейнер элемента управления при срабатывании события.

### <a name="remarks"></a>Примечания

Аргумент *втспарамс* представляет собой разделенный пробелами список значений `VTS_` констант. Одно или несколько из этих значений, разделенных пробелами, а не запятыми, указывает список параметров функции. Пример:

[!code-cpp[NVC_MFCActiveXControl#13](../../mfc/codesnippet/cpp/event-maps_2.cpp)]

Задает список, содержащий 32-разрядное целое число, представляющее значение цвета RGB, за которым следует указатель на `IFontDisp` интерфейс объекта ШРИФТА OLE.

Список `VTS_` констант см. в разделе [EVENT_CUSTOM](#event_custom).

### <a name="requirements"></a>Требования

**Заголовок** afxctl.h

## <a name="on_oleverb"></a><a name="on_oleverb"></a> ON_OLEVERB

Этот макрос определяет запись схемы сообщений, которая сопоставляет пользовательскую команду с определенной функцией-членом элемента управления.

```cpp
ON_OLEVERB(idsVerbName,  memberFxn)
```

### <a name="parameters"></a>Параметры

*идсвербнаме*<br/>
Строковый идентификатор ресурса имени команды.

*мемберфксн*<br/>
Функция, вызываемая платформой при вызове команды.

### <a name="remarks"></a>Примечания

Редактор ресурсов можно использовать для создания настраиваемых имен глаголов, добавляемых в таблицу строк.

Прототип функции для *мемберфксн* :

```cpp
BOOL memberFxn(
   LPMSG    lpMsg,
   HWND     hWndParent,
   LPCRECT  lpRect);
```

Значения параметров *лпмсг*, *хвндпарент*и *лпрект* берутся из соответствующих параметров `IOleObject::DoVerb` функции члена.

### <a name="requirements"></a>Требования

**Заголовок** афксоле.h

## <a name="on_stdoleverb"></a><a name="on_stdoleverb"></a> ON_STDOLEVERB

Используйте этот макрос, чтобы переопределить поведение стандартной команды по умолчанию.

```cpp
ON_STDOLEVERB(iVerb, memberFxn)
```

### <a name="parameters"></a>Параметры

*иверб*<br/>
Стандартный индекс глагола для переопределяемой команды.

*мемберфксн*<br/>
Функция, вызываемая платформой при вызове команды.

### <a name="remarks"></a>Примечания

Стандартный индекс команды имеет форму `OLEIVERB_` , за которой следует действие. OLEIVERB_SHOW, OLEIVERB_HIDE и OLEIVERB_UIACTIVATE являются примерами стандартных глаголов.

Описание прототипа функции, которое будет использоваться в качестве параметра *мемберфксн* , см. в разделе [ON_OLEVERB](#on_oleverb) .

### <a name="requirements"></a>Требования

**Заголовок** афксоле.h

## <a name="see-also"></a>См. также раздел

[Макросы и глобальные объекты](../../mfc/reference/mfc-macros-and-globals.md)
