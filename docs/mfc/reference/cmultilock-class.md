---
title: Класс CMultiLock
ms.date: 11/04/2016
f1_keywords:
- CMultiLock
- AFXMT/CMultiLock
- AFXMT/CMultiLock::CMultiLock
- AFXMT/CMultiLock::IsLocked
- AFXMT/CMultiLock::Lock
- AFXMT/CMultiLock::Unlock
helpviewer_keywords:
- CMultiLock [MFC], CMultiLock
- CMultiLock [MFC], IsLocked
- CMultiLock [MFC], Lock
- CMultiLock [MFC], Unlock
ms.assetid: c5b7c78b-1f81-4387-b7dd-2c813c5b6b61
ms.openlocfilehash: a051c6a510c53ac0c7c0a6efd8b4b5720080b264
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81319712"
---
# <a name="cmultilock-class"></a>Класс CMultiLock

Класс представляет механизм контроля доступа к ресурсам в многопоточных программах.

## <a name="syntax"></a>Синтаксис

```
class CMultiLock
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[CMultiLock::CMultiLock](#cmultilock)|Формирует объект `CMultiLock`.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[CMultiLock::Заблокирован](#islocked)|Определяет, заблокирован ли конкретный объект синхронизации в массиве.|
|[CMultiLock::Lock](#lock)|Ожидания на массиве объектов синхронизации.|
|[CMultiLock::Разблокировка](#unlock)|Выпускает любые принадлежащие объекты синхронизации.|

## <a name="remarks"></a>Примечания

`CMultiLock`не имеет базового класса.

Для использования классов синхронизации [CSemaphore,](../../mfc/reference/csemaphore-class.md) [CMutex](../../mfc/reference/cmutex-class.md)и [CEvent](../../mfc/reference/cevent-class.md)можно `CMultiLock` создать объект [CSingleLock](../../mfc/reference/csinglelock-class.md) для ожидания и выпуска объекта синхронизации. Используйте, `CMultiLock` когда есть несколько объектов, которые можно использовать в определенное время. Используйте, `CSingleLock` когда вам нужно только ждать на одном объекте за один раз.

Чтобы использовать `CMultiLock` объект, сначала создайте массив объектов синхронизации, которые вы хотите ждать. Затем позвоните `CMultiLock` в конструктор объекта внутри функции члена в классе контролируемого ресурса. Затем позвоните в функцию члена [блокировки,](#lock) чтобы определить, доступен ли ресурс (сигнал). Если это так, продолжайте оставшуюся часть функции члена. Если ресурс отсутствует, либо подождите определенное время для выпуска ресурса, либо сбой возврата. После завершения использования ресурса либо вызов [функции разблокировки,](#unlock) если `CMultiLock` объект `CMultiLock` будет использован снова, либо позвольте уничтожению объекта.

`CMultiLock`объекты наиболее полезны, когда `CEvent` поток имеет большое количество объектов, на которые он может реагировать. Создайте массив, `CEvent` содержащий все указатели, и вызов. `Lock` Это приведет к тому, что поток будет ждать, пока будет сигнализировано одно из событий.

Для получения дополнительной информации о том, как использовать `CMultiLock` объекты, смотрите статью [Многопоточность: Как использовать классы синхронизации](../../parallel/multithreading-how-to-use-the-synchronization-classes.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`CMultiLock`

## <a name="requirements"></a>Требования

**Заголовок:** afxmt.h

## <a name="cmultilockcmultilock"></a><a name="cmultilock"></a>CMultiLock::CMultiLock

Формирует объект `CMultiLock`.

```
CMultiLock(
    CSyncObject* ppObjects [ ],
    DWORD dwCount,
    BOOL bInitialLock = FALSE);
```

### <a name="parameters"></a>Параметры

*ppОбъекты*<br/>
Массив указателей на объекты синхронизации, на которые следует ждать. Не может быть NULL.

*dwCount*<br/>
Количество объектов в *ppObjects*. Должно быть больше 0.

*bInitialLock*<br/>
Уточняется, следует ли сначала пытаться получить доступ к любому из поставляемых объектов.

### <a name="remarks"></a>Примечания

Эта функция вызывается после создания массива объектов синхронизации, на которые следует ждать. Обычно он вызывается из потока, который должен ждать, пока один из объектов синхронизации станет доступным.

## <a name="cmultilockislocked"></a><a name="islocked"></a>CMultiLock::Заблокирован

Определяет, не сигнализируется ли указанный объект (недоступен).

```
BOOL IsLocked(DWORD dwItem);
```

### <a name="parameters"></a>Параметры

*dwItem*<br/>
Индекс в массиве объектов, соответствующих объекту, состояние которого запрашивается.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если указанный объект заблокирован; в противном случае 0.

## <a name="cmultilocklock"></a><a name="lock"></a>CMultiLock::Lock

Вызовите эту функцию, чтобы получить доступ к одному или несколько `CMultiLock` ресурсам, контролируемым объектами синхронизации, поставляемыми конструктору.

```
DWORD Lock(
    DWORD dwTimeOut = INFINITE,
    BOOL bWaitForAll = TRUE,
    DWORD dwWakeMask = 0);
```

### <a name="parameters"></a>Параметры

*dwTimeOut*<br/>
Определяетвремя время ожидания объекта синхронизации (сигнал). Если INFINITE, будет ждать, `Lock` пока объект сигнализируется перед возвращением.

*bWaitForAll*<br/>
Определяет, должны ли все объекты, дожидаявшиеся, быть сигнализировать одновременно перед возвращением. Если FALSE, вернется, `Lock` когда любой из объектов, ожидаемых на сигнал.

*dwWakeМаск*<br/>
Упомягляет другие условия, которые могут прервать ожидание. Полный список доступных опций для этого параметра можно найти в [SDK с мсГWaitForMultipleObjects.](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects)

### <a name="return-value"></a>Возвращаемое значение

Если `Lock` не удается, он возвращается - 1. В случае успеха он возвращает одно из следующих значений:

- Между WAIT_OBJECT_0 и WAIT_OBJECT_0 ( количество объектов - 1)

   Если *bWaitForAll* является правдой, все объекты сигнализируются (доступно). Если *bWaitForAll* является FALSE, значение возврата - WAIT_OBJECT_0 является индексом в массиве объектов объекта, который сигнализируется (доступен).

- WAIT_OBJECT_0 - количество объектов)

   Событие, указанное в *dwWakeMask,* доступно в очереди ввода потока.

- Между WAIT_ABANDONED_0 и WAIT_ABANDONED_0 ( количество объектов - 1)

   Если *bWaitForAll* является правдой, все объекты сигнализируются, и по крайней мере один из объектов является заброшенным объектом mutex. Если *bWaitForAll* является FALSE, то значение возврата - WAIT_ABANDONED_0 является индексом в массиве объектов заброшенного объекта mutex, удовлетворяющих ожидание.

- WAIT_TIMEOUT

   Интервал тайм-аута, указанный в *dwTimeOut,* истек без последующего ожидания.

### <a name="remarks"></a>Примечания

Если *bWaitForAll* является `Lock` правдой, вернется успешно, как только все объекты синхронизации становятся сигнализировать одновременно. Если *bWaitForAll* является `Lock` FALSE, вернется, как только один или несколько объектов синхронизации становится сигналом.

Если `Lock` он не сможет вернуться немедленно, он будет ждать не больше, чем количество миллисекунд, указанных в параметре *dwTimeOut* перед возвращением. Если *dwTimeOut* является `Lock` INFINITE, не вернется до тех пор, пока не будет получен доступ к объекту или не будет выполнено условие, указанное в *dwWakeMask.* В противном случае, если `Lock` удалось приобрести объект синхронизации, он успешно вернется; если нет, то это вернет неудачу.

## <a name="cmultilockunlock"></a><a name="unlock"></a>CMultiLock::Разблокировка

Выпускает объект синхронизации, принадлежащий `CMultiLock`.

```
BOOL Unlock();

BOOL Unlock(
    LONG lCount,
    LPLONG lPrevCount = NULL);
```

### <a name="parameters"></a>Параметры

*lCount*<br/>
Количество отсчетов ссылок на освобождение. Должно быть больше 0. Если указанная сумма приведет к тому, что количество объекта превысит его максимальный уклад, количество не изменяется, а функция возвращает FALSE.

*lPrevCount*<br/>
Очки переменной для получения предыдущего счета для объекта синхронизации. Если NULL, предыдущий подсчет не возвращается.

### <a name="return-value"></a>Возвращаемое значение

Nonzero, если функция была успешной; в противном случае 0.

### <a name="remarks"></a>Примечания

Эта функция называется `CMultiLock`'s destructor.

Первая форма `Unlock` пытается разблокировать объект синхронизации, `CMultiLock`управляемый . Вторая форма `Unlock` пытается разблокировать объекты, принадлежащие `CSemaphore` . `CMultiLock` Если `CMultiLock` нет какого-либо заблокированного `CSemaphore` объекта, функция возвращает FALSE; в противном случае, он возвращает TRUE. *lCount* и *lpPrevCount* точно такие же, как параметры [CSingleLock::Unlock](../../mfc/reference/csinglelock-class.md#unlock). Вторая форма `Unlock` редко применима к многоблокивные ситуации.

## <a name="see-also"></a>См. также раздел

[Диаграмма иерархии](../../mfc/hierarchy-chart.md)
