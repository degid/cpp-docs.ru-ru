---
title: TN006. Схемы сообщений
ms.date: 06/25/2018
f1_keywords:
- vc.messages.maps
helpviewer_keywords:
- ON_UPDATE_COMMAND_UI macro [MFC]
- ON_NOTIFY_RANGE macro [MFC]
- ON_COMMAND macro [MFC]
- ON_CONTROL_RANGE macro [MFC]
- ON_REGISTERED_MESSAGE macro [MFC]
- ON_NOTIFY message [MFC]
- ON_COMMAND_RANGE_EX macro [MFC]
- ON_MESSAGE macro [MFC]
- Windows messages [MFC], message maps
- ON_COMMAND_RANGE macro [MFC]
- TN006
- ON_CONTROL macro [MFC]
- ON_COMMAND_EX macro [MFC]
- message maps [MFC], Windows messaging
ms.assetid: af4b6794-4b40-4f1e-ad41-603c3b7409bb
ms.openlocfilehash: 6b387b851f5a76cd0d11957a87e57307d624759e
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87228535"
---
# <a name="tn006-message-maps"></a>TN006. Схемы сообщений

Это примечание описывает средство "схема сообщений MFC".

## <a name="the-problem"></a>Проблема

Microsoft Windows реализует виртуальные функции в классах Window, которые используют его механизм обмена сообщениями. Из-за большого количества вовлеченных сообщений предоставление отдельной виртуальной функции для каждого сообщения Windows приведет к созданию чрезмерно большого размера таблицы vtable.

Так как количество системных сообщений Windows изменяется с течением времени, а приложения могут определять свои сообщения Windows, схемы сообщений обеспечивают уровень косвенного обращения, который предотвращает изменение интерфейса от повреждения существующего кода.

## <a name="overview"></a>Обзор

MFC предоставляет альтернативу оператору switch, который использовался в традиционных программах на основе Windows для работы с сообщениями, отправленными в окно. Сопоставление сообщений с методами может быть определено таким образом, что при получении сообщения окном соответствующий метод вызывается автоматически. Этот механизм сопоставлений сообщений напоминает виртуальные функции, но обладает дополнительными преимуществами, которые невозможно реализовать с помощью виртуальных функций C++.

## <a name="defining-a-message-map"></a>Определение схемы сообщений

Макрос [DECLARE_MESSAGE_MAP](reference/message-map-macros-mfc.md#declare_message_map) объявляет три члена для класса.

- Частный массив записей AFX_MSGMAP_ENTRY с именем *_messageEntries*.

- Защищенная структура AFX_MSGMAP с именем *мессажемап* , указывающая на массив *_messageEntries* .

- Защищенная виртуальная функция `GetMessageMap` с именем, которая возвращает адрес *мессажемап*.

Этот макрос должен быть размещен в объявлении любого класса с помощью карт сообщений. По соглашению он находится в конце объявления класса. Например:

```cpp
class CMyWnd : public CMyParentWndClass
{
    // my stuff...

protected:
    //{{AFX_MSG(CMyWnd)
    afx_msg void OnPaint();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};
```

Это формат, создаваемый помощью мастера и ClassWizard при создании новых классов. Для ClassWizard требуются квадратные скобки//{{и//}}.

Таблица схемы сообщений определяется с помощью набора макросов, которые расширяются до записей схемы сообщений. Таблица начинается с вызова макроса [BEGIN_MESSAGE_MAP](reference/message-map-macros-mfc.md#begin_message_map) , который определяет класс, обрабатываемый этой схемой сообщений, и родительский класс, в который передаются необработанные сообщения. Таблица заканчивается вызовом макроса [END_MESSAGE_MAP](reference/message-map-macros-mfc.md#end_message_map) .

Между этими двумя вызовами макросов находится запись для каждого сообщения, обрабатываемого этой схемой сообщений. Каждое стандартное сообщение Windows имеет макрос формы ON_WM_*MESSAGE_NAME* , который создает запись для этого сообщения.

Для распаковки параметров каждого сообщения Windows и обеспечения безопасности типов определена стандартная сигнатура функции. Эти подписи можно найти в файле Afxwin.h в объявлении [CWnd](../mfc/reference/cwnd-class.md). Каждый из них помечается ключевым словом **afx_msg** для простоты идентификации.

> [!NOTE]
> ClassWizard требует использования ключевого слова **afx_msg** в объявлениях обработчика схемы сообщений.

Эти сигнатуры функций были получены с помощью простого соглашения. Имя функции всегда начинается с `"On` ". За ним следует имя сообщения Windows с удаленным "WM_", а также первая буква каждого слова, написанного прописными буквами. Порядок параметров — *wParam* , за которым следует `LOWORD` (*lParam*) then `HIWORD` (*lParam*). Неиспользуемые параметры не передаются. Все дескрипторы, обтекаемые классами MFC, преобразуются в указатели на соответствующие объекты MFC. В следующем примере показано, как обрабатывать сообщение WM_PAINT и вызывать `CMyWnd::OnPaint` функцию:

```cpp
BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
    //{{AFX_MSG_MAP(CMyWnd)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
```

Таблица схемы сообщений должна быть определена вне области определения функции или класса. Его не следует поставлять в блок с модификатором extern "C".

> [!NOTE]
> ClassWizard изменит записи схемы сообщений, которые происходят между скобками комментария//{{and//}}.

## <a name="user-defined-windows-messages"></a>Пользовательские сообщения Windows

Определяемые пользователем сообщения могут включаться в схему сообщений с помощью макроса [ON_MESSAGE](reference/message-map-macros-mfc.md#on_message) . Этот макрос принимает номер сообщения и метод формы:

```cpp
    // inside the class declaration
    afx_msg LRESULT OnMyMessage(WPARAM wParam, LPARAM lParam);

    #define WM_MYMESSAGE (WM_USER + 100)

BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
    ON_MESSAGE(WM_MYMESSAGE, OnMyMessage)
END_MESSAGE_MAP()
```

В этом примере мы создаем обработчик для пользовательского сообщения с ИДЕНТИФИКАТОРом сообщения Windows, полученным из стандартной WM_USERной базы для определяемых пользователем сообщений. В следующем примере показано, как вызвать этот обработчик:

```cpp
CWnd* pWnd = ...;
pWnd->SendMessage(WM_MYMESSAGE);
```

Диапазон определяемых пользователем сообщений, использующих этот подход, должен находиться в диапазоне WM_USER 0x7FFF.

> [!NOTE]
> ClassWizard не поддерживает ввод подпрограмм обработчика ON_MESSAGE из пользовательского интерфейса ClassWizard. Их необходимо ввести вручную в редакторе Visual C++. ClassWizard будет анализировать эти записи и просматривать их так же, как и любые другие записи схемы сообщений.

## <a name="registered-windows-messages"></a>Зарегистрированные сообщения Windows

Функция [регистервиндовмессаже](/windows/win32/api/winuser/nf-winuser-registerwindowmessagew) используется для определения нового сообщения окна, которое гарантированно уникально в пределах всей системы. Макрос ON_REGISTERED_MESSAGE используется для обработки этих сообщений. Этот макрос принимает имя переменной *UINT NEAR* , содержащей зарегистрированный идентификатор сообщения Windows. Например.

```cpp
class CMyWnd : public CMyParentWndClass
{
public:
    CMyWnd();

    //{{AFX_MSG(CMyWnd)
    afx_msg LRESULT OnFind(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

static UINT NEAR WM_FIND = RegisterWindowMessage("COMMDLG_FIND");

BEGIN_MESSAGE_MAP(CMyWnd, CMyParentWndClass)
    //{{AFX_MSG_MAP(CMyWnd)
    ON_REGISTERED_MESSAGE(WM_FIND, OnFind)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
```

Зарегистрированная переменная идентификатора сообщения Windows (WM_FIND в этом примере) должна быть *ближней* переменной из-за способа реализации ON_REGISTERED_MESSAGE.

Диапазон определяемых пользователем сообщений, использующих этот подход, будет находиться в диапазоне от 0xC000 до 0xFFFF.

> [!NOTE]
> ClassWizard не поддерживает ввод подпрограмм обработчика ON_REGISTERED_MESSAGE из пользовательского интерфейса ClassWizard. Их необходимо ввести вручную в текстовом редакторе. ClassWizard будет анализировать эти записи и просматривать их так же, как и любые другие записи схемы сообщений.

## <a name="command-messages"></a>Сообщения команды

Командные сообщения из меню и ускорителей обрабатываются в картах сообщений с помощью макроса ON_COMMAND. Этот макрос принимает идентификатор команды и метод. Только конкретное WM_COMMAND сообщение с параметром *wParam* , равным УКАЗАНному идентификатору команды, обрабатывается методом, указанным в записи схемы сообщений. Функции члена обработчика команд не принимают параметров и возвращают **`void`** . Макрос имеет следующую форму:

```cpp
ON_COMMAND(id, memberFxn)
```

Сообщения обновления команды направляются через тот же механизм, но вместо этого используйте ON_UPDATE_COMMAND_UI макрос. Функции-члены обработчика обновления команды принимают один параметр, указатель на объект [Поддержка CCmdUI](../mfc/reference/ccmdui-class.md) и возвращают **`void`** . Макрос имеет форму

```cpp
ON_UPDATE_COMMAND_UI(id, memberFxn)
```

Опытные пользователи могут использовать макрос ON_COMMAND_EX, который является расширенной формой обработчиков командных сообщений. Макрос предоставляет надмножество функциональных возможностей ON_COMMAND. Расширенные функции-члены обработчика команд принимают один параметр, **uint** , который содержит идентификатор команды, и возвращают **логическое**значение. Чтобы указать, что команда была обработана, возвращаемое значение должно быть **равно true** . В противном случае маршрутизация продолжит другие целевые объекты команды.

Примеры следующих форм:

- Внутри Resource.h (обычно создается с помощью Visual C++)

    ```cpp
    #define    ID_MYCMD      100
    #define    ID_COMPLEX    101
    ```

- Внутри объявления класса

    ```cpp
    afx_msg void OnMyCommand();
    afx_msg void OnUpdateMyCommand(CCmdUI* pCmdUI);
    afx_msg BOOL OnComplexCommand(UINT nID);
    ```

- Внутри определения схемы сообщений

    ```cpp
    ON_COMMAND(ID_MYCMD, OnMyCommand)
    ON_UPDATE_COMMAND_UI(ID_MYCMD, OnUpdateMyCommand)
    ON_COMMAND_EX(ID_MYCMD, OnComplexCommand)
    ```

- В файле реализации

    ```cpp
    void CMyClass::OnMyCommand()
    {
        // handle the command
    }

    void CMyClass::OnUpdateMyCommand(CCmdUI* pCmdUI)
    {
        // set the UI state with pCmdUI
    }

    BOOL CMyClass::OnComplexCommand(UINT nID)
    {
        // handle the command
        return TRUE;
    }
    ```

Опытные пользователи могут выполнять ряд команд с помощью одного обработчика команд: [ON_COMMAND_RANGE](reference/message-map-macros-mfc.md#on_command_range) или ON_COMMAND_RANGE_EX. Дополнительные сведения об этих макросах см. в документации по продукту.

> [!NOTE]
> ClassWizard поддерживает создание обработчиков ON_COMMAND и ON_UPDATE_COMMAND_UI, но не поддерживает создание обработчиков ON_COMMAND_EX или ON_COMMAND_RANGE. Однако мастер классов будет анализировать и просматривать все четыре варианта обработчика команд.

## <a name="control-notification-messages"></a>Управление сообщениями уведомления

Сообщения, отправленные из дочерних элементов управления в окно, имеют дополнительный бит информации в записи схемы сообщений: идентификатор элемента управления. Обработчик сообщений, указанный в записи схемы сообщений, вызывается только в том случае, если выполняются следующие условия.

- Код уведомления элемента управления (высокое слово *lParam*), например BN_CLICKED, соответствует коду уведомления, указанному в записи схемы сообщений.

- Идентификатор элемента управления (*wParam*) соответствует идентификатору элемента управления, указанному в записи схемы сообщений.

Сообщения уведомления пользовательского элемента управления могут использовать макрос [ON_CONTROL](reference/message-map-macros-mfc.md#on_control) для определения записи схемы сообщений с пользовательским кодом уведомления. Этот макрос имеет форму

```cpp
ON_CONTROL(wNotificationCode, id, memberFxn)
```

Для расширенного использования [ON_CONTROL_RANGE](reference/message-map-macros-mfc.md#on_control_range) можно использовать для обработки конкретного уведомления элемента управления из диапазона элементов управления с тем же обработчиком.

> [!NOTE]
> ClassWizard не поддерживает создание обработчика ON_CONTROL или ON_CONTROL_RANGE в пользовательском интерфейсе. Их необходимо ввести вручную в текстовом редакторе. ClassWizard будет анализировать эти записи и просматривать их так же, как и любые другие записи схемы сообщений.

Общие элементы управления Windows используют более мощные [WM_NOTIFY](/windows/win32/controls/wm-notify) для сложных управляющих уведомлений. Эта версия MFC напрямую поддерживает это новое сообщение с помощью макросов ON_NOTIFY и ON_NOTIFY_RANGE. Дополнительные сведения об этих макросах см. в документации по продукту.

## <a name="see-also"></a>См. также статью

[Технические примечания по номеру](../mfc/technical-notes-by-number.md)<br/>
[Технические примечания по категориям](../mfc/technical-notes-by-category.md)
