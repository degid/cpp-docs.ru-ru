---
title: C26446
description: Предупреждение анализа кода Microsoft C++ C26446 для C++ Core Guidelinesных границ вариантов. 4.
ms.date: 08/21/2010
ms.topic: reference
f1_keywords:
- C26446
helpviewer_keywords:
- C26446
ms.openlocfilehash: ad3e529aa65797bc8b2a2c12b29007844c58e070
ms.sourcegitcommit: ec6dd97ef3d10b44e0fedaa8e53f41696f49ac7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/25/2020
ms.locfileid: "88843343"
---
# <a name="c26446-use_gsl_at"></a>C26446 USE_GSL_AT

> `Prefer to use gsl::at() instead of unchecked subscript operator (bounds.4).`

C++ Core Guidelines: [Bounds. 4: не используйте функции и типы стандартной библиотеки, которые не имеют установленных ограничений](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#probounds-bounds-safety-profile).

## <a name="remarks"></a>Примечания

Профиль границ C++ Core Guidelines пытается устранить незащищенные манипуляции с памятью. Это позволяет избежать использования необработанных указателей и непроверенных операций. Один из способов выполнить однородный доступ по диапазону для буферов заключается в использовании `gsl::at()` программы из библиотеки поддержки руководств. Также рекомендуется использовать стандартные реализации, `at()` Доступные в контейнерах STL.

Это правило помогает находить места, где потенциально непроверенный доступ выполняется через вызовы `operator[]` . В большинстве случаев такие вызовы можно заменить с помощью `gsl::at()` .

- Доступ к массивам известного размера помечается при использовании неконстантного индекса в операторе подстрочных индексов. Постоянные индексы обрабатываются [C26483 STATIC_INDEX_OUT_OF_RANGE](c26483.md).
- Логика для предупреждения о перегруженных `operator[]` вызовах более сложная:
  - Если индекс не является целочисленным, вызов игнорируется. Это также обрабатывает индексирование в стандартных картах, так как параметры в таких операторах передаются по ссылке.
  - Если оператор помечен как не создающий исключение (с помощью **`noexcept`** , **`throw()`** или **`__declspec(nothrow)`** ), вызов помечается флагом. Предполагается, что если оператор индекса никогда не создает исключения, он либо не выполняет проверку диапазона, либо эти проверки скрываются.
  - Если оператор не помечен как не создающий исключение, он может быть помечен, если он поступает из контейнера STL, который также определяет обычную `at()` функцию-член. Такие функции обнаруживаются простым сопоставлением имен.
  - Правило не предупреждает о вызовах стандартных `at()` функций. Эти функции являются надежными; замена их на не `gsl::at()` приносит большого значения.
- Индексирование в `std::basic_string_view<>` является ненадежным, поэтому выдается предупреждение. Замените стандарт `string_view` с помощью `gsl::basic_string_span<>` , который всегда имеет значение Checked.
- Реализация не учитывает проверку диапазона, что пользовательский код может находиться где-либо в циклах или ветвях. Точность здесь является компромиссной для повышения производительности. Как правило, вы часто можете заменить явные проверки диапазона с помощью более надежных итераторов или более кратких улучшенных **`for`** циклов.

## <a name="example"></a>Пример

В этом примере показано, как `gsl::at` функция может заменить индексированную ссылку:

```cpp
// C26446.cpp
#include <vector>
#include <gsl/gsl_util>
#include <iostream>

void fn()
{
    std::vector<int> v{1, 2, 3, 4, 5};
  
    // Normal bracket operators do not prevent you from accessing memory out of bounds.
    std::cout << v[5] << '\n';  // C26446, prefer using gsl::at instead of using operator[]. 
  
    // gsl::at prevents accessing memory out of bounds and invokes std::terminate on access.
    std::cout << gsl::at(v, 5) << '\n'; 
}
```
