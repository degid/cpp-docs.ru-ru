---
title: C26415
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26415
helpviewer_keywords:
- C26415
ms.assetid: 4165f70a-78ae-4a03-b256-c4bd74b02d09
ms.openlocfilehash: 45bfdd891cecb029d6abb8dabb222780a0d17f56
ms.sourcegitcommit: c1fd917a8c06c6504f66f66315ff352d0c046700
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2020
ms.locfileid: "90685402"
---
# <a name="c26415-smart_ptr_not_needed"></a>C26415 SMART_PTR_NOT_NEEDED

"Параметр интеллектуального указателя используется только для доступа к содержащему указателю. Вместо этого используйте T * или T& ".

**C++ Core Guidelines**: [R. 30](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r30-take-smart-pointers-as-parameters-only-to-explicitly-express-lifetime-semantics): использовать интеллектуальные указатели как параметры только для явного выражения семантики времени существования

Использование типа интеллектуального указателя для передачи данных в функцию указывает, что целевой функции необходимо управлять временем существования автономного объекта. Однако если функция использует только смарт-указатель для доступа к вложенному объекту и никогда не вызывает код, который может привести к его освобождению (то есть не влияет на его время существования), обычно нет необходимости затруднить интерфейс интеллектуальными указателями. Предпочтительным является простой указатель или ссылка на содержащий объект.

## <a name="remarks"></a>Примечания

Эта проверка охватывает большинство сценариев, которые также вызывают C26410, C26415, C26417 и C26418. Лучше сначала выполнить очистку SMART_PTR_NOT_NEEDED, а затем переключиться на граничные варианты для общих или уникальных указателей. Для более тщательной очистки это предупреждение можно отключить.

В дополнение к стандартным шаблонам std::unqiue_pointer и std::shared_pointer эта проверка распознает определяемые пользователем типы, которые, скорее всего, будут смарт-указателями. Такие типы должны определять следующие операции:

- Перегруженные операторы разыменования или доступа к членам, которые являются открытыми и не помечены как удаленные.
- Открытый деструктор, который не удален или установлен по умолчанию. Сюда входят деструкторы, явно определенные как пустые.

Интерпретация операций, которые могут повлиять на время существования содержащихся объектов, является широкой и включает:

- Любая функция, которая принимает параметр указателя или ссылки на неконстантный интеллектуальный указатель
- Конструкторы копирования или перемещения или операторы присваивания
- Неконстантные функции

## <a name="examples"></a>Примеры

Громоздкий жизненный цикл управления.

```cpp
bool set_initial_message(
            const std::unique_ptr<message> &m) // C26415, also C26410 NO_REF_TO_CONST_UNIQUE_PTR
{
    if (!m || initial_message_)
        return false;

    initial_message_.reset(m.get());
    return true;
}

void pass_message(const message_info &info)
{
    auto m = std::make_unique<message>(info);
    const auto release = set_initial_message(m);
    // ...
    if (release)
        m.release();
}
```

Нетрудоемкое управление жизненным циклом — переработано.

```cpp
void set_initial_message(std::shared_ptr<message> m) noexcept
{
    if (m && !initial_message_)
        initial_message_ = std::move(m);
}

void pass_message(const message_info &info)
{
    auto m = std::make_shared<message>(info);
    set_initial_message(m);
    // ...
}
```
