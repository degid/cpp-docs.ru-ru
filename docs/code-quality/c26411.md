---
title: C26411
ms.date: 08/19/2020
ms.topic: conceptual
f1_keywords:
- C26411
helpviewer_keywords:
- C26411
ms.assetid: 5134e51e-8b92-4ee7-94c3-022e318a0e24
ms.openlocfilehash: e1d812b9d5080d39098c36d185a2dcaa9fcdebf1
ms.sourcegitcommit: f1752bf90b4f869633a859ace85439ca19e208b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "88722132"
---
# <a name="c26411--no_ref_to_unique_ptr"></a>C26411 NO_REF_TO_UNIQUE_PTR

При передаче уникального указателя на функцию по ссылке он подразумевает, что его ресурс может быть освобожден или передан внутри функции. Если функция использует ее параметр только для доступа к ресурсу, можно передать необработанный указатель или ссылку. Дополнительные сведения см. в разделе [C++ Core Guidelines Rule R. 33](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r33-take-a-unique_ptrwidget-parameter-to-express-that-a-function-reseats-thewidget): *возьмем \<widget\> параметр unique_ptr&, чтобы выражать, что функция перестает мини-* приложение.

## <a name="remarks"></a>Примечания

- Здесь также применимы ограничения [C26410](C26410.md) предупреждений.

- Эвристическим подходом для обнаружения `release` или `reset` доступа к уникальному указателю является наивный. Мы обнаруживаем вызовы только для операторов присваивания и для функций с именем `reset` (без учета регистра). Очевидно, что это обнаружение не охватывает все возможные случаи изменения интеллектуальных указателей. (Например, он не обнаруживает `std::swap` или какой-либо специальный **`const`** Нефункциональный элемент в пользовательском интеллектуальном указателе). Мы планируем, что это предупреждение может дать множество ложных срабатываний для пользовательских типов, а в некоторых — в некоторых сценариях, имеющих стандартные уникальные указатели. Мы планируем повысить уровень эвристики, так как мы реализуем дополнительные проверки на смарт-указатели.

- Тот факт, что смарт-указатели часто являются шаблонами, приводит к интересным ограничениям. Компилятору не требуется обрабатывать код шаблона в шаблонах, если он не используется. В коде, который обеспечивает ограниченное использование интерфейсов интеллектуальных указателей, средство проверки может привести к непредвиденным результатам. Средство проверки не может правильно определить семантику типа шаблона, так как некоторые функции не могут использоваться. Для уровня "Стандартный" `std::unique_ptr` это ограничение уменьшается путем распознавания имени типа. Это может быть расширено в будущем для охвата более хорошо известных смарт-указателей.

- Лямбда-выражения, которые выполняют неявные записи по ссылке, могут привести к неожиданным предупреждениям о ссылках на уникальные указатели. В настоящее время возвращаются все заданные ссылочные параметры в лямбда-выражениях независимо от того, сброшены они или нет. В будущем выпуске может расширяться эвристический подход для сопоставления лямбда-полей и лямбда-параметров.

## <a name="example-unnecessary-reference"></a>Пример: ненужная ссылка

```cpp
void TraceValid(std::unique_ptr<Slot> &slot)    // C26411
{
    if (!IsDamaged(slot.get()))
        std::cout << *slot.get();
}

void ReleaseValid(std::unique_ptr<Slot> &slot)  // OK
{
    if (!IsDamaged(slot.get()))
        slot.reset(nullptr);
}
```
