---
title: __assume
ms.date: 09/02/2019
f1_keywords:
- __assume
- _assume
- __assume_cpp
helpviewer_keywords:
- __assume keyword [C++]
ms.assetid: d8565123-b132-44b1-8235-5a8c8bff85a7
ms.openlocfilehash: 80acb417ed85ced8f72906848474837efe6bc9d1
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87225102"
---
# <a name="__assume"></a>__assume

**Блок, относящийся только к системам Microsoft**

Передает подсказку оптимизатору.

## <a name="syntax"></a>Синтаксис

```C
__assume(
   expression
)
```

### <a name="parameters"></a>Параметры

*выражение*\
Любое выражение, которое считается, что принимает значение true.

## <a name="remarks"></a>Примечания

Оптимизатор предполагает, что условие, представленное `expression` имеет значение true, в точке, где появляется ключевое слово и сохраняет значение true до изменения `expression` (например, путем присваивания переменной). Выборочное использование подсказок, передаваемых оптимизатору, **`__assume`** может улучшить оптимизацию.

Если **`__assume`** инструкция записывается как противоречие (выражение, которое всегда возвращает значение false), оно всегда обрабатывается как `__assume(0)` . Если код не работает должным образом, убедитесь, что `expression`, которое было определено, является допустимым и имеет значение true, как было описано ранее. Дополнительные сведения об ожидаемом поведении `__assume(0)`, приведены в последующих комментариях.

> [!WARNING]
> Программа не должна содержать недопустимую **`__assume`** инструкцию по достижимому пути. Если компилятор может достичь недопустимого **`__assume`** оператора, программа может привести к непредсказуемому и потенциально опасному поведению.

`__assume`не является подлинной встроенной функцией. Не объявлена как функция и не может использоваться в директиве `#pragma intrinsic`. Несмотря на то, что код не создается, изменяется код, созданный с помощью оптимизатора.

Используйте **`__assume`** в [утверждении](../c-runtime-library/reference/assert-asserte-assert-expr-macros.md) , только если утверждение не может быть восстановлено. Не используйте **`__assume`** в утверждении, для которого имеется следующий код восстановления ошибок, поскольку компилятор может оптимизировать код обработки ошибок.

Инструкция `__assume(0)` является особым случаем. Используйте `__assume(0)` для указания пути к коду, который нельзя достигнуть. Следующий пример показывает, как использовать `__assume(0)` для указания того, что в вариант по умолчанию инструкции switch нельзя попасть. Это показывает наиболее типичное использование `__assume(0)`.

Для совместимости с предыдущими версиями аргумент **`_assume`** является синонимом, **`__assume`** если только параметр компилятора [/Za не \( отключил расширения языка)](../build/reference/za-ze-disable-language-extensions.md) .

## <a name="requirements"></a>Требования

|Intrinsic|Architecture|
|---------------|------------------|
|**`__assume`**|x86, ARM, x64, ARM64|

## <a name="example"></a>Пример

```cpp
// compiler_intrinsics__assume.cpp
#ifdef DEBUG
# define ASSERT(e)    ( ((e) || assert(__FILE__, __LINE__) )
#else
# define ASSERT(e)    ( __assume(e) )
#endif

void func1(int i)
{
}

int main(int p)
{
   switch(p){
      case 1:
         func1(1);
         break;
      case 2:
         func1(-1);
         break;
      default:
         __assume(0);
            // This tells the optimizer that the default
            // cannot be reached. As so, it does not have to generate
            // the extra code to check that 'p' has a value
            // not represented by a case arm. This makes the switch
            // run faster.
   }
}
```

Использование `__assume(0)` сообщает оптимизатору, что вариант по умолчанию недоступен. В примере показано, что программист знает, что ввести для `p` возможно только будет 1 или 2. Если другое значение передается в `p`, программа становится недействительной, что приводит к ее непредсказуемому поведению.

В результате использования инструкции `__assume(0)`, компилятор не создает код для тестирования имеет ли `p` значение, не представленное в операторе case. Чтобы это работало, оператор `__assume(0)` должен быть первым в теле варианта по умолчанию.

Поскольку компилятор создает код на основе **`__assume`** , этот код может работать неправильно, если выражение внутри **`__assume`** инструкции имеет значение false во время выполнения. Если вы не уверены, что выражение всегда будет иметь значение true во время выполнения, можно использовать функцию `assert` для защиты кода.

```C
#define ASSERT(e)    ( ((e) || assert(__FILE__, __LINE__)), __assume(e) )
```

К сожалению, такое использование `assert` не позволяет компилятору выполнить оптимизацию варианта по умолчанию, как было описано ранее в этом документе. В качестве альтернативы можно использовать отдельный макрос следующим образом.

```C
#ifdef DEBUG
# define NODEFAULT   ASSERT(0)
#else
# define NODEFAULT   __assume(0)
#endif

   default:
      NODEFAULT;
```

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Встроенные функции компилятора](../intrinsics/compiler-intrinsics.md)\
[Ключевые слова](../cpp/keywords-cpp.md)
