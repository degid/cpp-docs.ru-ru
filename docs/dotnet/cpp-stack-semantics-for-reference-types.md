---
title: Семантика стека C++ для ссылочных типов
ms.date: 11/04/2016
helpviewer_keywords:
- reference types, C++ stack semantics for
ms.assetid: 319a1304-f4a4-4079-8b84-01cec847d531
ms.openlocfilehash: 886d0d16d8b81364078db5604ab10d8dcc3fa561
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87197843"
---
# <a name="c-stack-semantics-for-reference-types"></a>Семантика стека C++ для ссылочных типов

До Visual Studio 2005 экземпляр ссылочного типа можно создать только с помощью **`new`** оператора, который создал объект в куче, в которой произносятся сборки мусора. Однако теперь можно создать экземпляр ссылочного типа, используя тот же синтаксис, который используется для создания экземпляра собственного типа в стеке. Поэтому не нужно использовать [ref new, gcnew](../extensions/ref-new-gcnew-cpp-component-extensions.md) для создания объекта ссылочного типа. А когда объект выходит из области действия, компилятор вызывает деструктор объекта.

## <a name="remarks"></a>Примечания

При создании экземпляра ссылочного типа с помощью семантики стека компилятор внутренне создает экземпляр в куче со сборкой мусора (с помощью **`gcnew`** ).

Если сигнатура или возвращаемый тип функции содержит экземпляр ссылочного типа по значению, функция будет помечена в метаданных как обязательная обработка (с modreq). В настоящее время эта специальная обработка предоставляется только клиентам Visual C++. в настоящее время другие языки не поддерживают использование функций или данных, использующих ссылочные типы, созданные с семантикой стека.

Одна из причин использования **`gcnew`** (динамическое выделение) вместо семантики стека —, если у типа нет деструктора. Кроме того, использование ссылочных типов, созданных с семантикой стека в сигнатурах функций, невозможно, если требуется, чтобы функции использовались другими языками, отличными от Visual C++.

Компилятор не создаст конструктор копии для ссылочного типа. Поэтому при определении функции, которая использует ссылочный тип по значению в сигнатуре, необходимо определить конструктор копии для ссылочного типа. Конструктор копии для ссылочного типа имеет сигнатуру следующего вида: `R(R%){}` .

Компилятор не создаст оператор присваивания по умолчанию для ссылочного типа. Оператор присваивания позволяет создать объект, используя семантику стека, и инициализировать его с помощью существующего объекта, созданного с использованием семантики стека. Оператор присваивания для ссылочного типа имеет сигнатуру следующего вида: `void operator=( R% ){}` .

Если деструктор типа освобождает критические ресурсы и используется семантика стека для ссылочных типов, не нужно явно вызывать деструктор (или вызов **`delete`** ). Дополнительные сведения о деструкторах в ссылочных типах см. [в разделе Деструкторы и методы завершения в руководстве: определение и использование классов и структур (C++/CLI)](../dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli.md#BKMK_Destructors_and_finalizers).

Созданный компилятором оператор присваивания будет следовать обычным стандартным правилам C++ со следующими дополнениями:

- Все нестатические элементы данных, тип которых является обработчиком ссылочного типа, будет неповерхностным копированием (рассматривается как нестатические элементы данных, тип которых является указателем).

- Любой нестатический элемент данных, тип которого является типом значения, будет неповерхностным копированием.

- Любой нестатический элемент данных, тип которого является экземпляром ссылочного типа, вызовет вызов конструктора копирования ссылочного типа.

Компилятор также предоставляет `%` унарный оператор для преобразования экземпляра ссылочного типа, созданного с помощью семантики стека, в базовый тип Handle.

Следующие ссылочные типы недоступны для использования с семантикой стека:

- [delegate (расширения компонентов C++)](../extensions/delegate-cpp-component-extensions.md)

- [Массивы](../extensions/arrays-cpp-component-extensions.md)

- <xref:System.String>

## <a name="example"></a>Пример

### <a name="description"></a>Описание

В следующем образце кода показано, как объявить экземпляры ссылочных типов с семантикой стека, как работает оператор присваивания и конструктор копирования, а также как инициализировать отслеживаемую ссылку с ссылочным типом, созданным с помощью семантики стека.

### <a name="code"></a>Код

```cpp
// stack_semantics_for_reference_types.cpp
// compile with: /clr
ref class R {
public:
   int i;
   R(){}

   // assignment operator
   void operator=(R% r) {
      i = r.i;
   }

   // copy constructor
   R(R% r) : i(r.i) {}
};

void Test(R r) {}   // requires copy constructor

int main() {
   R r1;
   r1.i = 98;

   R r2(r1);   // requires copy constructor
   System::Console::WriteLine(r1.i);
   System::Console::WriteLine(r2.i);

   // use % unary operator to convert instance using stack semantics
   // to its underlying handle
   R ^ r3 = %r1;
   System::Console::WriteLine(r3->i);

   Test(r1);

   R r4;
   R r5;
   r5.i = 13;
   r4 = r5;   // requires a user-defined assignment operator
   System::Console::WriteLine(r4.i);

   // initialize tracking reference
   R % r6 = r4;
   System::Console::WriteLine(r6.i);
}
```

### <a name="output"></a>Вывод

```Output
98
98
98
13
13
```

## <a name="see-also"></a>См. также

[Классы и структуры](../extensions/classes-and-structs-cpp-component-extensions.md)
