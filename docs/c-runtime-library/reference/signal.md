---
title: signal
ms.date: 04/12/2018
api_name:
- signal
api_location:
- msvcrt.dll
- msvcr80.dll
- msvcr90.dll
- msvcr100.dll
- msvcr100_clr0400.dll
- msvcr110.dll
- msvcr110_clr0400.dll
- msvcr120.dll
- msvcr120_clr0400.dll
- ucrtbase.dll
- api-ms-win-crt-runtime-l1-1-0.dll
api_type:
- DLLExport
topic_type:
- apiref
f1_keywords:
- signal
helpviewer_keywords:
- signal function
ms.openlocfilehash: 1dacf23b6c4f698b61c5bfe2dd2fb1ff7ee389f5
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87216756"
---
# <a name="signal"></a>signal

Задает обработку сигнала прерывания.

> [!IMPORTANT]
> Не используйте этот метод для завершения работы Microsoft Store приложения, за исключением сценариев тестирования или отладки. В соответствии с [политиками Microsoft Store](/legal/windows/agreements/store-policies)не разрешено закрывать приложения Магазина программным способом или с помощью пользовательского интерфейса. Дополнительные сведения см. в статье [жизненный цикл приложения UWP](/windows/uwp/launch-resume/app-lifecycle).

## <a name="syntax"></a>Синтаксис

```C
void __cdecl *signal(int sig, int (*func)(int, int));
```

### <a name="parameters"></a>Параметры

*SIG*<br/>
Значение сигнала.

*func*<br/>
Второй параметр — это указатель на функцию, которую необходимо выполнить. Первый параметр указывает значение сигнала, второй параметр — подкод, который можно использовать, если первый параметр — SIGFPE.

## <a name="return-value"></a>Возвращаемое значение

**сигнал** возвращает предыдущее значение func, связанное с данным сигналом. Например, если предыдущее значение *Func* было **SIG_IGN**, то возвращаемое значение также будет **SIG_IGN**. Возвращаемое значение **SIG_ERR** указывает на ошибку; в этом случае для параметра « **еинвал**» задано значение **«нет»** .

Дополнительные сведения о кодах возврата см. в разделе [errno, _doserrno, _sys_errlist и _sys_nerr](../../c-runtime-library/errno-doserrno-sys-errlist-and-sys-nerr.md).

## <a name="remarks"></a>Примечания

Функция **сигнал** позволяет процессу выбрать один из нескольких способов обработки сигнала прерывания из операционной системы. Аргумент *SIG* — это прерывание, на которое реагирует **сигнал** ; Он должен быть одной из следующих констант манифеста, которые определены в СИГНАЛе. Высоты.

|значение *SIG*|Описание|
|-----------------|-----------------|
|**SIGABRT**|Аварийное завершение|
|**SIGFPE**|Ошибка с плавающей запятой|
|**SIGILL**|Недопустимая инструкция|
|**SIGINT**|Сигнал CTRL + C|
|**SIGSEGV**|Недопустимый доступ к хранилищу|
|**SIGTERM**|Запрос на завершение|

Если *SIG* не является одним из указанных выше значений, вызывается обработчик недопустимых параметров, как определено в [проверке параметров](../../c-runtime-library/parameter-validation.md) . Если выполнение может быть продолжено, эта функция **устанавливает** **еинвал** и возвращает **SIG_ERR**.

По умолчанию **сигнал** завершает вызывающую программу с кодом выхода 3, независимо от значения *SIG*.

> [!NOTE]
> **SIGINT** не поддерживается ни для одного приложения Win32. Когда происходит прерывание CTRL + C, операционные системы Win32 создают новый поток специально для обработки такого прерывания. Это может привести к тому, что однопоточное приложение, например в UNIX, становится многопоточным и вызывает непредвиденное поведение.

Аргумент *Func* — это адрес обработчика сигналов, который вы пишете, или к одной из предопределенных констант **SIG_DFL** или **SIG_IGN**, которые также определены в сигнале. Высоты. Если функция *Func* является функцией, она устанавливается как обработчик сигналов для данного сигнала. Для прототипа обработчика сигнала требуется один формальный аргумент типа *SIG* **`int`** . Операционная система предоставляет фактический аргумент через *SIG* , когда происходит прерывание; аргумент — это сигнал, создавший прерывание. Поэтому можно использовать шесть констант манифеста (перечисленных в приведенной выше таблице) в обработчике сигнала, чтобы определить, какое прерывание произошло, и предпринять соответствующие действия. Например, можно вызывать **сигнал** дважды, чтобы назначить один и тот же обработчик двум различным сигналам, а затем протестировать аргумент *SIG* в обработчике для выполнения различных действий на основе полученного сигнала.

Если вы тестируете исключения с плавающей запятой (**сигфпе**), функция *Func* указывает на функцию, принимающую необязательный второй аргумент, который является одной из нескольких констант манифеста, определенных в float. H, **FPE_xxx**формы. При появлении сигнала **сигфпе** можно проверить значение второго аргумента, чтобы определить тип исключения с плавающей запятой и выполнить соответствующее действие. Этот аргумент и его возможные значения являются расширениями Майкрософт.

При возникновении исключений с плавающей запятой значение *Func* не сбрасывается при получении сигнала. Для восстановления после исключений в операциях с плавающей запятой заключайте такие операции в конструкции try/except. Кроме того, восстановление возможно с помощью [setjmp](setjmp.md) с [longjmp](longjmp.md). В любом случае вызывающий процесс продолжает выполнение, а значение состояния операции с плавающей запятой в процессе остается неопределенным.

Если обработчик сигналов возвращает значение, вызывающий процесс возобновляет процесс непосредственного с того момента, когда он получил сигнал прерывания. Это верно независимо от вида сигнала или режима работы.

Перед выполнением указанной функции значение *Func* устанавливается равным **SIG_DFL**. Следующий сигнал прерывания обрабатывается, как описано в **SIG_DFL**, если только промежуточный вызов **сигнала** не указывает иное. Эту особенность можно использовать для сброса сигналов в вызванной функции.

Поскольку подпрограммы обработчика сигналов обычно вызываются асинхронно в случае прерывания, функция обработчика сигнала может получить управление в то время, когда операция среды выполнения не завершена или находится в неизвестном состоянии. В следующем списке указаны ограничения, которые определяют, какие функции могут использоваться в подпрограмме обработчика сигнала.

- Не выпускайте низкого уровня или STDIO. H подпрограммы ввода-вывода (например, **printf** или **fread**).

- Не вызывайте подпрограммы кучи или любую подпрограммы, которая использует подпрограммы кучи (например, **malloc**, **_strdup**или **_putenv**). Дополнительные сведения см. в разделе [malloc](malloc.md).

- Не используйте функцию, создающую системный вызов (например, **_getcwd** или **time**).

- Не используйте **longjmp** , если только прерывание не вызвано исключением с плавающей запятой (то есть *SIG* — **сигфпе**). В этом случае сначала инициализируйте пакет с плавающей запятой с помощью вызова **_fpreset**.

- Не используйте подпрограммы наложения.

Программа должна содержать код с плавающей запятой, если это необходимо для перехвата исключения **сигфпе** с помощью функции. Если программа не содержит код, использующий операции с плавающей запятой, и требует выполнение кода обработчиков сигналов библиотеки времени выполнения, просто объявите переменную volatile double и инициализируйте ее нулевым значением.

```C
volatile double d = 0.0f;
```

Сигналы **сигилл** и **SIGTERM** не создаются в Windows. Они включены для обеспечения совместимости с ANSI. Таким образом, можно установить обработчики сигналов для этих сигналов с помощью **сигнала**, а также можно явно создать эти сигналы, вызвав метод [raise](raise.md).

Параметры сигнала не сохраняются в порожденных процессах, созданных вызовами функций [_exec](../../c-runtime-library/exec-wexec-functions.md) или [_spawn](../../c-runtime-library/spawn-wspawn-functions.md) . В новом процессе параметры сигнала сбрасываются в значения по умолчанию.

## <a name="requirements"></a>Требования

|Подпрограмма|Обязательный заголовок|
|-------------|---------------------|
|**signal**;|\<signal.h>|

Дополнительные сведения о совместимости см. в статье [Compatibility](../../c-runtime-library/compatibility.md).

## <a name="example"></a>Пример

В следующем примере показано, как использовать **сигнал** для добавления пользовательского поведения в сигнал **сигабрт** . Дополнительные сведения о прерывании работы см. в разделе [_set_abort_behavior](set-abort-behavior.md).

```C
// crt_signal.c
// compile with: /EHsc /W4
// Use signal to attach a signal handler to the abort routine
#include <stdlib.h>
#include <signal.h>

void SignalHandler(int signal)
{
    if (signal == SIGABRT) {
        // abort signal handler code
    } else {
        // ...
    }
}

int main()
{
    typedef void (*SignalHandlerPointer)(int);

    SignalHandlerPointer previousHandler;
    previousHandler = signal(SIGABRT, SignalHandler);

    abort();
}
```

Выходные данные зависят от используемой версии среды выполнения, от того, является ли приложение консолью или приложением Windows, а также параметрами реестра Windows. Для консольного приложения в stderr может быть отправлено примерно следующее сообщение:

```Output
Debug Error!

Program: c:\Projects\crt_signal\Debug\crt_signal.exe

R6010

- abort() has been called
```

## <a name="see-also"></a>См. также раздел

[Управление процессами и средой](../../c-runtime-library/process-and-environment-control.md)<br/>
[abort](abort.md)<br/>
[_exec, функции _wexec](../../c-runtime-library/exec-wexec-functions.md)<br/>
[exit, _Exit, _exit](exit-exit-exit.md)<br/>
[_fpreset](fpreset.md)<br/>
[_spawn, функции _wspawn](../../c-runtime-library/spawn-wspawn-functions.md)<br/>
