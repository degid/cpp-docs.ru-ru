---
title: volatile (C++)
ms.date: 05/07/2019
f1_keywords:
- volatile_cpp
helpviewer_keywords:
- interrupt handlers and volatile keyword [C++]
- volatile keyword [C++]
- volatile objects
- objects [C++], volatile
ms.assetid: 81db4a85-ed5a-4a2c-9a53-5d07a771d2de
ms.openlocfilehash: bbdd7d03d820b9fc0d541dbb31d55b641226f14e
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87213103"
---
# <a name="volatile-c"></a>volatile (C++)

Квалификатор типа, который используется для объявления о том, что объект может быть изменен в программе аппаратным обеспечением.

## <a name="syntax"></a>Синтаксис

```
volatile declarator ;
```

## <a name="remarks"></a>Примечания

Чтобы изменить способ, которым компилятор интерпретирует это ключевое слово, можно использовать параметр компилятора [/volatile](../build/reference/volatile-volatile-keyword-interpretation.md) .

Visual Studio интерпретирует **`volatile`** ключевое слово по-разному в зависимости от целевой архитектуры. Для ARM, если не указан параметр компилятора **/volatile** , компилятор выполняет команду, как если бы был указан **/volatile: ISO** . Для архитектур, отличных от ARM, если не указан параметр компилятора **/volatile** , компилятор выполняет команду, как если бы был указан **/volatile: MS** . Таким образом, для архитектур, отличных от ARM, настоятельно рекомендуется указывать **/volatile: ISO**и использовать явные примитивы синхронизации и встроенные функции компилятора при работе с памятью, которая совместно используется в потоках.

Квалификатор можно использовать **`volatile`** для предоставления доступа к областям памяти, используемым асинхронными процессами, такими как обработчики прерываний.

Если **`volatile`** используется для переменной, которая также имеет ключевое слово [__restrict](../cpp/extension-restrict.md) , **`volatile`** имеет приоритет.

Если **`struct`** член помечен как **`volatile`** , то **`volatile`** он передается всей структуре. Если структура не имеет длины, которую можно скопировать в текущей архитектуре с помощью одной инструкции, **`volatile`** может быть полностью утеряна в этой структуре.

**`volatile`** Ключевое слово может не влиять на поле, если выполняется одно из следующих условий.

- Длина поля с ключевым словом volatile превышает максимальный размер, который в текущей архитектуре может быть скопирован с помощью одной инструкции.

- Длина самого внешнего объекта **`struct`** , или если он является членом потенциально вложенного объекта, **`struct`** превышает максимальный размер, который можно скопировать в текущую архитектуру с помощью одной инструкции.

Несмотря на то, что процессор не переупорядочивает доступ к некэшированной памяти, переменные без возможности кэширования должны быть помечены как, **`volatile`** чтобы гарантировать, что компилятор не переупорядочивает доступ к памяти.

Объекты, объявленные как **`volatile`** , не используются в определенных оптимизациях, так как их значения могут изменяться в любое время.  При запросе объекта с ключевым словом volatile система всегда считывает его текущее значение, даже если оно запрашивалось в предшествовавшей инструкции.  Кроме того, значение объекта записывается непосредственно при присваивании.


## <a name="iso-compliant"></a>Блок, относящийся к стандарту ISO

Если вы знакомы с ключевым словом "volatile" в C# или знакомы с поведением **`volatile`** в более ранних версиях компилятора Microsoft C++ (компилятором MSVC), имейте в виду, что ключевое слово C++ 11 ISO Standard отличается **`volatile`** и поддерживается в компилятором MSVC при указании параметра компилятора [/volatile: ISO](../build/reference/volatile-volatile-keyword-interpretation.md) . (Для архитектуры ARM он установлен по умолчанию). **`volatile`** Ключевое слово в стандартном коде ISO 11 языка c++ используется только для доступа к оборудованию; не используйте его для обмена данными между потоками. Для обмена данными между потоками используйте такие механизмы, как [std:: \<T> Atomic](../standard-library/atomic.md) из [стандартной библиотеки C++](../standard-library/cpp-standard-library-reference.md).

## <a name="end-of-iso-compliant"></a>Конец блока, относящегося к стандарту ISO

**Блок, относящийся только к системам Microsoft**

Когда используется параметр компилятора **/volatile: MS** — по умолчанию, если нацелены архитектуры, отличные от ARM, компилятор создает дополнительный код для поддержания упорядочения между ссылками на переменные объекты, а также для поддержания порядка ссылок на другие глобальные объекты. В частности:

- Запись в объект с ключевым словом volatile (т. н. "запись в изменяемый объект") имеет семантику освобождения. Это означает, что ссылка на глобальный или статический объект, которая находится в последовательности инструкций перед записью в объект с ключевым словом volatile, в скомпилированном двоичном файле будет находиться до записи в изменяемый объект.

- Считывание из объекта с ключевым словом volatile (т. н. "считывание из изменяемого объекта") имеет семантику получения. Это означает, что ссылка на глобальный или статический объект, которая находится в последовательности инструкций после считывания из объекта с ключевым словом volatile, в скомпилированном двоичном файле будет находиться после считывания из изменяемого объекта.

Благодаря этому объекты с ключевым словом volatile могут использоваться для блокировки и освобождения памяти в многопоточных приложениях.

> [!NOTE]
> Если используется расширенная гарантия, предоставляемая при использовании параметра компилятора **/volatile: MS** , код не является переносимым.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[const](../cpp/const-cpp.md)<br/>
[константные и переменные указатели](../cpp/const-and-volatile-pointers.md)
