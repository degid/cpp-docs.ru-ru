---
title: :::no-loc(main):::аргументы функции и командной строки (C++)
description: :::no-loc(main):::Функция является точкой входа для программы C++.
ms.date: 01/15/2019
ms.assetid: c6568ee6-40ab-4ae8-aa44-c99e232f64ac
no-loc:
- ':::no-loc(main):::'
- ':::no-loc(wmain):::'
- ':::no-loc(inline):::'
- ':::no-loc(static):::'
- ':::no-loc(_tmain):::'
- ':::no-loc(void):::'
- ':::no-loc(exit):::'
- ':::no-loc(argc):::'
- ':::no-loc(argv):::'
- ':::no-loc(envp):::'
- ':::no-loc(CreateProcess):::'
- ':::no-loc(GetModuleFileName):::'
- ':::no-loc(char):::'
- ':::no-loc(wchar_t):::'
- ':::no-loc(extern):::'
ms.openlocfilehash: 9fe7c7a0808584a70bffa541903866b3de364e5f
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87213324"
---
# <a name="no-locmain-function-and-command-line-arguments"></a>:::no-loc(main):::аргументы функции и командной строки

Все программы на C++ должны иметь `:::no-loc(main):::` функцию. При попытке скомпилировать проект C++ *. exe* без :::no-loc(main)::: функции компилятор вызовет ошибку. (Библиотеки и библиотеки динамической компоновки :::no-loc(static)::: не имеют `:::no-loc(main):::` функции.) `:::no-loc(main):::`Функция заключается в том, где исходный код начинает выполнение, но до того, как программа введет `:::no-loc(main):::` функцию, всем :::no-loc(static)::: членам класса без явных инициализаторов присваивается нулевое значение. В Microsoft C++ глобальные :::no-loc(static)::: объекты также инициализируются перед записью в `:::no-loc(main):::` . К `:::no-loc(main):::` функции, которая не применяется к другим функциям C++, применяются некоторые ограничения. `:::no-loc(main):::`Функция:

- Не может быть перегружен (см. [перегрузку функции](function-overloading.md)).
- Не может быть объявлен как **`:::no-loc(inline):::`** .
- Не может быть объявлен как **`:::no-loc(static):::`** .
- Не может иметь адрес взятым.
- Вызвать невозможно.

:::no-loc(main):::Функция не имеет объявления, так как она встроена в язык. Если это так, синтаксис объявления для `:::no-loc(main):::` будет выглядеть следующим образом:

```cpp
int :::no-loc(main):::();
int :::no-loc(main):::(int :::no-loc(argc):::, :::no-loc(char)::: *:::no-loc(argv):::[], :::no-loc(char)::: *:::no-loc(envp):::[]);
```

**Блок, относящийся только к системам Microsoft**

Если исходные файлы используют Юникод Wide :::no-loc(char)::: актерс, можно использовать `:::no-loc(wmain):::` , который является :::no-loc(char)::: актер версией `:::no-loc(main):::` . Синтаксис объявления функции `:::no-loc(wmain):::` выглядит следующим образом:

```cpp
int :::no-loc(wmain):::( );
int :::no-loc(wmain):::(int :::no-loc(argc):::, :::no-loc(wchar_t)::: *:::no-loc(argv):::[], :::no-loc(wchar_t)::: *:::no-loc(envp):::[]);
```

Можно также использовать `:::no-loc(_tmain):::` , который определен в t :::no-loc(char)::: .h. `:::no-loc(_tmain):::`разрешается в, `:::no-loc(main):::` если не определено _UNICODE. В противном случае функция `:::no-loc(_tmain):::` разрешается в функцию `:::no-loc(wmain):::`.

Если возвращаемое значение не указано, компилятор предоставляет возвращаемое значение, равное нулю. Кроме того, `:::no-loc(main):::` `:::no-loc(wmain):::` функции и могут быть объявлены как возвращаемые **`:::no-loc(void):::`** (без возвращаемого значения). Если объявляется `:::no-loc(main):::` или `:::no-loc(wmain):::` возвращается **`:::no-loc(void):::`** , то нельзя вернуть :::no-loc(exit)::: код в родительский процесс или операционную систему с помощью оператора [return](../cpp/return-statement-in-program-termination-cpp.md) . Чтобы вернуть :::no-loc(exit)::: код, если `:::no-loc(main):::` или `:::no-loc(wmain):::` объявлен как **`:::no-loc(void):::`** , необходимо использовать [:::no-loc(exit):::](../cpp/:::no-loc(exit):::-function.md) функцию.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="command-line-arguments"></a>Аргументы командной строки

Аргументы для `:::no-loc(main):::` или `:::no-loc(wmain):::` предоставляют удобный синтаксический анализ аргументов в командной строке и, при необходимости, доступ к переменным среды. Типы для параметров `:::no-loc(argc):::` и `:::no-loc(argv):::` определяются языком. Имена `:::no-loc(argc):::` , `:::no-loc(argv):::` и `:::no-loc(envp):::` являются традиционными, но их можно называть любым из них.

```cpp
int :::no-loc(main):::( int :::no-loc(argc):::, :::no-loc(char):::* :::no-loc(argv):::[], :::no-loc(char):::* :::no-loc(envp):::[]);
int :::no-loc(wmain):::( int :::no-loc(argc):::, :::no-loc(wchar_t):::* :::no-loc(argv):::[], :::no-loc(wchar_t):::* :::no-loc(envp):::[]);
```

Используются следующие определения аргументов.

*:::no-loc(argc):::*<br/>
Целое число, содержащее число аргументов, следующих за *:::no-loc(argv):::* . *:::no-loc(argc):::* Параметр всегда больше или равен 1.

*:::no-loc(argv):::*<br/>
Массив завершающихся null строк, представляющих введенные пользователем программы аргументы командной строки. По соглашению `:::no-loc(argv):::[0]` — это команда, с помощью которой вызывается программа, `:::no-loc(argv):::[1]` является первым аргументом командной строки и т. д., до `:::no-loc(argv):::[:::no-loc(argc):::]` которой всегда имеет значение null. Сведения о подавлении обработки из командной строки см. в разделе [Настройка обработки командной строки](../cpp/customizing-cpp-command-line-processing.md) .

Первый аргумент командной строки — всегда `:::no-loc(argv):::[1]`, а последний — `:::no-loc(argv):::[:::no-loc(argc)::: - 1]`.

> [!NOTE]
> По соглашению `:::no-loc(argv):::[0]` — это команда, с помощью которой вызывается программа. Однако можно создать процесс с помощью [:::no-loc(CreateProcess):::](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) и, если вы используете как первый, так и второй аргумент (*Лпаппликатионнаме* и *лпкоммандлине*), `:::no-loc(argv):::[0]` не может быть именем исполняемого файла; используйте [:::no-loc(GetModuleFileName):::](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamew) для получения имени исполняемого файла и его полного пути.

**Блок, относящийся только к системам Microsoft**

*:::no-loc(envp):::*<br/>
*:::no-loc(envp):::* Массив, являющийся общим расширением во многих системах UNIX, используется в Microsoft C++. Это массив строк, представляющих переменные, заданные в среде пользователя. Этот массив завершается записью NULL. Он может быть объявлен как массив указателей на **`:::no-loc(char):::`** ( `:::no-loc(char)::: *:::no-loc(envp):::[]` ) или как указатель на указатели на **`:::no-loc(char):::`** ( `:::no-loc(char)::: **:::no-loc(envp):::` ). Если программа использует `:::no-loc(wmain):::` вместо `:::no-loc(main):::` , используйте **`:::no-loc(wchar_t):::`** тип данных вместо **`:::no-loc(char):::`** . Блок среды, переданный в `:::no-loc(main):::` и `:::no-loc(wmain):::` , является замороженной копией текущей среды. При последующем изменении среды с помощью вызова `putenv` или `_wputenv` , текущая среда (как и переменная или, возвращаемая `getenv` переменной или) изменится `_wgetenv` `_environ` `_wenviron` , но блок, на который указывает, :::no-loc(envp)::: не изменится. Сведения о подавлении обработки среды см. в разделе [Настройка обработки командной строки](../cpp/customizing-cpp-command-line-processing.md) . Этот аргумент совместим с ANSI в C, но не в C++.

**Завершение блока, относящегося только к системам Майкрософт**

### <a name="example"></a>Пример

В следующем примере показано, как использовать *:::no-loc(argc):::* аргументы, *:::no-loc(argv):::* и *:::no-loc(envp):::* в следующих `:::no-loc(main):::` случаях:

```cpp
// argument_definitions.cpp
// compile with: /EHsc
#include <iostream>
#include <string.h>

using namespace std;
int :::no-loc(main):::( int :::no-loc(argc):::, :::no-loc(char)::: *:::no-loc(argv):::[], :::no-loc(char)::: *:::no-loc(envp):::[] ) {
    int iNumberLines = 0;    // Default is no line numbers.

    // If /n is passed to the .exe, display numbered listing
    // of environment variables.

    if ( (:::no-loc(argc)::: == 2) && _stricmp( :::no-loc(argv):::[1], "/n" ) == 0 )
         iNumberLines = 1;

    // Walk through list of strings until a NULL is encountered.
    for( int i = 0; :::no-loc(envp):::[i] != NULL; ++i ) {
        if( iNumberLines )
            cout << i << ": " << :::no-loc(envp):::[i] << "\n";
    }
}
```

## <a name="parsing-c-command-line-arguments"></a>Синтаксический анализ аргументов командной строки C++

**Блок, относящийся только к системам Microsoft**

В коде запуска Microsoft C/C++ используются следующие правила при обработке аргументов, вводимых в командной строке операционной системы.

- Аргументы разделяются пробелами (пробел или табуляция).

- Курсор :::no-loc(char)::: актер (^) не распознается как escape- :::no-loc(char)::: актер или разделитель. :::no-loc(char):::Актер полностью обрабатывается анализатором командной строки в операционной системе перед передачей в `:::no-loc(argv):::` массив в программе.

- Строка, заключенная в двойные кавычки ("*строка*"), интерпретируется как один аргумент, независимо от пробелов, содержащихся в. Строку в кавычках можно встроить в аргумент.

- Двойная кавычка с предшествующей обратной косой чертой ( \\ ") интерпретируется как литеральная двойная кавычка :::no-loc(char)::: актер (").

- Символы обратной косой черты обрабатываются буквально, если только им не предшествует двойная кавычка.

- Если после четного числа символов обратной косой черты стоит двойная кавычка, в массив `:::no-loc(argv):::` помещается по одному символу обратной косой черты (\) для каждой пары символов обратной косой черты (\\), а двойная кавычка (") обрабатывается как разделитель строки.

- Если после нечетного числа знаков обратной косой черты стоит двойная кавычка, то одна обратная косая черта помещается в `:::no-loc(argv):::` массив для каждой пары символов обратной косой черты, а двойные кавычки — в escape-последовательности :::no-loc(main)::: , что приводит к помещению символа двойной кавычки (") в качестве литерала `:::no-loc(argv):::` .

### <a name="example"></a>Пример

В следующем примере программы показана передача аргументов командной строки:

```cpp
// command_line_arguments.cpp
// compile with: /EHsc
#include <iostream>

using namespace std;
int :::no-loc(main):::( int :::no-loc(argc):::,      // Number of strings in array :::no-loc(argv):::
          :::no-loc(char)::: *:::no-loc(argv):::[],   // Array of command-line argument strings
          :::no-loc(char)::: *:::no-loc(envp):::[] )  // Array of environment variable strings
{
    int count;

    // Display each command-line argument.
    cout << "\nCommand-line arguments:\n";
    for( count = 0; count < :::no-loc(argc):::; count++ )
         cout << "  :::no-loc(argv):::[" << count << "]   "
                << :::no-loc(argv):::[count] << "\n";
}
```

В следующей таблице показаны примеры входных данных и ожидаемые выходные данные, иллюстрирующие применение правил из приведенного выше списка.

### <a name="results-of-parsing-command-lines"></a>Результаты синтаксического анализа командных строк

|Данные в командной строке|:::no-loc(argv):::[1]|:::no-loc(argv):::[2]|:::no-loc(argv):::3-5|
|-------------------------|---------------|---------------|---------------|
|`"abc" d e`|`abc`|`d`|`e`|
|`a\\b d"e f"g h`|`a\\b`|`de fg`|`h`|
|`a\\\"b c d`|`a\"b`|`c`|`d`|
|`a\\\\"b c" d e`|`a\\b c`|`d`|`e`|

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="wildcard-expansion"></a>Развертывание подстановочных знаков

**Блок, относящийся только к системам Microsoft**

Задавать имена файлов и пути к ним в аргументах командной строки можно при помощи знаков подстановки — вопросительного знака (?) и звездочки (*).

Аргументы командной строки обрабатываются подсистемой `_set:::no-loc(argv):::` (или `_wset:::no-loc(argv):::` в среде Wide- :::no-loc(char)::: актер), которая по умолчанию не расширяет подстановочные знаки в отдельные строки в `:::no-loc(argv):::` массиве строк. Дополнительные сведения о включении расширения с подстановочными знаками см. в разделе [расширение аргументов-шаблонов](../c-language/expanding-wildcard-arguments.md).

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="customizing-c-command-line-processing"></a>Настройка обработки командной строки C++

**Блок, относящийся только к системам Microsoft**

Если программа не принимает аргументы командной строки, можно сохранить небольшой объем пространства, подавив использование подпрограммы библиотеки, выполняющей обработку командной строки. Эта подпрограммы вызывается `_set:::no-loc(argv):::` и описывается в разделе [расширение подстановочных знаков](../cpp/wildcard-expansion.md). Чтобы подавить его использование, определите подпрограммы, которая ничего не делает с файлом `:::no-loc(main):::` , содержащим функцию, и назовите ее `_set:::no-loc(argv):::` . Затем вызов метода `_set:::no-loc(argv):::` удовлетворяет вашему определению `_set:::no-loc(argv):::` , а версия библиотеки не загружается.

Аналогично, если вы никогда не обращаетесь к таблице окружения через `:::no-loc(envp):::` аргумент, можно предоставить собственную пустую подпрограммы, которая будет использоваться вместо `_set:::no-loc(envp):::` , подпрограммы обработки среды. Как и в `_set:::no-loc(argv):::` случае функции, `_set:::no-loc(envp):::` должен быть объявлен как ** :::no-loc(extern)::: "C"**.

Программа может вызывать `spawn` или `exec` семейство подпрограмм в библиотеке времени выполнения C. Если это так, не следует подавлять подпрограммы обработки среды, так как эта процедура используется для передачи среды из родительского процесса в дочерний процесс.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[Основные понятия](../cpp/basic-concepts-cpp.md)
