---
title: Операторы присваивания
description: Синтаксис операторов назначения языка C++ Standard и использование.
ms.date: 07/24/2020
f1_keywords:
- =
- '*='
- /=
- '%='
- +=
- -=
- <<=
- '>>='
- '&='
- ^=
- '|='
helpviewer_keywords:
- operators [C++], assignment
- assignment operators [C++], C++
- '&= operator'
- ^= operator
- += operator
- '>>= operator'
- '|= operator'
- operator>>=
- '*= operator'
- '%= operator'
- ^= operator
- operator >>=
- = operator
- -= operator
- /= operator
- <<= operator
ms.assetid: b028cf35-2ff1-4f14-9027-fd53ebec8aa0
ms.openlocfilehash: 91346d06c6fab4f3cd83c5318c88e738daf8d249
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87229224"
---
# <a name="assignment-operators"></a>Операторы присваивания

## <a name="syntax"></a>Синтаксис

выражение *оператора присваивания* *expression* *выражения*

*assignment-operator*: один из следующих операторов:<br/>
&emsp;**`=`**&emsp;**`*=`**&emsp;**`/=`**&emsp;**`%=`**&emsp;**`+=`**&emsp;**`-=`**&emsp;**`<<=`**&emsp;**`>>=`**&emsp;**`&=`**&emsp;**`^=`**&emsp;**`|=`**

## <a name="remarks"></a>Примечания

Операторы присваивания хранят значение в объекте, указанном левым операндом. Существует два вида операций присваивания:

- *простое присваивание*, в котором значение второго операнда хранится в объекте, указанном первым операндом.

- *составное присваивание*, в котором выполняется арифметическая операция сдвига или Побитовая перед сохранением результата.

Все операторы присваивания в следующей таблице, за исключением **`=`** оператора, являются составными операторами присваивания.

### <a name="assignment-operators-table"></a>Таблица операторов присваивания

| Оператор | Значение |
|--|--|
| **`=`** | Сохранение значения второго операнда в объект, указанный первым операндом (простое присваивание). |
| **`*=`** | Умножение значения первого операнда на значение второго операнда; сохранение результата в объект, указанный первым операндом. |
| **`/=`** | Деление значения первого операнда на значение второго операнда; сохранение результата в объект, указанный первым операндом. |
| **`%=`** | деление по модулю первого операнда на значение второго операнда; сохранение результата в объект, указанный первым операндом. |
| **`+=`** | Сложение значения первого операнда со значением второго операнда; сохранение результата в объект, указанный первым операндом. |
| **`-=`** | Вычитание значения второго операнда из значения первого операнда; сохранение результата в объект, указанный первым операндом. |
| **`<<=`** | Сдвиг значения первого операнда влево на количество битов, заданное значением второго операнда; сохранение результата в объект, указанный первым операндом. |
| **`>>=`** | Сдвиг значения первого операнда вправо на количество битов, заданное значением второго операнда; сохранение результата в объект, указанный первым операндом. |
| **`&=`** | Выполнение операции побитового И для значений первого и второго операндов; сохранение результата в объект, указанный первым операндом. |
| **`^=`** | Выполнение операции побитового исключающего ИЛИ для значений первого и второго операндов; сохранение результата в объект, указанный первым операндом. |
| **`|=`** | Выполнение операции побитового включающего ИЛИ для значений первого и второго операндов; сохранение результата в объект, указанный первым операндом. |

### <a name="operator-keywords"></a>Ключевые слова операторов

Три составных оператора присваивания имеют эквиваленты ключевого слова. К ним относятся:

| Оператор | Эквивалентный |
|--|--|
| **`&=`** | **`and_eq`** |
| **`|=`** | **`or_eq`** |
| **`^=`** | **`xor_eq`** |

C++ задает эти ключевые слова операторов в качестве альтернативного написания для составных операторов присваивания. В языке C альтернативное написание предоставляется в виде макросов в \<iso646.h> заголовке. В C++ альтернативные слова являются ключевыми словами; использование \<iso646.h> или эквивалент C++ \<ciso646> не рекомендуется. В Microsoft C++ [`/permissive-`](../build/reference/permissive-standards-conformance.md) [`/Za`](../build/reference/za-ze-disable-language-extensions.md) параметр компилятора или необходим для включения альтернативного написания.

## <a name="example"></a>Пример

```cpp
// expre_Assignment_Operators.cpp
// compile with: /EHsc
// Demonstrate assignment operators
#include <iostream>
using namespace std;
int main() {
   int a = 3, b = 6, c = 10, d = 0xAAAA, e = 0x5555;

   a += b;      // a is 9
   b %= a;      // b is 6
   c >>= 1;      // c is 5
   d |= e;      // Bitwise--d is 0xFFFF

   cout  << "a = 3, b = 6, c = 10, d = 0xAAAA, e = 0x5555" << endl
         << "a += b yields " << a << endl
         << "b %= a yields " << b << endl
         << "c >>= 1 yields " << c << endl
         << "d |= e yields " << hex << d << endl;
}
```

## <a name="simple-assignment"></a>Простое присваивание

Оператор простого присваивания ( **`=`** ) вызывает сохранение значения второго операнда в объекте, указанном первым операндом. Если оба объекта имеют арифметические типы, правый операнд преобразуется в тип слева перед сохранением значения.

Объекты **`const`** и **`volatile`** типов могут быть назначены l-значениям только типов **`volatile`** , а не **`const`** или **`volatile`** .

Присваивание объектам типа класса ( **`struct`** типы, **`union`** и **`class`** ) выполняется функцией с именем `operator=` . По умолчанию эта функция-оператор производит побитовое копирование; однако такое поведение можно изменить с помощью перегруженных операторов. Для получения дополнительной информации см. раздел [Перегрузка операторов](../cpp/operator-overloading.md). Типы классов также могут иметь операторы *присваивания* и *перемещения* копирования. Дополнительные сведения см. в разделе [конструкторы копирования и операторы присваивания копирования](copy-constructors-and-copy-assignment-operators-cpp.md) и [конструкторы перемещения и операторы присваивания перемещения](move-constructors-and-move-assignment-operators-cpp.md).

Объект любого класса, однозначно производного от некоторого базового класса, можно присвоить объекту этого базового класса. Обратный переход не выполняется, поскольку существует неявное преобразование из производного класса в базовый класс, но не из базового класса в производный класс. Например:

```cpp
// expre_SimpleAssignment.cpp
// compile with: /EHsc
#include <iostream>
using namespace std;
class ABase
{
public:
    ABase() { cout << "constructing ABase\n"; }
};

class ADerived : public ABase
{
public:
    ADerived() { cout << "constructing ADerived\n"; }
};

int main()
{
    ABase aBase;
    ADerived aDerived;

    aBase = aDerived; // OK
    aDerived = aBase; // C2679
}
```

Присваивание ссылочным типам выполняется так, как если бы выполнялось присваивание объекту, на который указывает ссылка.

Для объектов типа класса присваивание отличается от инициализации. Для иллюстрации того, насколько сильно присваивание может отличаться от инициализации, рассмотрим код

```cpp
UserType1 A;
UserType2 B = A;
```

В предыдущем коде показан инициализатор; он вызывает конструктор для типа `UserType2`, который принимает аргумент типа `UserType1`. В коде

```cpp
UserType1 A;
UserType2 B;

B = A;
```

оператор присваивания

```cpp
B = A;
```

может вызывать одно из указанных ниже действий.

- Вызовите функцию `operator=` для `UserType2` , предоставленную `operator=` с `UserType1` аргументом.

- Вызывать функцию явного преобразования `UserType1::operator UserType2`, если такая функция существует.

- Вызывать конструктор `UserType2::UserType2`, если он существует, принимает аргумент `UserType1` и копирует результат.

## <a name="compound-assignment"></a>Составное присваивание

Составные операторы присваивания показаны в [таблице операторы назначения](#assignment-operators-table). Эти операторы имеют форму *E1* *Op* =  *E2*, где *E1* — это **`const`** неизменяемое l-значение, а *E2* —:

- арифметический тип

- указатель, если *Op* имеет значение **`+`** или**`-`**

Форма *E1* *Op* =  *E2* ведет себя как *E1* **`=`** *E1* *Op* *E2*, но *E1* вычисляется только один раз.

Составное присваивание перечисляемому типу создает сообщение об ошибке. Если левый операнд имеет тип указателя, правый операнд должен иметь тип указателя или константное выражение, результатом которого является 0. Если левый операнд имеет целочисленный тип, правый операнд не должен иметь тип указателя.

## <a name="result-of-assignment-operators"></a>Результат операторов присваивания

Операторы присваивания возвращают значение объекта, указанного левым операндом после присваивания. Результирующий тип — это тип левого операнда. Результатом выражения присваивания всегда является l-значение. Эти операторы имеют ассоциативность справа налево. Левый операнд должен быть изменяемым l-значением.

В ANSI C результат выражения присваивания не является l-значением. Это означает, что юридическое выражение C++ `(a += b) += c` не допускается в C.

## <a name="see-also"></a>См. также статью

[Выражения с бинарными операторами](../cpp/expressions-with-binary-operators.md)<br/>
[Встроенные операторы, приоритет и ассоциативность C++](../cpp/cpp-built-in-operators-precedence-and-associativity.md)<br/>
[Операторы присваивания в C](../c-language/c-assignment-operators.md)
