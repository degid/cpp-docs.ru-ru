---
title: Строковые и символьные литералы (C++)
description: Как объявить и определить строковые и символьные литералы в C++.
ms.date: 02/18/2020
f1_keywords:
- R
- L
- u
- u8
- LR
- uR
- u8R
helpviewer_keywords:
- literal strings [C++]
- string literals [C++]
ms.assetid: 61de8f6f-2714-4e7b-86b6-a3f885d3b9df
ms.openlocfilehash: 60389ecf01cf16b1cf2a86fc68da94bd558b6d83
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231134"
---
# <a name="string-and-character-literals-c"></a>Строковые и символьные литералы (C++)

В C++ поддерживаются различные типы строк и символов, а также доступны различные способы выражения значений литералов каждого из этих типов. В исходном коде содержимое символьных и строковых литералов выражается с помощью кодировки. Универсальные имена символов и escape-символы позволяют представить любую строку, используя только основную кодировку исходного кода. Необработанные строковые литералы позволяют не использовать escape-символы и могут применяться для выражения всех типов строковых литералов. Можно также создавать `std::string` литералы без необходимости выполнения дополнительных действий по созданию или преобразованию.

```cpp
#include <string>
using namespace std::string_literals; // enables s-suffix for std::string literals

int main()
{
    // Character literals
    auto c0 =   'A'; // char
    auto c1 = u8'A'; // char
    auto c2 =  L'A'; // wchar_t
    auto c3 =  u'A'; // char16_t
    auto c4 =  U'A'; // char32_t

    // Multicharacter literals
    auto m0 = 'abcd'; // int, value 0x61626364

    // String literals
    auto s0 =   "hello"; // const char*
    auto s1 = u8"hello"; // const char*, encoded as UTF-8
    auto s2 =  L"hello"; // const wchar_t*
    auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16
    auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32

    // Raw string literals containing unescaped \ and "
    auto R0 =   R"("Hello \ world")"; // const char*
    auto R1 = u8R"("Hello \ world")"; // const char*, encoded as UTF-8
    auto R2 =  LR"("Hello \ world")"; // const wchar_t*
    auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16
    auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32

    // Combining string literals with standard s-suffix
    auto S0 =   "hello"s; // std::string
    auto S1 = u8"hello"s; // std::string
    auto S2 =  L"hello"s; // std::wstring
    auto S3 =  u"hello"s; // std::u16string
    auto S4 =  U"hello"s; // std::u32string

    // Combining raw string literals with standard s-suffix
    auto S5 =   R"("Hello \ world")"s; // std::string from a raw const char*
    auto S6 = u8R"("Hello \ world")"s; // std::string from a raw const char*, encoded as UTF-8
    auto S7 =  LR"("Hello \ world")"s; // std::wstring from a raw const wchar_t*
    auto S8 =  uR"("Hello \ world")"s; // std::u16string from a raw const char16_t*, encoded as UTF-16
    auto S9 =  UR"("Hello \ world")"s; // std::u32string from a raw const char32_t*, encoded as UTF-32
}
```

Строковые литералы могут не иметь префикса или включать префиксы `u8`, `L`, `u`и  `U` для обозначения кодировок обычных символов (однобайтовых или многобайтовых), UTF-8, расширенных символов (UCS-2 или UTF-16), UTF-16 и UTF-32, соответственно. Необработанный строковый литерал может иметь `R` `u8R` `LR` префиксы,,, `uR` и `UR` для необработанных эквивалентов этих кодировок.  Чтобы создать временные или статические `std::string` значения, можно использовать строковые литералы или необработанные строковые литералы с `s` суффиксом. Дополнительные сведения см. в разделе [строковые литералы](#string-literals) ниже. Дополнительные сведения о базовой кодировке исходного кода, универсальных именах символов и использовании символов из расширенных кодовых страниц в исходном коде см. в разделе [наборы символов](../cpp/character-sets.md).

## <a name="character-literals"></a>Символьные литералы

*Символьный литерал* состоит из символьной константы. Он представляется символом, заключенным в одинарные кавычки. Существует пять типов символьных литералов:

- Обычные символьные литералы типа **`char`** , например`'a'`

- Символьные литералы UTF-8 типа **`char`** ( **`char8_t`** в c++ 20), например`u8'a'`

- Литералы с расширенными символами типа **`wchar_t`** , например`L'a'`

- Символьные литералы UTF-16 типа **`char16_t`** , например`u'a'`

- UTF-32 символьные литералы типа **`char32_t`** , например`U'a'`

Символ, используемый для символьного литерала, может быть любым символом, за исключением символов обратной косой черты ( **`\`** ), одинарной кавычки ( **`'`** ) или новой строки. Зарезервированные символы можно указывать с помощью escape-последовательности. Символы можно указывать с помощью универсальных имен символов, при условии что тип является достаточно крупным для размещения символа.

### <a name="encoding"></a>Кодирование

Символьные литералы кодируются по-разному в соответствии с их префиксом.

- Символьный литерал без префикса является обычным символьным литералом. Значение обычного символьного литерала, содержащего один символ, escape-последовательность или универсальное имя символа, которое может быть представлено в наборе символов выполнения, имеет значение, равное числовому значению его кодировки в наборе символов выполнения. Обычный символьный литерал, содержащий более одного символа, escape-последовательности или универсального имени символа, является *многосимвольным литералом*. Многосимвольный литерал или обычный символьный литерал, который не может быть представлен в наборе символов выполнения **`int`** , имеет тип, а его значение определяется реализацией. Сведения о КОМПИЛЯТОРОМ MSVC см. в разделе, **относящемся к Microsoft** .

- Символьный литерал, начинающийся с `L` префикса, является литералом расширенных символов. Значение литерала расширенных символов, содержащего один символ, escape-последовательность или универсальное имя символа, имеет значение, равное числовому значению его кодировки в наборе расширенных символов выполнения, если только символьный литерал не имеет представления в наборе расширенных символов выполнения, в этом случае значение определяется реализацией. Значение литерала расширенных символов, содержащего несколько символов, escape-последовательностями или универсальных имен символов, определяется реализацией. Сведения о КОМПИЛЯТОРОМ MSVC см. в разделе, **относящемся к Microsoft** .

- Символьный литерал, начинающийся с `u8` префикса, является символьным литералом UTF-8. Значение символьного литерала UTF-8, содержащего один символ, escape-последовательность или универсальное имя символа, имеет значение, равное значению его кодовой точки ISO 10646, если оно может быть представлено в одной единице кода UTF-8 (соответствующее элементам управления C0 и основному регистру символов латиницы). Если значение не может быть представлено одной единицей кода UTF-8, программа неправильно сформирована. Символьный литерал в кодировке UTF-8, содержащий более одного символа, escape-последовательности или универсального имени символа, имеет неправильный формат.

- Символьный литерал, начинающийся с `u` префикса, является символьным литералом UTF-16. Значение символьного литерала UTF-16, содержащего один символ, escape-последовательность или универсальное имя символа, имеет значение, равное значению его кодовой точки ISO 10646, если оно может быть представлено одной единицей кода UTF-16 (соответствующей базовой многоязыковой плоскости). Если значение не может быть представлено одной единицей кода UTF-16, программа неправильно сформирована. Символьный литерал UTF-16, содержащий более одного символа, escape-последовательности или универсального имени символа, имеет неправильный формат.

- Символьный литерал, начинающийся с `U` префикса, является символьным литералом UTF-32. Значение символьного литерала UTF-32, содержащего один символ, escape-последовательность или универсальное имя символа, имеет значение, равное значению кодовой точки ISO 10646. Символьный литерал в кодировке UTF-32, содержащий более одного символа, escape-последовательности или универсального имени символа, имеет неправильный формат.

### <a name="escape-sequences"></a><a name="bkmk_Escape"></a>Escape-последовательности

Существует три вида escape-последовательностей: простая, восьмеричная и шестнадцатеричная. Escape-последовательностями могут быть следующие значения:

|Значение|Escape-последовательность|
|-----------|---------------------|
| новая строка | \\n |
| обратная косая черта | \\\\ |
| горизонтальная табуляция | \\t |
| вопросительный знак | ? или \\? |
| вертикальная табуляция | \\3,3 |
| одинарная кавычка | \\' |
| BACKSPACE | \\& |
| двойная кавычка | \\" |
| Возврат каретки | \\Cерверный |
| нуль-символ | \\0 |
| Смена страницы | \\ж |
| восьмеричный | \\ooo |
| оповещение (колокольчик) | \\a |
| шестнадцатеричный | \\ксххх |

Восьмеричная escape-последовательность — это обратная косая черта, за которой следует последовательность из одной до трех восьмеричных цифр. Восьмеричная escape-последовательность завершается на первом символе, который не является восьмеричной цифрой, если он встречается раньше, чем третья цифра. Наибольшее возможное восьмеричное значение — `\377` .

Шестнадцатеричная escape-последовательность — это обратная косая черта, за которой следует символ `x` , за которым следует последовательность из одной или нескольких шестнадцатеричных цифр. Начальные нули пропускаются. В обычном или U8 символьном литерале самое высокое шестнадцатеричное значение — 0xFF. В расширенном символьном литерале с префиксом L или u максимальное шестнадцатеричное значение — 0xFFFF. В расширенном символьном литерале с префиксом U максимальное шестнадцатеричное значение — 0xFFFFFFFF.

В этом примере кода показаны некоторые примеры экранированных символов с помощью обычных символьных литералов. Один и тот же синтаксис escape-последовательности допустим для других типов символьных литералов.

```cpp
#include <iostream>
using namespace std;

int main() {
    char newline = '\n';
    char tab = '\t';
    char backspace = '\b';
    char backslash = '\\';
    char nullChar = '\0';

    cout << "Newline character: " << newline << "ending" << endl;
    cout << "Tab character: " << tab << "ending" << endl;
    cout << "Backspace character: " << backspace << "ending" << endl;
    cout << "Backslash character: " << backslash << "ending" << endl;
    cout << "Null character: " << nullChar << "ending" << endl;
}
/* Output:
Newline character:
ending
Tab character:  ending
Backspace character:ending
Backslash character: \ending
Null character:  ending
*/
```

Обратная косая черта ( **`\`** ) — это символ продолжения строки, когда он помещается в конец строки. Если требуется, чтобы символ обратной косой черты отображался в виде символьного литерала, необходимо ввести две обратные косые черты в строке ( **`\\`** ). Дополнительные сведения о символе продолжения строки см. в разделе [Phases of Translation](../preprocessor/phases-of-translation.md).

#### <a name="microsoft-specific"></a>Специально для систем Майкрософт

Чтобы создать значение из короткого многосимвольного литерала, компилятор преобразует символ или последовательность символов между одинарными кавычками в 8-битные значения в пределах 32-разрядного целого числа. Несколько символов в литерале заполняют соответствующие байты по мере необходимости от высокого до низкого порядка. Затем компилятор преобразует целое число в целевой тип после обычных правил. Например, чтобы создать **`char`** значение, компилятор принимает байт нижнего порядка. Чтобы создать **`wchar_t`** значение или **`char16_t`** , компилятор принимает слово низкого порядка. Компилятор выдает предупреждение о том, что результат усекается, если какие-либо биты заданы выше назначенного байта или слова.

```cpp
char c0    = 'abcd';    // C4305, C4309, truncates to 'd'
wchar_t w0 = 'abcd';    // C4305, C4309, truncates to '\x6364'
int i0     = 'abcd';    // 0x61626364
```

Восьмеричная escape-последовательность, которая содержит более трех цифр, рассматривается как восьмеричная последовательность из 3 цифр, за которой следуют последующие цифры как символы в многосимвольном литерале, что может привести к неудивительному результату. Например:

```cpp
char c1 = '\100';   // '@'
char c2 = '\1000';  // C4305, C4309, truncates to '0'
```

Escape-последовательности, которые содержат невосьмеричные символы, вычисляются в виде восьмеричной последовательности вплоть до последнего восьмеричного символа, за которыми следуют оставшиеся символы в виде последующих символов в многосимвольном литерале. Предупреждение C4125 создается, если первый невосьмеричный символ является десятичной цифрой. Например:

```cpp
char c3 = '\009';   // '9'
char c4 = '\089';   // C4305, C4309, truncates to '9'
char c5 = '\qrs';   // C4129, C4305, C4309, truncates to 's'
```

Восьмеричная escape-последовательность, которая имеет большее значение, чем `\377` Ошибка C2022: "*значение-in-Decimal*": слишком большое для символа.

Escape-последовательность, которая содержит шестнадцатеричные и нешестнадцатеричные символы, вычисляется как многосимвольный литерал, содержащий шестнадцатеричную escape-последовательность вплоть до последнего шестнадцатеричного символа, за которыми следуют нешестнадцатеричные символы. Шестнадцатеричная escape-последовательность, которая не содержит шестнадцатеричных цифр, приводит к ошибке компилятора C2153: "шестнадцатеричные литералы должны содержать по крайней мере одну шестнадцатеричную цифру".

```cpp
char c6 = '\x0050'; // 'P'
char c7 = '\x0pqr'; // C4305, C4309, truncates to 'r'
```

Если в расширенном символьном литерале с префиксом `L` содержится последовательность из множества символов, значение берется из первого символа, а компилятор выдает предупреждение C4066. Последующие символы игнорируются, в отличие от поведения эквивалентного обычного многосимвольного литерала.

```cpp
wchar_t w1 = L'\100';   // L'@'
wchar_t w2 = L'\1000';  // C4066 L'@', 0 ignored
wchar_t w3 = L'\009';   // C4066 L'\0', 9 ignored
wchar_t w4 = L'\089';   // C4066 L'\0', 89 ignored
wchar_t w5 = L'\qrs';   // C4129, C4066 L'q' escape, rs ignored
wchar_t w6 = L'\x0050'; // L'P'
wchar_t w7 = L'\x0pqr'; // C4066 L'\0', pqr ignored
```

Раздел, **относящийся к корпорации Майкрософт** , заканчивается здесь.

### <a name="universal-character-names"></a><a name="bkmk_UCN"></a>Универсальные имена символов

В символьных литералах и машинных (не являющихся необработанными) строковых литералах любой символ может быть представлен универсальным именем символа.  Универсальные имена символов формируются с помощью префикса, `\U` за которым следует 8-значная кодовая точка Юникода или префикс, `\u` за которым следует 4-значная кодовая точка Юникода. Все восемь или четыре знака, соответственно, должны присутствовать для создания корректного универсального имени символа.

```cpp
char u1 = 'A';          // 'A'
char u2 = '\101';       // octal, 'A'
char u3 = '\x41';       // hexadecimal, 'A'
char u4 = '\u0041';     // \u UCN 'A'
char u5 = '\U00000041'; // \U UCN 'A'
```

#### <a name="surrogate-pairs"></a>Суррогатные пары

Универсальные имена символов не могут кодировать значения в суррогатном диапазоне кодовых точек D800-DFFF. Для суррогатных пар Юникода укажите универсальное имя символа, используя `\UNNNNNNNN`, где NNNNNNNN — восьмизначная кодовая точка для символа. При необходимости компилятор создает суррогатную пару.

В C++03 языком допускалось, чтобы универсальными именами символов представлялось лишь определенное подмножество символов. Также могли существовать универсальные имена символов, не представляющие никаких допустимых символов Юникода. Эта ошибка была исправлена в стандарте C++ 11. В C++11 в символьных и строковых литералах и идентификаторах можно использовать универсальные имена символов.  Дополнительные сведения об универсальных именах символов см. в разделе [Character Sets](../cpp/character-sets.md). Дополнительные сведения о Юникоде см. в статье [Unicode](/windows/win32/intl/unicode). Дополнительные сведения о суррогатных парах см. в статье [Surrogate Pairs and Supplementary Characters](/windows/win32/Intl/surrogates-and-supplementary-characters)(Суррогатные пары и дополнительные символы).

## <a name="string-literals"></a><a name="string-literals"></a>Строковые литералы

Строковый литерал представляет последовательность символов, которые вместе образуют строку с завершающим нулем. Символы должны быть заключены в двойные кавычки. Существуют следующие типы строковых литералов.

### <a name="narrow-string-literals"></a>Узкие строковые литералы

Узким строковым литералом является нефиксированный, разделенный символами двойной кавычки массив типа `const char[n]` , где n — это длина массива в байтах. Обычный строковый литерал может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Обычный строковый литерал также может содержать перечисленные выше escape-последовательности и универсальные имена символов, которые помещаются в байте.

```cpp
const char *narrow = "abcd";

// represents the string: yes\no
const char *escaped = "yes\\no";
```

#### <a name="utf-8-encoded-strings"></a>Строки в кодировке UTF-8

Строка в кодировке UTF-8 — это U8 с двойной кавычкой, разделенный нулем массив типа `const char[n]` , где *n* — это длина закодированного массива в байтах. Строковый литерал с префиксом u8 может содержать любые графические символы, за исключением двойных кавычек (`"`), обратной косой черты (`\`) или символа новой строки. Строковый литерал с префиксом u8 может также содержать перечисленные выше escape-последовательности и любые универсальные имена символов.

```cpp
const char* str1 = u8"Hello World";
const char* str2 = u8"\U0001F607 is O:-)";
```

### <a name="wide-string-literals"></a>Широкие строковые литералы

Широкий строковый литерал — это массив констант, заканчивающийся нулем **`wchar_t`** , который имеет префикс " `L` " и содержит любой графический символ, кроме двойных кавычек ( **`"`** ), обратной косой черты ( **`\`** ) или символа новой строки. Расширенный строковый литерал может содержать перечисленные выше escape-последовательности и любые универсальные имена символов.

```cpp
const wchar_t* wide = L"zyxw";
const wchar_t* newline = L"hello\ngoodbye";
```

#### <a name="char16_t-and-char32_t-c11"></a>char16_t и char32_t (C++11)

В c++ 11 введены переносимые **`char16_t`** (16-разрядные Юникод) и **`char32_t`** (32-разрядные Юникод) символы типа:

```cpp
auto s3 = u"hello"; // const char16_t*
auto s4 = U"hello"; // const char32_t*
```

### <a name="raw-string-literals-c11"></a>Необработанные строковые литералы (C++ 11)

Необработанный строковый литерал — это массив с завершающим нулем (любой символьный тип), содержащий любой графический символ, включая двойные кавычки ( **`"`** ), обратную косую черту ( **`\`** ) или символ новой строки. Необработанные строковые литералы часто применяются в регулярных выражениях, которые используют классы символов, а также в строках HTML и XML. Примеры см. в следующей статье: [Bjarne Stroustrup's FAQ on C++11](http://www.stroustrup.com/C++11FAQ.html)(Вопросы и ответы о C++11 от Бьерна Страуструпа).

```cpp
// represents the string: An unescaped \ character
const char* raw_narrow = R"(An unescaped \ character)";
const wchar_t* raw_wide = LR"(An unescaped \ character)";
const char*       raw_utf8  = u8R"(An unescaped \ character)";
const char16_t* raw_utf16 = uR"(An unescaped \ character)";
const char32_t* raw_utf32 = UR"(An unescaped \ character)";
```

Разделитель — это определяемая пользователем последовательность длиной до 16 символов, которая непосредственно предшествует открывающей скобке необработанного строкового литерала и сразу после закрывающей скобки.  Например, в `R"abc(Hello"\()abc"` последовательность разделителей — `abc` , а содержимое строки — `Hello"\(`. Разделители можно использовать для различения необработанных строк, содержащих двойные кавычки и круглые скобки. Этот строковый литерал вызывает ошибку компилятора:

```cpp
// meant to represent the string: )"
const char* bad_parens = R"()")";  // error C2059
```

Однако ошибку можно устранить с помощью разделителя:

```cpp
const char* good_parens = R"xyz()")xyz";
```

Можно создать необработанный строковый литерал, содержащий символ новой строки (не экранированный символ) в источнике:

```cpp
// represents the string: hello
//goodbye
const wchar_t* newline = LR"(hello
goodbye)";
```

### <a name="stdstring-literals-c14"></a>литералы std::string (C++ 14)

`std::string`литералы являются реализациями определяемых пользователем литералов в стандартной библиотеке (см. ниже), которые представлены как `"xyz"s` (с `s` суффиксом). Этот тип строкового литерала создает временный объект типа `std::string` , `std::wstring` , `std::u32string` или `std::u16string` , в зависимости от указанного префикса. Если префикс не используется, то создается `std::string` . `L"xyz"s`создает `std::wstring` . `u"xyz"s`создает [std::u16string](../standard-library/string-typedefs.md#u16string)и `U"xyz"s` создает [std::u32string](../standard-library/string-typedefs.md#u32string).

```cpp
//#include <string>
//using namespace std::string_literals;
string str{ "hello"s };
string str2{ u8"Hello World" };
wstring str3{ L"hello"s };
u16string str4{ u"hello"s };
u32string str5{ U"hello"s };
```

`s`Суффикс можно также использовать для необработанных строковых литералов:

```cpp
u32string str6{ UR"(She said "hello.")"s };
```

`std::string`литералы определяются в пространстве имен `std::literals::string_literals` в \<string> файле заголовка. Поскольку `std::literals::string_literals` и `std::literals` объявляются как [встроенные пространства имен](../cpp/namespaces-cpp.md), `std::literals::string_literals` автоматически обрабатывается так, как если бы он принадлежал непосредственно в пространстве имен `std` .

### <a name="size-of-string-literals"></a>Размер строковых литералов

Для `char*` строк ANSI и других однобайтовых кодировок (но не UTF-8) размер строкового литерала (в байтах) — это число символов плюс 1 для завершающего нуль-символа. Для всех других типов строк размер не строго связан с числом символов. UTF-8 использует до четырех **`char`** элементов для кодирования некоторых *единиц кода*, а **`char16_t`** или **`wchar_t`** кодирования UTF-16 может использовать два элемента (всего четыре байта) для кодирования одной *единицы кода*. В примере ниже показан размер расширенного строкового литерала в байтах.

```cpp
const wchar_t* str = L"Hello!";
const size_t byteSize = (wcslen(str) + 1) * sizeof(wchar_t);
```

Обратите внимание, что `strlen()` и `wcslen()` не включайте размер завершающего нуль-символа, размер которого равен размеру элемента строкового типа: один байт в `char*` `char8_t*` строке или, два байта `wchar_t*` или `char16_t*` строки и четыре байта в `char32_t*` строках.

Максимальная длина строкового литерала составляет 65 535 байт. Это ограничение применимо как к узким, так и к расширенным строковым литералам.

### <a name="modifying-string-literals"></a>Изменение строковых литералов

Поскольку строковые литералы (не включая `std::string` литералы) являются константами, попытка их изменить, например, `str[2] = 'A'` приводит к ошибке компилятора.

#### <a name="microsoft-specific"></a>Специально для систем Майкрософт

В Microsoft C++ можно использовать строковый литерал для инициализации указателя на не-const **`char`** или **`wchar_t`** . Эта неконстантная инициализация разрешена в коде C99, но не рекомендуется в C++ 98 и удалена в C++ 11. Попытка изменить строку вызовет нарушение прав доступа, как показано в следующем примере:

```cpp
wchar_t* str = L"hello";
str[2] = L'a'; // run-time error: access violation
```

Если задать параметр компилятора [ `/Zc:strictStrings` (отключить преобразование типов строковых литералов)](../build/reference/zc-strictstrings-disable-string-literal-type-conversion.md) , то при преобразовании строкового литерала в указатель неконстантного символа компилятор может выдать ошибку. Рекомендуется использовать его для создания переносимого кода, соответствующего стандартам. Также рекомендуется использовать **`auto`** ключевое слово для объявления инициализированных указателей строкового литерала, так как он разрешается в правильный (const) тип. В следующем примере кода перехватывается во время компиляции попытка записать в строковый литерал:

```cpp
auto str = L"hello";
str[2] = L'a'; // C3892: you cannot assign to a variable that is const.
```

В некоторых случаях идентичные строковые литералы могут быть объединены в пул для экономии места в исполняемом файле. При объединении строковых литералов в пулы компилятор делает так, что все ссылки на определенный строковый литерал указывают на одну и ту же область в памяти, вместо того чтобы каждая ссылка указывала на отдельный экземпляр строкового литерала. Чтобы включить объединение строк, используйте [`/GF`](../build/reference/gf-eliminate-duplicate-strings.md) параметр компилятора.

Раздел, **относящийся к корпорации Майкрософт** , заканчивается здесь.

### <a name="concatenating-adjacent-string-literals"></a>Сцепление смежных строковых литералов

Все смежные расширенные и узкие строковые литералы соединяются. Данное объявление:

```cpp
char str[] = "12" "34";
```

идентично следующему объявлению:

```cpp
char atr[] = "1234";
```

и следующему объявлению:

```cpp
char atr[] =  "12\
34";
```

Использование внедренных шестнадцатеричных escape-кодов для задания строковых литералов может привести к непредвиденным результатам. В следующем примере выполняется попытка создать строковый литерал, содержащий символ ASCII 5, за которым следуют символы f, i, v и e:

```cpp
"\x05five"
```

Фактический результат (шестнадцатеричное значение 5F) является кодом ASCII для символа подчеркивания, за которым следуют символы i, v и e. Чтобы получить правильный результат, можно использовать одну из следующих escape-последовательностей:

```cpp
"\005five"     // Use octal literal.
"\x05" "five"  // Use string splicing.
```

`std::string`литералы, так как они `std::string` являются типами, могут быть объединены с **`+`** оператором, определенным для [`basic_string`](../standard-library/basic-string-class.md) типов. Эти литералы также можно соединить аналогично смежным строковым литералам. В обоих случаях кодировка строки и суффикс должны совпадать:

```cpp
auto x1 = "hello" " " " world"; // OK
auto x2 = U"hello" " " L"world"; // C2308: disagree on prefix
auto x3 = u8"hello" " "s u8"world"s; // OK, agree on prefixes and suffixes
auto x4 = u8"hello" " "s u8"world"z; // C3688, disagree on suffixes
```

### <a name="string-literals-with-universal-character-names"></a>Строковые литералы с универсальными именами символов

Машинные (не являющиеся необработанными) строковые литералы могут использовать универсальные имена символов для представления любого символа, при условии что универсальные имена можно кодировать как один или несколько символов в строковом типе.  Например, универсальное имя символа, представляющее расширенный символ, не может быть закодировано в виде короткой строки с помощью кодовой страницы ANSI, но может быть закодировано в виде узких строк в некоторых многобайтовых кодовых страницах или в строках UTF-8 или в расширенной строке. В C++ 11 Поддержка Юникода расширена с помощью `char16_t*` `char32_t*` строковых типов и.

```cpp
// ASCII smiling face
const char*     s1 = ":-)";

// UTF-16 (on Windows) encoded WINKING FACE (U+1F609)
const wchar_t*  s2 = L"😉 = \U0001F609 is ;-)";

// UTF-8  encoded SMILING FACE WITH HALO (U+1F607)
const char*     s3 = u8"😇 = \U0001F607 is O:-)";

// UTF-16 encoded SMILING FACE WITH OPEN MOUTH (U+1F603)
const char16_t* s4 = u"😃 = \U0001F603 is :-D";

// UTF-32 encoded SMILING FACE WITH SUNGLASSES (U+1F60E)
const char32_t* s5 = U"😎 = \U0001F60E is B-)";
```

## <a name="see-also"></a>См. также статью

[Наборы символов](../cpp/character-sets.md)\
[Числовые, логические литералы и константы указателей](../cpp/numeric-boolean-and-pointer-literals-cpp.md)\
[Пользовательские литералы](../cpp/user-defined-literals-cpp.md)
