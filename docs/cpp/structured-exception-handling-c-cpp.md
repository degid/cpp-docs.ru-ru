---
title: Structured Exception Handling (C/C++)
description: Общие сведения об структурированной обработке исключений в Microsoft C/C++.
ms.date: 08/24/2020
helpviewer_keywords:
- termination handlers [C++], handling exceptions in C++
- structured exception handling [C++]
- try-catch keyword [C++], exception handlers
- C++ exception handling, termination handlers
- try-catch keyword [C++], termination handlers
- C++ exception handling, exception handlers
ms.assetid: dd3b647d-c269-43a8-aab9-ad1458712976
ms.openlocfilehash: 142e89bc82adbe7938e8825029908e814df6055c
ms.sourcegitcommit: efc8c32205c9d610f40597556273a64306dec15d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/26/2020
ms.locfileid: "88898634"
---
# <a name="structured-exception-handling-cc"></a>Structured Exception Handling (C/C++)

Структурированная обработка исключений (SEH) — это расширение Майкрософт для языка C для обработки определенных исключительных ситуаций кода, таких как ошибки оборудования, корректно. Хотя Windows и Microsoft C++ поддерживают SEH, рекомендуется использовать обработку исключений C++ в стандарте ISO. Это делает код более переносимым и гибким. Однако для поддержки существующего кода или определенных типов программ все равно может потребоваться использовать SEH.

**Зависит от корпорации Майкрософт:**

## <a name="grammar"></a>Грамматика

> *`try-except-statement`* :<br/>
> &emsp;**`__try`** *`compound-statement`* **`__except`** **`(`** *`expression`* **`)`** *`compound-statement`*
>
> *`try-finally-statement`* :<br/>
> &emsp;**`__try`** *`compound-statement`* **`__finally`** *`compound-statement`*

## <a name="remarks"></a>Примечания

С помощью SEH можно обеспечить правильное освобождение ресурсов, например блоков памяти и файлов, в случае непредвиденного завершения выполнения. Можно также решить определенные проблемы (например, недостаток памяти), используя краткий структурированный код, который не полагается на **`goto`** инструкции или тщательное тестирование кодов возврата.

`try-except`Инструкции и, `try-finally` упоминаемые в этой статье, являются расширениями Майкрософт для языка C. Они поддерживают SEH, позволяя приложениям получать контроль над программой после событий, которые в иных ситуациях привели бы к завершению выполнения. Хотя обработка ошибок SEH работает с исходными файлами C++, она не была создана специально для этого языка. При использовании SEH в программе C++, компилируемой с помощью параметра [ `/EHa` или `/EHsc` ](../build/reference/eh-exception-handling-model.md) , вызываются деструкторы для локальных объектов, но другое поведение выполнения может отличаться от ожидаемого. Иллюстрации см. в примере далее в этой статье. В большинстве случаев вместо SEH рекомендуется использовать [обработку исключений C++](../cpp/try-throw-and-catch-statements-cpp.md)в стандарте ISO, которую также поддерживает компилятор Microsoft C++. С помощью обработки исключений C++ можно повысить переносимость кода и обрабатывать исключения любого типа.

При наличии кода C, использующего SEH, можно смешивать его с кодом C++, использующим обработку исключений C++. Дополнительные сведения см. [в разделе Handle Structured Exceptions in C++](../cpp/exception-handling-differences.md).

Существует два механизма SEH.

- [Обработчики исключений](../cpp/writing-an-exception-handler.md)или **`__except`** блоки, которые могут реагировать на исключение или закрыть его.

- [Обработчики завершения](../cpp/writing-a-termination-handler.md)или **`__finally`** блоки, которые вызываются всегда, если исключение вызывает завершение или нет.

Эти два типа обработчиков различаются, но тесно связаны с процессом, называемым очисткой *стека*. При возникновении структурированного исключения Windows ищет недавно установленный обработчик исключений, который сейчас является активным. Обработчик может выполнить одно из трех действий:

- не распознать исключение и передать управление другим обработчикам;

- распознать исключение, но отбросить его;

- распознать исключение и обработать его.

Обработчик исключений, распознавший исключение, может находиться за пределами функции, которая выполнялась, когда возникло исключение. В стеке он может находиться в функции намного выше. Выполняемая в настоящее время функция и все прочие функции в кадре стека завершаются. Во время этого процесса стек будет *развернут*. То есть локальные нестатические переменные завершенных функций удаляются из стека.

По мере развертывания стека операционная система вызывает все обработчики завершения, которые были написаны для каждой функции. Используя обработчик завершения, вы очищаете ресурсы, которые в противном случае останутся открытыми из-за аварийного завершения. Если вы ввели критическую секцию, вы можете выйти из него в обработчике завершения. После завершения работы программы можно выполнять другие задачи по обслуживанию, такие как закрытие и удаление временных файлов.

## <a name="next-steps"></a>Дальнейшие действия

- [Написание обработчика исключений](../cpp/writing-an-exception-handler.md)

- [Написание обработчика завершения](../cpp/writing-a-termination-handler.md)

- [Обработка структурированных исключений в C++](../cpp/exception-handling-differences.md)

## <a name="example"></a>Пример

Как упоминалось ранее, деструкторы для локальных объектов вызываются, если вы используете SEH в программе C++ и компилируете его с помощью **`/EHa`** **`/EHsc`** параметра или. Однако поведение во время выполнения может отличаться от ожидаемого, если вы также используете исключения C++. В этом примере демонстрируются эти различия в поведении.

```cpp
#include <stdio.h>
#include <Windows.h>
#include <exception>

class TestClass
{
public:
    ~TestClass()
    {
        printf("Destroying TestClass!\r\n");
    }
};

__declspec(noinline) void TestCPPEX()
{
#ifdef CPPEX
    printf("Throwing C++ exception\r\n");
    throw std::exception("");
#else
    printf("Triggering SEH exception\r\n");
    volatile int *pInt = 0x00000000;
    *pInt = 20;
#endif
}

__declspec(noinline) void TestExceptions()
{
    TestClass d;
    TestCPPEX();
}

int main()
{
    __try
    {
        TestExceptions();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        printf("Executing SEH __except block\r\n");
    }

    return 0;
}
```

Если вы используете **`/EHsc`** для компиляции этого кода, но локальный макрос элемента управления теста `CPPEX` не определен, `TestClass` деструктор не выполняется. Выходные данные выглядят следующим образом.

```Output
Triggering SEH exception
Executing SEH __except block
```

Если используется **`/EHsc`** для компиляции кода и `CPPEX` определяется с помощью `/DCPPEX` (чтобы выдавалось исключение C++), `TestClass` выполняется деструктор, а выходные данные выглядят следующим образом:

```Output
Throwing C++ exception
Destroying TestClass!
Executing SEH __except block
```

Если используется **`/EHa`** для компиляции кода, деструктор выполняет исключение, вызванное вызовом `TestClass` исключения с помощью или с `std::throw` помощью SEH. То есть определяет, `CPPEX` определен ли тип или нет. Выходные данные выглядят следующим образом.

```Output
Throwing C++ exception
Destroying TestClass!
Executing SEH __except block
```

Дополнительные сведения см. в разделе [ `/EH` (модель обработки исключений)](../build/reference/eh-exception-handling-model.md).

**Завершение для конкретной корпорации Майкрософт**

## <a name="see-also"></a>См. также

[Обработка исключений](../cpp/exception-handling-in-visual-cpp.md)<br/>
[Ключевые слова](../cpp/keywords-cpp.md)<br/>
[`<exception>`](../standard-library/exception.md)<br/>
[Ошибки и обработка исключений](../cpp/errors-and-exception-handling-modern-cpp.md)<br/>
[Структурированная обработка исключений (Windows)](/windows/win32/debug/structured-exception-handling)
