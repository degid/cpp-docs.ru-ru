---
title: align (C++)
ms.date: 12/17/2018
f1_keywords:
- align_cpp
helpviewer_keywords:
- align __declspec keyword
- __declspec keyword [C++], align
ms.assetid: 9cb63f58-658b-4425-ac47-af8eabfc5878
ms.openlocfilehash: 0a1212f1c78f49029f82be5a2f5d82ea1788b6e0
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87227664"
---
# <a name="align-c"></a>align (C++)

В Visual Studio 2015 и более поздних версиях **`alignas`** для управления выравниванием используйте стандартный описатель c++ 11. Дополнительные сведения см. в разделе [Выравнивание](../cpp/alignment-cpp-declarations.md).

**Блок, относящийся только к системам Microsoft**

Используйте `__declspec(align(#))` для точного управления выравниванием пользовательских данных (например, статическими распределениями или автоматическими данными в функции).

## <a name="syntax"></a>Синтаксис

> **Декларатор __declspec (выровняйте (** *#* **))** *declarator*

## <a name="remarks"></a>Примечания

Написание приложений, использующих последние инструкции процессора, связано с некоторыми новыми ограничениями и проблемами. Для многих новых инструкций требуются данные, которые выводятся по 16-байтным границам. Кроме того, путем согласования часто используемых данных с размером строки кэша процессора повышается производительность кэша. Например, если определена структура, размер которой меньше 32 байт, то может потребоваться 32 байтов, чтобы обеспечить эффективное кэширование объектов этого типа структуры.

\#значение выравнивания. Допустимые записи — целые степени двух значений от 1 до 8192 (байты), например 2, 4, 8, 16, 32 или 64. `declarator`— Это данные, которые объявляются как согласованные.

Сведения о том, как вернуть значение типа `size_t` , которое является требованием выравнивания для типа, см. в разделе [`alignof`](../cpp/alignof-operator.md) . Сведения об объявлении несогласованных указателей при нацеливании на 64-разрядные процессоры см. в разделе [`__unaligned`](../cpp/unaligned.md) .

Можно использовать `__declspec(align(#))` при определении **`struct`** , **`union`** или **`class`** , или при объявлении переменной.

Компилятор не гарантирует или не пытается сохранить атрибут выравнивания данных во время операции копирования или преобразования данных. Например, [`memcpy`](../c-runtime-library/reference/memcpy-wmemcpy.md) может скопировать структуру, объявленную с `__declspec(align(#))` , в любое расположение. Обычные распределителя (например, [`malloc`](../c-runtime-library/reference/malloc.md) C++ [`operator new`](new-operator-cpp.md) и распределителя Win32) обычно возвращают память, которая не полностью соответствует `__declspec(align(#))` структурам или массивам структур. Чтобы гарантировать, что назначение копирования или операции преобразования данных будет правильно согласовано, используйте [`_aligned_malloc`](../c-runtime-library/reference/aligned-malloc.md) . Или напишите собственный распределитель.

Нельзя указать выравнивание для параметров функции. При передаче данных с атрибутом выравнивания по значению в стеке его выравнивание регулируется соглашением о вызовах. Если в вызываемой функции важно выравнивание данных, скопируйте параметр в правильно выровненную память перед использованием.

Без этого `__declspec(align(#))` компилятор обычно выровнять данные по естественным границам, исходя из целевого процессора и размера данных, до 4-байтовых границ на 32-разрядных процессорах и 8-байтовых границ на 64-разрядных процессорах. Данные в классах или структурах выравниваться в классе или структуре на минимальном уровне естественного выравнивания и текущем параметре упаковки (от `#pragma pack` или `/Zp` параметра компилятора).

В этом примере демонстрируется использование `__declspec(align(#))`:

```cpp
__declspec(align(32)) struct Str1{
   int a, b, c, d, e;
};
```

Теперь этот тип содержит 32-разрядный атрибут выравнивания. Это означает, что все статические и автоматические экземпляры начинаются на границе 32 байта. Дополнительные типы структуры, объявленные с этим типом в качестве члена, сохраняют атрибут выравнивания этого типа, то есть любая структура с `Str1` элементом имеет атрибут выравнивания не менее 32.

Здесь, `sizeof(struct Str1)` равно 32. Это означает, что если создается массив `Str1` объектов, а основание массива составляет 32 байт, то каждый элемент массива также имеет значение, равное 32 байт. Чтобы создать массив, базовый объект которого правильно соответствует динамической памяти, используйте [`_aligned_malloc`](../c-runtime-library/reference/aligned-malloc.md) . Или напишите собственный распределитель.

**`sizeof`** Значением для любой структуры является смещение последнего элемента, а также его размер, округленный до ближайшего числа, кратного наибольшему значению выравнивания элемента или целому значению выравнивания структуры, в зависимости от того, какое значение больше.

Компилятор использует эти правила для выравнивания структуры:

- Если выравнивание не переопределяется с помощью `__declspec(align(#))`, выравнивание скалярного члена структуры — это его минимальный размер и текущая упаковка.

- Если выравнивание не переопределяется с помощью `__declspec(align(#))`, выравнивание структуры — это максимальное число отдельных выравниваний членов.

- Элемент структуры помещается со смещением от начала его родительской структуры, которая является наименьшей, кратным значению смещения конца предыдущего элемента.

- Размер структуры — это наименьшее число, кратное ее выравниванию, больше или равное смещению в конце его последнего члена.

`__declspec(align(#))` может только увеличить ограничения выравнивания.

Дополнительные сведения см. в разделе:

- [`align`Примеров](#vclrfalignexamples)

- [Определение новых типов с помощью`__declspec(align(#))`](#vclrf_declspecaligntypedef)

- [Выравнивание данных в локальном хранилище потока](#vclrfthreadlocalstorageallocation)

- [Принцип `align` работы с упаковкой данных](#vclrfhowalignworkswithdatapacking)

- [Примеры выравнивания структуры](../build/x64-software-conventions.md#examples-of-structure-alignment) (только для x64)

## <a name="align-examples"></a><a name="vclrfalignexamples"></a>Примеры выровняйте

В следующих примерах показано, как `__declspec(align(#))` влияет на размер и выравнивание структур данных. В примерах допускаются следующие определения.

```cpp
#define CACHE_LINE  32
#define CACHE_ALIGN __declspec(align(CACHE_LINE))
```

В этом примере структура `S1` определена с помощью `__declspec(align(32))`. Все случаи использования `S1` для определения переменных или в объявлениях других типов выравниваются по 32 байтам. `sizeof(struct S1)` возвращает значение 32, а `S1` имеет 16 байтов заполнения после 16 байтов, необходимых для удержания четырех целых чисел. Каждый **`int`** элемент требует 4-байтового выравнивания, но выравнивание самой структуры объявляется как 32. Затем общее выравнивание составляет 32.

```cpp
struct CACHE_ALIGN S1 { // cache align all instances of S1
   int a, b, c, d;
};
struct S1 s1;   // s1 is 32-byte cache aligned
```

В этом примере `sizeof(struct S2)` возвращает 16. Это сумма размеров членов, поскольку это число является кратным наибольшему требуемому выравниванию (кратное 8).

```cpp
__declspec(align(8)) struct S2 {
   int a, b, c, d;
};
```

В следующем примере `sizeof(struct S3)` возвращает 64.

```cpp
struct S3 {
   struct S1 s1;   // S3 inherits cache alignment requirement
                  // from S1 declaration
   int a;         // a is now cache aligned because of s1
                  // 28 bytes of trailing padding
};
```

Обратите внимание, что в этом примере `a` выравнивается по своему естественному типу, то есть, в данном случае, по 4 байтам. Однако значение `S1` должно быть выровнено по 32-байтовой границе. Далее следует 28 байтов заполнения `a` , чтобы оно `s1` начиналось со смещения 32. `S4`затем наследует требование выравнивания `S1` , поскольку оно является самым большим требованием к выравниванию в структуре. `sizeof(struct S4)` возвращает 64.

```cpp
struct S4 {
   int a;
   // 28 bytes padding
   struct S1 s1;      // S4 inherits cache alignment requirement of S1
};
```

Следующие три объявления переменных также используют `__declspec(align(#))`. В каждом случае переменная должна быть выровнена по 32 байтам. В массиве базовый адрес массива, а не каждый элемент массива составляет 32 байт. **`sizeof`** Значение для каждого элемента массива не изменяется при использовании `__declspec(align(#))` .

```cpp
CACHE_ALIGN int i;
CACHE_ALIGN int array[128];
CACHE_ALIGN struct s2 s;
```

Для выравнивания каждого члена массива нужно использовать следующий код:

```cpp
typedef CACHE_ALIGN struct { int a; } S5;
S5 array[10];
```

Обратите внимание, что в этом примере выравнивание самой структуры и первого элемента работают одинаково:

```cpp
CACHE_ALIGN struct S6 {
   int a;
   int b;
};

struct S7 {
   CACHE_ALIGN int a;
               int b;
};
```

`S6` и `S7` имеют одинаковые характеристики выравнивания, выделения и размера.

В этом примере выравнивание начальных адресов a, b, c и d — соответственно 4, 1, 4, и 1.

```cpp
void fn() {
   int a;
   char b;
   long c;
   char d[10]
}
```

Выравнивание при выделении памяти в куче зависит от того, какая функция выделения вызвана.  Например, если используется `malloc`, результат зависит от размера операнда. Если *аргумент arg* >= 8, возвращается память размером 8 байт. Если *аргумент arg* < 8, то при выравнивании возвращаемой памяти первая степень числа 2 меньше *аргумента*будет первой. Например, если используется `malloc(7)` , выравнивание составляет 4 байта.

## <a name="defining-new-types-with-__declspecalign"></a><a name="vclrf_declspecaligntypedef"></a>Определение новых типов с помощью`__declspec(align(#))`

Можно определить тип с характеристикой выравнивания.

Например, можно определить **`struct`** с помощью значения выравнивания следующим образом:

```cpp
struct aType {int a; int b;};
typedef __declspec(align(32)) struct aType bType;
```

Теперь `aType` и `bType` имеют одинаковый размер (8 байт), но переменные типа `bType` — 32 байт.

## <a name="aligning-data-in-thread-local-storage"></a><a name="vclrfthreadlocalstorageallocation"></a>Выровняйте данные в локальном хранилище потока

Статическое локальное хранилище потока (TLS), созданное с помощью атрибута `__declspec(thread)` и помещенное в раздел TLS образа, обеспечивает выравнивание так же, как стандартные статические данные. Для создания данных TLS операционная система выделяет память в размере раздела TLS и сохраняет атрибут выравнивания раздела TLS.

В этом примере показаны различные способы помещения выровненных данных в локальное хранилище потока.

```cpp
// put an aligned integer in TLS
__declspec(thread) __declspec(align(32)) int a;

// define an aligned structure and put a variable of the struct type
// into TLS
__declspec(thread) __declspec(align(32)) struct F1 { int a; int b; } a;

// create an aligned structure
struct CACHE_ALIGN S9 {
   int a;
   int b;
};
// put a variable of the structure type into TLS
__declspec(thread) struct S9 a;
```

## <a name="how-align-works-with-data-packing"></a><a name="vclrfhowalignworkswithdatapacking"></a>Принцип `align` работы с упаковкой данных

`/Zp`Параметр компилятора и `pack` директива pragma имеют воздействие на данные упаковки для членов структуры и объединения. В этом примере показано `/Zp` , как и `__declspec(align(#))` совместно работать:

```cpp
struct S {
   char a;
   short b;
   double c;
   CACHE_ALIGN double d;
   char e;
   double f;
};
```

В следующей таблице перечислены смещения каждого элемента в различных `/Zp` значениях (или `#pragma pack` ), показывающие, как эти два взаимодействуют.

|Переменная|/Zp1|/Zp2|/Zp4|/Zp8|
|--------------|-----------|-----------|-----------|-----------|
|a|0|0|0|0|
|b|1|2|2|2|
|с|3|4|4|8|
|d|32|32|32|32|
|Д.|40|40|40|40|
|f|41|42|44|48|
|sizeof(S)|64|64|64|64|

Дополнительные сведения см. в разделе [ `/Zp` (выравнивание членов структуры)](../build/reference/zp-struct-member-alignment.md).

Смещение объекта зависит от смещения предыдущего объекта и от текущего параметра упаковки, если у объекта нет атрибута `__declspec(align(#))`. Если же такой атрибут есть, то выравнивание зависит от смещения предыдущего объекта и от значения `__declspec(align(#))` объекта.

**Завершение блока, относящегося только к системам Майкрософт**

## <a name="see-also"></a>См. также

[`__declspec`](../cpp/declspec.md)<br/>
[Обзор соглашений ABI ARM](../build/overview-of-arm-abi-conventions.md)<br/>
[Программные соглашения для 64-разрядных систем](../build/x64-software-conventions.md)
