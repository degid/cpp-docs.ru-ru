---
title: EXPORTS
ms.date: 09/07/2018
f1_keywords:
- EXPORTS
helpviewer_keywords:
- EXPORTS .def file statement
ms.assetid: dbcd7579-b855-44c4-bd27-931e157657f7
ms.openlocfilehash: 9ede0d3b53c975298dea3d1331bc0fb00ac246b2
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81328257"
---
# <a name="exports"></a>EXPORTS

Начинает раздел, состоящий из одного или нескольких определений экспорта, в которых указываются имена или порядковые номера экспортируемых функций или данных. Каждое определение должно находиться в отдельной строке.

```DEF
EXPORTS
   definition
```

## <a name="remarks"></a>Примечания

Первое *определение* может быть на `EXPORTS` той же строке, что и ключевое слово, или на последующей строке. В файле DEF могут содержаться один или несколько операторов `EXPORTS`.

Синтаксис для *определения* экспорта:

> *входной internal_name*\[__=__ _ordinal_ \[ **NONAME** \[ **PRIVATE***internal_name*|*other_module.exported_name* \[ **\@** \[ \[ **ДАННЫЕ**И ДАННЫЕ

*имя входа* — это функция или переменное имя, которое вы хотите экспортировать. Это обязательный шаг. Если название, которое вы экспортируете, отличается от названия в DLL, укажите название экспорта в DLL, используя *internal_name.* Например, если библиотека DLL экспортирует функцию `func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.

```DEF
EXPORTS
   func2=func1
```

Если имя, которое вы экспортируете, от какого-либо другого модуля, укажите имя экспорта в DLL, используя *other_module.exported_name.* Например, если библиотека DLL экспортирует функцию `other_module.func1` и вы хотите, чтобы она вызывалась как функция `func2`, укажите следующее.

```DEF
EXPORTS
   func2=other_module.func1
```

Если название, которое вы экспортируете, от другого модуля, который экспортируется по ординатору, укажите обыдание экспорта в DLL, используя *other_module.* __#__ *ординатал .* Например, если ваш DLL экспортирует функцию из другого модуля, где она является `func2`ordinal 42, и вы хотите, чтобы абоненты использовали ее как, вы укажете:

```DEF
EXPORTS
   func2=other_module.#42
```

Поскольку компилятор MSVC использует украшение имен для функций СЗ, необходимо либо `extern "C"` использовать украшенное имя *internal_name* или определить экспортированные функции, используя в исходном коде. Компилятор также украшает C [__stdcall](../../cpp/stdcall.md) функции, которые используют\___stdcall вызова конвенции с подчеркиванием\@( ) префикс и суффикс состоит из на знак ( ) следуют количество байтов (в десятичных) в списке аргументов.

Чтобы найти украшенные имена, созданные компилятором, используйте инструмент [DUMPBIN](dumpbin-reference.md) или опцию linker [/MAP.](map-generate-mapfile.md) Декорированные имена зависят от компилятора. Если вы экспортируете декорированные имена в файле DEF, сборка исполняемых файлов, связанных с библиотекой DLL, должна осуществляться с помощью той же версии компилятора. Таким образом обеспечивается совпадение декорированных имен в вызывающем объекте с экспортированными именами в файле DEF.

Можно использовать \@ *ordinal,* чтобы указать, что число, а не имя функции, входит в таблицу экспорта DLL. Многие библиотеки DLL Windows экспортируют порядковые номера для поддержки устаревшего кода. В 16-разрядном коде Windows часто использовались порядковые номера, так как это позволяло уменьшить размер DLL. Мы не рекомендуем экспортировать функции по порядке, если клиенты вашего DLL не нуждаются в нем для устаревшей поддержки. Файл LIB будет содержать сопоставление между порядковым номером и функцией, что позволит использовать имя функции, как обычно в проектах, использующих DLL.

Используя дополнительное ключевое слово **NONAME,** вы можете экспортировать только по ординатору и уменьшить размер таблицы экспорта в полученном DLL. Однако, если вы хотите использовать [GetProcAddress](/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress) на DLL, вы должны знать, что это имя не будет действительным.

Дополнительное ключевое слово **PRIVATE** предотвращает *вхождение* в библиотеку импорта, генерируемое LINK. Оно не влияет на экспорт в образ, также созданный с помощью LINK.

В дополнительном ключевом слове **DATA** указывается, что экспорт — это данные, а не код. Например, переменную с именем `exported_global`, содержащую данные, можно экспортировать так.

```DEF
EXPORTS
   exported_global DATA
```

Существует четыре способа экспорта определения; здесь они перечислены в порядке предпочтительности:

1. Ключевое слово [__declspec (dllexport)](../../cpp/dllexport-dllimport.md) в исходном коде

1. оператор `EXPORTS` в файле DEF;

1. Спецификация [/EXPORT](export-exports-a-function.md) в команде LINK

1. Директива [о комментарии](../../preprocessor/comment-c-cpp.md) в исходном коде, о форме `#pragma comment(linker, "/export: definition ")`. В следующем примере показана директива #pragma `PlainFuncName` комментария перед декларацией `_PlainFuncName@4` функции, где находится неукрашенное имя, и является украшенное название функции:

    ```cpp
    #pragma comment(linker, "/export:PlainFuncName=_PlainFuncName@4")
    BOOL CALLBACK PlainFuncName( Things * lpParams)
    ```

Директива #pragma полезна, если вам нужно экспортировать неукрашенное имя функции, и иметь разный экспорт в зависимости от конфигурации сборки (например, в 32-битных или 64-битных сборках).

Все эти методы можно использовать в одной программе. Когда программа LINK создает программу, содержащую экспорты, она также создает библиотеку импорта (если только при построении не используется файл EXP).

Ниже приведен пример раздела EXPORTS.

```DEF
EXPORTS
   DllCanUnloadNow      @1          PRIVATE
   DllWindowName = WindowName       DATA
   DllGetClassObject    @4 NONAME   PRIVATE
   DllRegisterServer    @7
   DllUnregisterServer
```

Если экспортируется переменная из библиотеки DLL с помощью файла DEF, вам не надо указывать `__declspec(dllexport)` для переменной. Однако в любом файле, использующем библиотеку DLL, вы должны использовать `__declspec(dllimport)` для объявления данных.

## <a name="see-also"></a>См. также раздел

[Правила для операторов определения модуля](rules-for-module-definition-statements.md)
