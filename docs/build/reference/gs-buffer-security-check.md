---
title: Параметр /GS (проверка безопасности буфера)
ms.date: 11/04/2016
f1_keywords:
- VC.Project.VCCLWCECompilerTool.BufferSecurityCheck
- VC.Project.VCCLCompilerTool.BufferSecurityCheck
helpviewer_keywords:
- buffers [C++], buffer overruns
- buffer overruns, compiler /GS switch
- GS compiler option [C++]
- /GS compiler option [C++]
- security check compiler option [C++]
- -GS compiler option [C++]
- buffers [C++], avoiding overruns
ms.assetid: 8d8a5ea1-cd5e-42e1-bc36-66e1cd7e731e
ms.openlocfilehash: 92d296e8079a9ecd8d366c46bbdad8b2ee5dc313
ms.sourcegitcommit: 63784729604aaf526de21f6c6b62813882af930a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/17/2020
ms.locfileid: "79439561"
---
# <a name="gs-buffer-security-check"></a>Параметр /GS (проверка безопасности буфера)

Обнаруживает некоторые переполнения буфера, которые перезапишут обратный адрес функции, адрес обработчика исключений или определенные типы параметров. Переполнение буфера — это метод, используемый хакерами для использования кода, который не обеспечивает ограничения по размеру буфера.

## <a name="syntax"></a>Синтаксис

```
/GS[-]
```

## <a name="remarks"></a>Примечания

Параметр **/GS** включен по умолчанию. Если вы предполагаете, что в вашем приложении нет угрозы безопасности, используйте **/GS-** . Дополнительные сведения о подавлении обнаружения переполнения буфера см. в разделе [сафебуфферс](../../cpp/safebuffers.md).

## <a name="security-checks"></a>Проверки безопасности

В функциях, распознаваемых компилятором как подлежащие проблемам переполнения буфера, компилятор выделяет место в стеке перед возвращаемым адресом. При вводе функции выделенное пространство загружается с помощью *файла cookie безопасности* , который вычисляются один раз при загрузке модуля. При выходе из функции и во время очистки кадра в 64-разрядных операционных системах вызывается вспомогательная функция, чтобы гарантировать, что значение файла cookie остается прежним. Другое значение указывает, что может произойти перезапись стека. Если обнаруживается другое значение, процесс завершается.

## <a name="gs-buffers"></a>Буферы GS

Проверка безопасности переполнения буфера выполняется в *буфере GS*. Буфер GS может быть одним из следующих:

- Массив, размер которого больше 4 байт, имеет более двух элементов и имеет тип элемента, который не является типом указателя.

- Структура данных, размер которой превышает 8 байт и не содержит указателей.

- Буфер, выделенный с помощью функции [_alloca](../../c-runtime-library/reference/alloca.md) .

- Любой класс или структура, содержащая буфер GS.

Например, следующие инструкции объявляют буферы GS.

```cpp
char buffer[20];
int buffer[20];
struct { int a; int b; int c; int d; } myStruct;
struct { int a; char buf[20]; };
```

Однако следующие инструкции не объявляют буферы GS. Первые два объявления содержат элементы типа указателя. Третья и четвертая инструкции объявляют массивы, размер которых слишком мал. Пятый оператор объявляет структуру, размер которой на платформе x86 не превышает 8 байт.

```cpp
char *pBuf[20];
void *pv[20];
char buf[4];
int buf[2];
struct { int a; int b; };
```

## <a name="initialize-the-security-cookie"></a>Инициализация файла cookie безопасности

Параметр компилятора **/GS** требует, чтобы файл cookie безопасности был инициализирован перед выполнением любой функции, использующей файл cookie. Файл cookie безопасности должен быть инициализирован немедленно при входе в EXE-или библиотеку DLL. Это делается автоматически при использовании точек входа VCRuntime по умолчанию: mainCRTStartup, Вмаинкртстартуп, Винмаинкртстартуп, Ввинмаинкртстартуп или _DllMainCRTStartup. При использовании альтернативной точки входа необходимо вручную инициализировать куки-файл безопасности, вызвав [__security_init_cookie](../../c-runtime-library/reference/security-init-cookie.md).

## <a name="what-is-protected"></a>Что защищено

Параметр компилятора **/GS** защищает следующие элементы:

- Обратный адрес вызова функции.

- Адрес обработчика исключений для функции.

- Параметры уязвимой функции.

На всех платформах **/GS** пытается обнаружить переполнения буфера в обратном адресе. Переполнение буфера проще использовать на платформах, таких как x86 и x64, которые используют соглашения о вызовах, хранящие обратный адрес вызова функции в стеке.

На платформе x86, если функция использует обработчик исключений, компилятор вставляет файл cookie безопасности для защиты адреса обработчика исключений. Файл cookie проверяется во время очистки кадра.

**/GS** защищает *уязвимые параметры* , передаваемые в функцию. Уязвимым параметром является указатель, C++ ссылка, структура C (C++ тип POD), которая содержит указатель или буфер GS.

Уязвимый параметр выделяется перед файлами cookie и локальными переменными. Переполнение буфера может перезаписывать эти параметры. И код в функции, использующей эти параметры, может вызвать атаку перед возвратом функции и выполнения проверки безопасности. Чтобы избежать этой опасности, компилятор создает копию уязвимых параметров во время пролога функции и помещает их под областью хранения для всех буферов.

Компилятор не делает копии уязвимых параметров в следующих ситуациях:

- Функции, которые не содержат буфер GS.

- Оптимизации ([Параметры/o](o-options-optimize-code.md)) не включены.

- Функции, имеющие переменный список аргументов (...).

- Функции, помеченные [атрибутом naked](../../cpp/naked-cpp.md).

- Функции, содержащие встроенный код на языке ассемблера в первой инструкции.

- Параметр используется только способами, которые менее вероятно могут быть использованы в случае переполнения буфера.

## <a name="what-is-not-protected"></a>Что не защищено

Параметр компилятора **/GS** не защищает от всех атак безопасности переполнения буфера. Например, если в объекте есть буфер и таблица vtable, переполнение буфера может повредить таблицу vtable.

Даже при использовании **/GS**всегда пытайтесь написать безопасный код без переполнения буфера.

### <a name="to-set-this-compiler-option-in-visual-studio"></a>Установка параметра компилятора в Visual Studio

1. В **Обозреватель решений**щелкните правой кнопкой мыши проект и выберите пункт **свойства**.

   Подробнее см. в статье [Настройка компилятора C++ и свойств сборки в Visual Studio](../working-with-project-properties.md).

1. В диалоговом окне **страницы свойств** щелкните папку **C/C++**  .

1. Перейдите на страницу свойств **Создание кода** .

1. Измените свойство **Проверка безопасности буфера** .

### <a name="to-set-this-compiler-option-programmatically"></a>Установка данного параметра компилятора программным способом

- См. раздел <xref:Microsoft.VisualStudio.VCProjectEngine.VCCLCompilerTool.BufferSecurityCheck%2A>.

## <a name="example"></a>Пример

Этот пример перезапускает буфер. Это приводит к сбою приложения во время выполнения.

```C
// compile with: /c /W1
#include <cstring>
#include <stdlib.h>
#pragma warning(disable : 4996)   // for strcpy use

// Vulnerable function
void vulnerable(const char *str) {
   char buffer[10];
   strcpy(buffer, str); // overrun buffer !!!

   // use a secure CRT function to help prevent buffer overruns
   // truncate string to fit a 10 byte buffer
   // strncpy_s(buffer, _countof(buffer), str, _TRUNCATE);
}

int main() {
   // declare buffer that is bigger than expected
   char large_buffer[] = "This string is longer than 10 characters!!";
   vulnerable(large_buffer);
}
```

## <a name="see-also"></a>См. также раздел

[Параметры компилятора MSVC](compiler-options.md)<br/>
[Синтаксис командной строки компилятора MSVC](compiler-command-line-syntax.md)
