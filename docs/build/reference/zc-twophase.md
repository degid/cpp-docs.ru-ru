---
title: /Zc:twoPhase- (отключение двухэтапного поиска имени)
description: 'Объясняет, как/Zc: twoPhase — отключает поиск по двум фазам имен при указании/permissive-.'
ms.date: 12/03/2019
f1_keywords:
- twoPhase
- /Zc:twoPhase
helpviewer_keywords:
- twoPhase
- disable two-phase name lookup
- /Zc:twoPhase
ms.openlocfilehash: 712503d08221d29a61323946008f2f36a467cb31
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87234332"
---
# <a name="zctwophase--disable-two-phase-name-lookup"></a>/Zc:twoPhase- (отключение двухэтапного поиска имени)

Параметр **/Zc: twoPhase-** в разделе **/permissive-** указывает компилятору использовать исходное, не согласованное поведение компилятора Microsoft C++ для анализа и создания экземпляров шаблонов классов и шаблонов функций.

## <a name="syntax"></a>Синтаксис

> **/Zc: twoPhase —**

## <a name="remarks"></a>Примечания

Visual Studio 2017 версии 15,3 и более поздних версий: в [/permissive-](permissive-standards-conformance.md)компилятор использует двухэтапный поиск по имени шаблона для разрешения имен. Если также указать **/Zc: twoPhase-**, компилятор вернется к предыдущему несоответствующему шаблону класса, а также разрешению и замене имени шаблона функции. Если **/permissive-** не указан, по умолчанию используется несоответствие.

Файлы заголовков Windows SDK в версии 10.0.15063.0 (создатели обновления или RS2) и более ранних версий не работают в режиме соответствия. **/Zc: twoPhase —** требуется для компиляции кода для этих версий пакета SDK при использовании **/permissive-**. Версии Windows SDK, начиная с версии 10.0.15254.0 (обновления или RS3), правильно работают в режиме соответствия. Они не нуждаются в параметре **/Zc: twoPhase-** Option.

Используйте **/Zc: twoPhase —** если в коде требуется правильно компилировать старое поведение. Настоятельно рекомендуем обновить код, чтобы он соответствовал стандарту.

### <a name="compiler-behavior-under-zctwophase-"></a>Поведение компилятора в разделе/Zc: twoPhase-

По умолчанию или в Visual Studio 2017 версии 15,3 и более поздних версиях при указании одновременно **/permissive-** и **/Zc: twoPhase-**, компилятор использует такое поведение:

- Он анализирует только объявление шаблона, заголовок класса и список базовых классов. Тело шаблона записывается в виде потока токенов. Не анализируются тела функций, инициализаторы, аргументы по умолчанию или аргументы, кроме аргументов. Шаблон класса создается на основе типа с предварительным созданием экземпляра для проверки правильности объявлений в шаблоне класса. Рассмотрим этот шаблон класса:

   ```cpp
   template <typename T> class Derived : public Base<T> { ... }
   ```

   Объявление шаблона, `template <typename T>` , заголовок класса `class Derived` и список базовых классов `public Base<T>` анализируются, но тело шаблона записывается как поток маркера.

- При синтаксическом анализе шаблона функции компилятор анализирует только сигнатуру функции. Тело функции не анализируется. Вместо этого он фиксируется как поток маркера.

В результате, если тело шаблона содержит синтаксические ошибки, но шаблон никогда не создается, компилятор не выполняет диагностику ошибок.

Другим результатом этого поведения является разрешение перегрузки. Нестандартное поведение происходит из-за того, что поток токенов расширяется на сайте создания экземпляра. Символы, которые не были видны в объявлении шаблона, могут быть видимыми в момент создания экземпляра. Это означает, что они могут участвовать в разрешении перегрузки. Шаблоны могут изменяться в зависимости от кода, который не был виден в определении шаблона, в противоположность стандарту.

Рассмотрим для примера такой код:

```cpp
// zctwophase.cpp
// To test options, compile by using
// cl /EHsc /nologo /W4 zctwophase.cpp
// cl /EHsc /nologo /W4 /permissive- zctwophase.cpp
// cl /EHsc /nologo /W4 /permissive- /Zc:twoPhase- zctwophase.cpp

#include <cstdio>

void func(long) { std::puts("Standard two-phase") ;}

template<typename T> void g(T x)
{
    func(0);
}

void func(int) { std::puts("Microsoft one-phase"); }

int main()
{
    g(6174);
}
```

Ниже приведены выходные данные при использовании режима по умолчанию, режима соответствия и режима соответствия с параметрами **/Zc: twoPhase-** Compiler:

```cmd
C:\Temp>cl /EHsc /nologo /W4 zctwophase.cpp && zctwophase
zctwophase.cpp
Microsoft one-phase

C:\Temp>cl /EHsc /nologo /W4 /permissive- zctwophase.cpp && zctwophase
zctwophase.cpp
Standard two-phase

C:\Temp>cl /EHsc /nologo /W4 /permissive- /Zc:twoPhase- zctwophase.cpp && zctwophase
zctwophase.cpp
Microsoft one-phase
```

При компиляции в режиме соответствия в разделе **/permissive-** эта программа выводит " `Standard two-phase` ", так как Вторая перегрузка `func` не видна, когда компилятор достигает шаблона. При добавлении **/Zc: twoPhase-** программа выводит " `Microsoft one-phase` ". Выходные данные те же, что и при отсутствии указания **/permissive-**.

*Зависимые имена* — это имена, которые зависят от параметра шаблона. Эти имена имеют поведение поиска, которое также отличается от параметра **/Zc: twoPhase-**. В режиме соответствия зависимые имена не связаны в точке определения шаблона. Вместо этого компилятор просматривает их при создании экземпляра шаблона. Для вызовов функций с именем зависимой функции имя привязывается к функциям, видимым в месте вызова в определении шаблона. Добавляются дополнительные перегрузки из поиска с зависимостью от аргументов, как в точке определения шаблона, так и в момент создания экземпляра шаблона.

Двухэтапный поиск состоит из двух частей: Поиск независимых имен в определении шаблона и поиск зависимых имен во время создания экземпляра шаблона. В разделе **/Zc: twoPhase-** компилятор не выполняет поиск с зависимостью от аргументов отдельно от неквалифицированного уточняющего запроса. То есть он не выполняет двухэтапный поиск, поэтому результаты разрешения перегрузки могут отличаться.

Вот еще один пример:

```cpp
// zctwophase1.cpp
// To test options, compile by using
// cl /EHsc /W4 zctwophase1.cpp
// cl /EHsc /W4 /permissive- zctwophase1.cpp
// cl /EHsc /W4 /permissive- /Zc:twoPhase- zctwophase1.cpp

#include <cstdio>

void func(long) { std::puts("func(long)"); }

template <typename T> void tfunc(T t) {
    func(t);
}

void func(int) { std::puts("func(int)"); }

namespace NS {
    struct S {};
    void func(S) { std::puts("NS::func(NS::S)"); }
}

int main() {
    tfunc(1729);
    NS::S s;
    tfunc(s);
}
```

При компиляции без **/permissive-** этот код выводит:

```Output
func(int)
NS::func(NS::S)
```

При компиляции с помощью **/permissive-**, но без **/Zc: twoPhase-**, этот код выводит:

```Output
func(long)
NS::func(NS::S)
```

При компиляции с **/permissive-** и **/Zc: twoPhase-** этот код выводит:

```Output
func(int)
NS::func(NS::S)
```

В режиме соответствия в разделе **/permissive-** вызов `tfunc(1729)` разрешается в `void func(long)` перегрузку. Он не разрешается в `void func(int)` перегрузку, как в разделе **/Zc: twoPhase-**. Это обусловлено тем, что неполное `func(int)` объявление объявляется после определения шаблона и не найдено при поиске с зависимостью от аргументов. Но `void func(S)` участвует в поиске с зависимостью от аргументов, поэтому он добавляется в перегруженный набор для вызова `tfunc(s)` , даже если он объявлен после функции-шаблона.

### <a name="update-your-code-for-two-phase-conformance"></a>Обновление кода для двухфазной согласованности

Более старые версии компилятора не требуют ключевых слов **`template`** и **`typename`** везде, где они требуются стандарту C++. Эти ключевые слова необходимы в некоторых позициях, чтобы определить, как компиляторы должны анализировать зависимое имя во время первого этапа поиска. Например:

`T::Foo<a || b>(c);`

Согласованный компилятор анализирует `Foo` как переменную в области `T` , что означает, что этот код является логическим выражением или с помощью левого операнда `T::foo < a` и `b > (c)` правого операнда. Если предполагается использовать в `Foo` качестве шаблона функции, необходимо указать, что это шаблон, добавив **`template`** ключевое слово:

`T::template Foo<a || b>(c);`

В версиях Visual Studio 2017 версии 15,3 и более поздних, когда указаны **/permissive-** и **/Zc: twoPhase-** , компилятор разрешает этот код без **`template`** ключевого слова. Он интерпретирует код как вызов шаблона функции с аргументом `a || b` , так как он только анализирует шаблоны в ограниченном режиме. Приведенный выше код не анализируется на первом этапе. На втором этапе достаточно контекста, чтобы сообщить, что `T::Foo` является шаблоном, а не переменной, поэтому компилятор не применяет использование ключевого слова.

Это поведение также можно увидеть, удалив ключевое слово **`typename`** перед именами в теле шаблона функции, инициализаторах, аргументах по умолчанию и аргументах, кроме аргументов. Например:

```cpp
template<typename T>
typename T::TYPE func(typename T::TYPE*)
{
    /* typename */ T::TYPE i;
}
```

Если в теле функции не используется ключевое слово **`typename`** , этот код компилируется в разделе **/permissive-/Zc: twoPhase-**, но не только в **/permissive-** . **`typename`** Ключевое слово требуется, чтобы указать, что `TYPE` зависимым является. Так как текст не анализируется в разделе **/Zc: twoPhase-**, компилятору не требуется ключевое слово. В режиме соответствия **/permissive-** код без **`typename`** ключевого слова создает ошибки. Чтобы перенести код в соответствие в Visual Studio 2017 версии 15,3 и более поздних версий, вставьте **`typename`** ключевое слово там, где оно отсутствует.

Аналогичным образом рассмотрим следующий пример кода:

```cpp
template<typename T>
typename T::template X<T>::TYPE func(typename T::TYPE)
{
    typename T::/* template */ X<T>::TYPE i;
}
```

В разделе **/Permissive-/Zc: twoPhase-** and в более ранних компиляторах для компилятора требуется только **`template`** ключевое слово в строке 2. В режиме соответствия компилятору теперь требуется **`template`** ключевое слово в строке 4 для указания того, что `T::X<T>` является шаблоном. Найдите код, в котором отсутствует ключевое слово, и укажите его, чтобы сделать код соответствующим стандарту.

Дополнительные сведения о проблемах соответствия см. [в разделе улучшения соответствия C++ в Visual Studio](../../overview/cpp-conformance-improvements.md) и [нестандартное поведение](../../cpp/nonstandard-behavior.md).

### <a name="to-set-this-compiler-option-in-the-visual-studio-development-environment"></a>Установка данного параметра компилятора в среде разработки Visual Studio

1. Откройте диалоговое окно **Страницы свойств** проекта. Подробнее см. в статье [Настройка компилятора C++ и свойства сборки в Visual Studio](../working-with-project-properties.md).

1. Выберите страницу свойств **Свойства конфигурации**  >  **C/C++**  >  **Командная строка** .

1. Измените свойство **Дополнительные параметры** , включив параметр **/Zc: twoPhase-** и нажмите кнопку **ОК**.

## <a name="see-also"></a>См. также статью

[/Zc (соответствие)](zc-conformance.md)
