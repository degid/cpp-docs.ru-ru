---
title: Поддержка открытых папок для систем сборки C++ в Visual Studio
ms.date: 12/02/2019
helpviewer_keywords:
- Open Folder Projects in Visual Studio
ms.assetid: abd1985e-3717-4338-9e80-869db5435175
ms.openlocfilehash: 9d9f59817a499f4d529363c88adc57154268c0bc
ms.sourcegitcommit: 6280a4c629de0f638ebc2edd446de2a9b11f0406
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/12/2020
ms.locfileid: "90039590"
---
# <a name="open-folder-support-for-c-build-systems-in-visual-studio"></a>Поддержка открытых папок для систем сборки C++ в Visual Studio

::: moniker range="vs-2015"

Функция "Открыть папку" доступна в Visual Studio 2017 и более поздних версиях.

::: moniker-end

::: moniker range=">=vs-2017"

В Visual Studio 2017 и более поздних версиях появилась функция "Открыть папку", позволяющая открыть папку исходных файлов и немедленно приступить к написанию кода с поддержкой IntelliSense, просмотра, рефакторинга, отладки и т. п. Когда вы изменяете, создаете и удаляете файлы, Visual Studio автоматически отслеживает эти изменения и постоянно обновляет индекс IntelliSense. Никакие файлы SLN или VCXPROJ не загружаются. При необходимости вы можете указать настраиваемые задачи и параметры запуска, используя простые файлы JSON. Эта функция позволяет интегрировать любую систему сборки сторонних разработчиков в Visual Studio. Общие сведения о проекте "Открыть папку" см. в статье [Разработка кода в Visual Studio без использования проектов и решений](/visualstudio/ide/develop-code-in-visual-studio-without-projects-or-solutions).

## <a name="cmake-and-qt"></a>CMake и Qt

Средство CMake интегрировано в интегрированную среду разработки Visual Studio как компонент рабочей нагрузки C++ для настольных ПК. Рабочий процесс для CMake отличается от рабочего процесса, описанного в этой статье. Если вы используете CMake, обратитесь к статье [Проекты CMake в Visual Studio](cmake-projects-in-visual-studio.md). Вы также можете использовать CMake для создания проектов Qt, либо использовать [расширение Qt Visual Studio](https://download.qt.io/development_releases/vsaddin/) для Visual Studio 2015 или Visual Studio 2017.

## <a name="other-build-systems"></a>Другие системы сборки

Чтобы использовать интегрированную среду разработки Visual Studio с системой сборки или набором инструментов компилятора, которые не поддерживаются напрямую из главного меню, выберите **Файл | Открыть | Папка** или нажмите **CTRL + SHIFT + ALT + O**. Перейдите к папке, содержащей файлы исходного кода. Чтобы выполнить сборку проекта, настроить IntelliSense и задать параметры отладки, добавьте три файла JSON:

| Файл | Описание |
|-|-|
|CppProperties.json|Указывает сведения о настраиваемой конфигурации для просмотра. При необходимости вы можете создать этот файл в корневой папке проекта. (Не используется в проектах CMake.)|
|tasks.vs.json|Определение настраиваемых команд сборки Доступ к файлу можно получить в **обозревателе решений**, воспользовавшись пунктом контекстного меню **Настройка задач**.|
|launch.vs.json|Задает аргументы командной строки для отладчика. Доступ к файлу можно получить в **обозревателе решений**, воспользовавшись пунктом контекстного меню **Параметры отладки и запуска**.|

## <a name="configure-code-navigation-with-cpppropertiesjson"></a>Настройка навигации по коду с помощью CppProperties.json

Для правильной работы обзора и функций IntelliSense, таких как **Перейти к определению**, Visual Studio необходимо определить, какой компилятор используется, где находятся заголовки системы и где находятся дополнительные включаемые файлы, если они не находятся непосредственно в открытой папке (папка рабочей области). Чтобы указать конфигурацию, можно выбрать **Управление конфигурациями** из раскрывающегося списка на главной панели инструментов:

![Раскрывающийся список "Управление конфигурациями"](media/manage-configurations-dropdown.png)

Visual Studio предлагает следующие конфигурации по умолчанию:

![Конфигурации по умолчанию](media/default-configurations.png)

Например, если выбрать **x64-Debug**, Visual Studio создаст файл с именем *CppProperties.json* в корневой папке проекта:

```json
{
  "configurations": [
    {
      "inheritEnvironments": [
        "msvc_x64"
      ],
      "name": "x64-Debug",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "defines": [
        "WIN32",
        "_DEBUG",
        "UNICODE",
        "_UNICODE"
      ],
      "intelliSenseMode": "windows-msvc-x64"
    }
  ]
}
```

Эта конфигурация наследует переменные среды Visual Studio [Командная строка разработчика x64](building-on-the-command-line.md). Одной из этих переменных является `INCLUDE`, и вы можете ссылаться на нее с помощью макроса `${env.INCLUDE}`. Свойство `includePath` сообщает Visual Studio, где искать все источники, необходимые для IntelliSense. В этом случае появляется сообщение "Поиск во всех каталогах, указанных переменной среды INCLUDE, а также во всех каталогах в дереве текущей рабочей папки". Свойство `name` — это имя, которое будет отображаться в раскрывающемся списке. Оно может быть любым. Свойство `defines` предоставляет подсказки для IntelliSense при обнаружении блоков условной компиляции. Свойство `intelliSenseMode` предоставляет некоторые дополнительные указания на основе типа компилятора. Для компиляторов MSVC, GCC и Clang доступны несколько параметров.

> [!NOTE]
> Если Visual Studio пропускает параметры в файле *CppProperties.json*, попробуйте добавить исключение в файл *GITIGNORE* следующим образом: `!/CppProperties.json`.

## <a name="default-configuration-for-mingw-w64"></a>Конфигурация по умолчанию для MinGW-w64

Если добавить конфигурацию MinGW-W64, JSON будет выглядеть следующим образом:

```json
{
  {
      "inheritEnvironments": [
        "mingw_64"
      ],
      "name": "Mingw64",
      "includePath": [
        "${env.INCLUDE}",
        "${workspaceRoot}\\**"
      ],
      "intelliSenseMode": "linux-gcc-x64",
      "environments": [
        {
          "MINGW64_ROOT": "C:\\msys64\\mingw64",
          "BIN_ROOT": "${env.MINGW64_ROOT}\\bin",
          "FLAVOR": "x86_64-w64-mingw32",
          "TOOLSET_VERSION": "9.1.0",
          "PATH": "${env.BIN_ROOT};${env.MINGW64_ROOT}\\..\\usr\\local\\bin;${env.MINGW64_ROOT}\\..\\usr\\bin;${env.MINGW64_ROOT}\\..\\bin;${env.PATH}",
          "INCLUDE": "${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION};${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION}\\tr1;${env.MINGW64_ROOT}\\include\\c++\\${env.TOOLSET_VERSION}\\${env.FLAVOR}",
          "environment": "mingw_64"
        }
      ]
    }
}
```

Обратите внимание на блок `environments`. Он определяет свойства, которые ведут себя как переменные среды и доступны не только в файле *CppProperties.json*, но также и в других файлах конфигурации *task.vs.json* и *launch.vs.json*. Конфигурация `Mingw64` наследует среду `mingw_w64` и использует ее свойство `INCLUDE`, чтобы указать значение для `includePath`. При необходимости можно добавить другие пути к этому свойству массива.

Свойству `intelliSenseMode` присвоено значение, подходящее для GCC. Дополнительные сведения обо всех этих свойствах см. в разделе [Справочник по схеме CppProperties](cppproperties-schema-reference.md).

Когда все работает правильно, вы увидите IntelliSense из заголовков GCC при наведении указателя мыши на тип:

![IntelliSense GCC](media/gcc-intellisense.png)

## <a name="enable-intellisense-diagnostics"></a>Включение диагностики IntelliSense

Если вы не видите IntelliSense, как ожидалось, проблему можно устранить, выбрав **Сервис** > **Параметры** > **Текстовый редактор** > **C/C++**  > **Дополнительно** и установив для параметра **Включить ведение журнала** значение **`true`** . Для начала задайте для параметра **Уровень ведения журнала** значение 5, а для параметра **Фильтры ведения журнала** — значение 8.

![Ведение журналов диагностики](media/diagnostic-logging.png)

Выходные данные направляются в **окно вывода** и отображаются при выборе **Показать выходные данные из: журнал Visual C++* . Выходные данные содержат, помимо прочего, список фактических путей включения, которые IntelliSense пытается использовать. Если пути не совпадают с путями в *CppProperties.json*, закройте папку и удалите вложенную папку *.vs*, которая содержит кэшированные данные обзора.

### <a name="define-build-tasks-with-tasksvsjson"></a>Определение задач сборки в файле tasks.vs.json

Вы можете автоматизировать скрипты сборки и любые внешние операции с файлами, размещенными в текущей рабочей области, запуская их как задачи в интегрированной среде разработки. Чтобы настроить новую задачу, щелкните правой кнопкой мыши нужный файл или папку и выберите **Настройка задач**.

![Настройка задач "Открыть папку"](media/configure-tasks.png)

Создает (или открывает) файл *tasks.vs.json* в папке .vs, которую Visual Studio создает в корневой папке проекта. Можно определить в этом файле любую произвольную задачу, а затем вызывать ее из контекстного меню **обозревателя решений**. Чтобы продолжить пример с GCC, в следующем фрагменте кода показан полный файл *tasks.vs.json* с одной задачей, которая вызывает *g++.exe* для сборки проекта. Предположим, что проект содержит один файл с именем *hello.cpp*.

```json
{
  "version": "0.2.1",
  "tasks": [
    {
      "taskLabel": "build hello",
      "appliesTo": "/",
      "type": "default",
      "command": "g++",
      "args": [
        "-g",
        "-o",
        "hello",
        "hello.cpp"
      ]
    }
  ]
}

```

Файл JSON помещается в подпапку *.vs*. Чтобы просмотреть эту папку, нажмите кнопку **Показать все файлы** в верхней части **обозревателя решений**. Эту задачу можно выполнить, щелкнув правой кнопкой мыши корневой узел в **обозревателе решений** и выбрав **build hello**. После завершения задачи вы увидите новый файл *hello.exe* в **обозревателе решений**.

Можно определить множество типов задач. Ниже представлен пример файла *tasks.vs.json*, который определяет одну задачу. `taskLabel` определяет имя, отображаемое в контекстном меню. `appliesTo` определяет, для каких файлов можно выполнить эту команду. Свойство `command` ссылается на переменную среды COMSPEC, которая определяет путь для консоли (*cmd.exe* в Windows). Вы также можете ссылаться на переменные среды, объявленные в CppProperties.json или CMakeSettings.json. Свойство `args` определяет вызываемую командную строку. Макрос `${file}` передает выбранный файл в **обозреватель решений**. Приведенный ниже пример отображает имя для выбранного в этот момент CPP-файла.

```json
{
  "version": "0.2.1",
  "tasks": [
    {
      "taskLabel": "Echo filename",
      "appliesTo": "*.cpp",
      "type": "command",
      "command": "${env.COMSPEC}",
      "args": ["echo ${file}"]
    }
  ]
}
```

Сохранив *tasks.vs.json*, можно щелкнуть любой *CPP-файл* в папке, выбрать пункт **Echo filename** (Вывести имя файла) в контекстном меню и просмотреть имя файла в окне вывода.

Дополнительные сведения см. в разделе [Справочник по схеме Tasks.vs.json](tasks-vs-json-schema-reference-cpp.md).

### <a name="configure-debugging-parameters-with-launchvsjson"></a>Настройка параметров отладки с помощью launch.vs.json

Чтобы настроить аргументы командной строки и инструкции отладки для своей программы, щелкните правой кнопкой мыши исполняемый файл в **обозревателе решений** и выберите **Параметры отладки и запуска**. Откроется существующий файл *launch.vs.json* или, если он не существует, будет создан новый файл с набором минимальных параметров запуска. Сначала вам нужно выбрать тип сеанса отладки, который необходимо настроить. Для отладки проекта MinGw-W64 мы выбираем **Запуск C/C++ для MinGW/Cygwin (gdb)** . При этом создается конфигурация запуска для использования *gdb.exe* с некоторыми обученными предположениями о значениях по умолчанию. Одно из этих значений по умолчанию — `MINGW_PREFIX`. Вы можете заменить литеральный путь (как показано ниже) или определить свойство `MINGW_PREFIX` в *CppProperties.json*:

```json
{
  "version": "0.2.1",
  "defaults": {},
  "configurations": [
    {
      "type": "cppdbg",
      "name": "hello.exe",
      "project": "hello.exe",
      "cwd": "${workspaceRoot}",
      "program": "${debugInfo.target}",
      "MIMode": "gdb",
      "miDebuggerPath": "c:\\msys64\\usr\\bin\\gdb.exe",
      "externalConsole": true
    }
  ]
}

```

Чтобы начать отладку, выберите исполняемый файл в раскрывающемся списке "Отладка", а затем щелкните зеленую стрелку:

![Отладчик запуска](media/launch-debugger-gdb.png)

Должно отобразиться диалоговое окно **Инициализация отладчика**, а затем внешнее окно консоли, в котором выполняется программа.

Дополнительные сведения см. в разделе [Справочник по схеме Launch.vs.json](launch-vs-schema-reference-cpp.md).

## <a name="launching-other-executables"></a>Запуск других исполняемых файлов

Можно определить параметры запуска для любого исполняемого файла на компьютере. В следующем примере запускается *7za* и указываются дополнительные аргументы путем их добавления в массив JSON `args`:

```json
{
  "version": "0.2.1",
  "defaults": {},
  "configurations": [
    {
      "type": "default",
      "project": "CPP\\7zip\\Bundles\\Alone\\O\\7za.exe",
      "name": "7za.exe list content of helloworld.zip",
      "args": [ "l", "d:\\sources\\helloworld.zip" ]
    }
  ]
}
```

Когда вы сохраняете этот файл, новая конфигурация отображается в раскрывающемся списке "Цель отладки". Вы можете выбрать ее, чтобы запустить отладчик. Можно создать любое количество конфигураций отладки для любого количества исполняемых файлов. Нажатие клавиши **F5** запускает отладчик, который будет останавливаться на всех заданных точках останова. Все обычные окна отладчика и их функции теперь доступны.

::: moniker-end
