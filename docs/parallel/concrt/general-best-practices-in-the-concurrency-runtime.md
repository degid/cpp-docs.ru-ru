---
title: Общие рекомендации в среде выполнения с параллелизмом
ms.date: 11/04/2016
helpviewer_keywords:
- Concurrency Runtime, general best practices
ms.assetid: ce5c784c-051e-44a6-be84-8b3e1139c18b
ms.openlocfilehash: 77ca8acbd3dedc28aaa6c330c3e91ed09046d162
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87228457"
---
# <a name="general-best-practices-in-the-concurrency-runtime"></a>Общие рекомендации в среде выполнения с параллелизмом

В этом документе описываются рекомендации, применяемые к нескольким областям среда выполнения с параллелизмом.

## <a name="sections"></a><a name="top"></a>Священ

Этот документ содержит следующие разделы.

- [Использовать конструкции совместной синхронизации по возможности](#synchronization)

- [Избегайте длительных задач, которые не дают](#yield)

- [Использование превышения лимита подписки для сдвига операций, которые блокируют или имеют высокую задержку](#oversubscription)

- [Используйте функции параллельного управления памятью, когда это возможно](#memory)

- [Используйте RAII для управления временем существования объектов параллелизма](#raii)

- [Не создавать объекты параллелизма в глобальной области](#global-scope)

- [Не используйте объекты параллелизма в общих сегментах данных](#shared-data)

## <a name="use-cooperative-synchronization-constructs-when-possible"></a><a name="synchronization"></a>Использовать конструкции совместной синхронизации по возможности

Среда выполнения с параллелизмом предоставляет множество одновременных конструкций, не требующих внешнего объекта синхронизации. Например, класс [concurrency::concurrent_vector](../../parallel/concrt/reference/concurrent-vector-class.md) предоставляет одновременные операции добавления и доступа к элементам. В данном случае, безопасность с параллелизмом означает, что указатели или итераторы всегда действительны. Не гарантируется инициализация элементов или определенный порядок обхода. Однако в случаях, когда требуется эксклюзивный доступ к ресурсу, среда выполнения предоставляет классы [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md), [concurrency::reader_writer_lock](../../parallel/concrt/reference/reader-writer-lock-class.md)и [concurrency::Event](../../parallel/concrt/reference/event-class.md) . Эти типы работают совместно. Таким образом, планировщик заданий может перераспределить ресурсы обработки в другой контекст, так как первая задача ожидает данные. По возможности используйте эти типы синхронизации вместо других механизмов синхронизации, например, предоставляемых Windows API, которые не работают совместно. Дополнительные сведения об этих типах синхронизации и пример кода см. в разделе [структуры данных синхронизации](../../parallel/concrt/synchronization-data-structures.md) и [Сравнение структур данных синхронизации с API Windows](../../parallel/concrt/comparing-synchronization-data-structures-to-the-windows-api.md).

[[Top](#top)]

## <a name="avoid-lengthy-tasks-that-do-not-yield"></a><a name="yield"></a>Избегайте длительных задач, которые не дают

Поскольку планировщик заданий работает совместно, он не обеспечивает равноправие между задачами. Таким образом, задача может препятствовать запуску других задач. Хотя это приемлемо в некоторых случаях, в других случаях это может вызвать взаимоблокировку или нехватку ресурсов.

В следующем примере выполняется больше задач, чем количество выделенных вычислительных ресурсов. Первая задача не передается планировщику задач, поэтому вторая задача не запускается до тех пор, пока не завершится первая задача.

[!code-cpp[concrt-cooperative-tasks#1](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_1.cpp)]

В этом примере выводятся следующие данные:

1: 250000000 1: 500000000 1: 750000000 1: 1000000000 2: 250000000 2: 500000000 2: 750000000 2: 1000000000

Существует несколько способов обеспечить совместную работу двух задач. Один из способов — время от времени можно получить планировщик заданий в долгосрочной задаче. В следующем примере `task` функция вызывает метод [concurrency::Context:: Yield](reference/context-class.md#yield) для получения выполнения планировщику заданий, чтобы можно было запустить другую задачу.

[!code-cpp[concrt-cooperative-tasks#2](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_2.cpp)]

В этом примере выводятся следующие данные:

```Output
1: 250000000
2: 250000000
1: 500000000
2: 500000000
1: 750000000
2: 750000000
1: 1000000000
2: 1000000000
```

`Context::Yield`Метод возвращает только другой активный поток в планировщике, к которому относится текущий поток, упрощенная задача или другой поток операционной системы. Этот метод не является результатом работы, запланированной для выполнения в объекте [concurrency::task_group](reference/task-group-class.md) или [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) , но еще не запущен.

Существуют и другие способы обеспечения взаимодействия между долго выполняющимися задачами. Можно разбить большую задачу на более мелкие подзадачи. Можно также включить превышение лимита подписки во время длительной задачи. Превышение лимита подписки позволяет создать больше потоков, чем количество доступных аппаратных потоков. Превышение лимита подписки особенно полезно, если длительная задача содержит большое количество задержек, например чтение данных с диска или подключение к сети. Дополнительные сведения о упрощенных задачах и превышении лимита подписки см. в разделе [планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).

[[Top](#top)]

## <a name="use-oversubscription-to-offset-operations-that-block-or-have-high-latency"></a><a name="oversubscription"></a>Использование превышения лимита подписки для сдвига операций, которые блокируют или имеют высокую задержку

Среда выполнения с параллелизмом предоставляет примитивы синхронизации, такие как [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md), которые позволяют задачам совместно блокироваться и возвращать друг другу. Когда одна задача совместно блокирует или выдает, планировщик задач может перераспределить ресурсы обработки в другой контекст, так как первая задача ожидает данные.

В некоторых случаях нельзя использовать механизм совместной блокировки, предоставляемый среда выполнения с параллелизмом. Например, используемая внешняя библиотека может использовать другой механизм синхронизации. Другой пример — при выполнении операции, которая может иметь большой объем задержки, например при использовании функции Windows API `ReadFile` для считывания данных из сетевого подключения. В таких случаях превышение лимита подписки может обеспечить выполнение других задач, когда другая задача бездействует. Превышение лимита подписки позволяет создать больше потоков, чем количество доступных аппаратных потоков.

Рассмотрим следующую функцию, `download` которая скачивает файл по указанному URL-адресу. В этом примере используется метод [concurrency::Context:: resubscribe](reference/context-class.md#oversubscribe) для временного увеличения числа активных потоков.

[!code-cpp[concrt-download-oversubscription#4](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_3.cpp)]

Так как `GetHttpFile` функция выполняет потенциально скрытую операцию, превышение лимита подписки может обеспечить выполнение других задач, так как текущая задача ожидает данные. Полную версию этого примера см. в разделе [как использовать превышение лимита подписки для смещения задержки](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).

[[Top](#top)]

## <a name="use-concurrent-memory-management-functions-when-possible"></a><a name="memory"></a>Используйте функции параллельного управления памятью, когда это возможно

Используйте функции управления памятью [concurrency::Alloc](reference/concurrency-namespace-functions.md#alloc) и [concurrency::Free](reference/concurrency-namespace-functions.md#free), если у вас есть детализированные задачи, которые часто распределяют небольшие объекты с относительно коротким временем существования. Среда выполнения с параллелизмом содержит отдельный кэш памяти для каждого выполняющегося потока. `Alloc`Функции и `Free` выделяют и освобождают память из этих кэшей без использования блокировок или барьеров памяти.

Дополнительные сведения об этих функциях управления памятью см. в разделе [планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md). Пример использования этих функций см. в разделе [как использовать Alloc и Free для повышения производительности памяти](../../parallel/concrt/how-to-use-alloc-and-free-to-improve-memory-performance.md).

[[Top](#top)]

## <a name="use-raii-to-manage-the-lifetime-of-concurrency-objects"></a><a name="raii"></a>Используйте RAII для управления временем существования объектов параллелизма

Среда выполнения с параллелизмом использует обработку исключений для реализации таких функций, как отмена. Поэтому при вызове среды выполнения или вызове другой библиотеки, которая вызывается в среде выполнения, следует писать код, защищенный с помощью исключений.

Шаблон " *получение ресурсов" — Инициализация* (RAII) — это один из способов безопасного управления жизненным циклом объекта параллелизма в заданной области. В шаблоне RAII структура данных выделяется в стеке. Эта структура данных Инициализирует или получает ресурс при его создании, а также уничтожает или освобождает этот ресурс при уничтожении структуры данных. Шаблон RAII гарантирует, что деструктор вызывается до выхода из охватывающей области. Этот шаблон полезен, если функция содержит несколько **`return`** инструкций. Этот шаблон также помогает написать код, защищенный с помощью исключений. Если **`throw`** инструкция вызывает очистку стека, вызывается деструктор для объекта RAII, поэтому ресурс всегда будет правильно удален или освобожден.

Среда выполнения определяет несколько классов, использующих шаблон RAII, например [concurrency::critical_section:: scoped_lock](../../parallel/concrt/reference/critical-section-class.md#critical_section__scoped_lock_class) и [concurrency::reader_writer_lock:: scoped_lock](reference/reader-writer-lock-class.md#scoped_lock_class). Эти вспомогательные классы известны как *блокировки с областью действия*. Эти классы предоставляют несколько преимуществ при работе с объектами [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md) или [concurrency::reader_writer_lock](../../parallel/concrt/reference/reader-writer-lock-class.md) . Конструктор этих классов получает доступ к предоставленному `critical_section` `reader_writer_lock` объекту или. Деструктор освобождает доступ к этому объекту. Так как блокировка с областью освобождает доступ к объекту взаимного исключения автоматически при его уничтожении, базовый объект не разблокируется вручную.

Рассмотрим следующий класс, `account` который определяется внешней библиотекой и поэтому не может быть изменен.

[!code-cpp[concrt-account-transactions#1](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_4.h)]

В следующем примере несколько транзакций для объекта выполняется `account` параллельно. В примере объект используется `critical_section` для синхронизации доступа к объекту, `account` так как `account` класс не является типобезопасным. Каждая параллельная операция использует `critical_section::scoped_lock` объект, чтобы гарантировать, что `critical_section` объект разблокируется при успешном или неудачном выполнении операции. Если баланс учетной записи отрицательный, `withdraw` операция завершается ошибкой, вызывая исключение.

[!code-cpp[concrt-account-transactions#2](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_5.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
Balance before deposit: 1924
Balance after deposit: 2924
Balance before withdrawal: 2924
Balance after withdrawal: -76
Balance before withdrawal: -76
Error details:
    negative balance: -76
```

Дополнительные примеры использования шаблона RAII для управления временем существования объектов параллелизма см. в разделе [Пошаговое руководство. Удаление работы из потока пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md), [Практическое руководство. Использование класса Context для реализации параллельного семафора](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md)и [Практическое руководство. Использование превышения лимита подписки для смещения задержки](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md).

[[Top](#top)]

## <a name="do-not-create-concurrency-objects-at-global-scope"></a><a name="global-scope"></a>Не создавать объекты параллелизма в глобальной области

При создании объекта параллелизма в глобальной области в приложении могут возникнуть такие проблемы, как взаимоблокировка или нарушение прав доступа к памяти.

Например, при создании объекта исполняющей среды с параллелизмом среда создает планировщик по умолчанию, если он еще не создан. Объект среды выполнения, созданный при конструировании глобального объекта, соответственно вызовет то, что среда выполнения создаст этот планировщик по умолчанию. Однако этот процесс принимает внутреннюю блокировку, которая может помешать инициализации других объектов, поддерживающих инфраструктуру исполняющей среды с параллелизмом. Эта внутренняя блокировка может потребоваться другому, еще не инициализированному, объекту инфраструктуры, и поэтому может привести к возникновению взаимоблокировки в приложении.

В следующем примере демонстрируется создание глобального объекта [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md) . Эта схема применяется не только к классу `Scheduler`, но и ко всем остальным типам, предоставленным исполняющей средой с параллелизмом. Рекомендуется не использовать эту схему, поскольку она может привести к неожиданному поведению в приложении.

[!code-cpp[concrt-global-scheduler#1](../../parallel/concrt/codesnippet/cpp/general-best-practices-in-the-concurrency-runtime_6.cpp)]

Примеры правильного способа создания `Scheduler` объектов см. в разделе [планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).

[[Top](#top)]

## <a name="do-not-use-concurrency-objects-in-shared-data-segments"></a><a name="shared-data"></a>Не используйте объекты параллелизма в общих сегментах данных

Среда выполнения с параллелизмом не поддерживает использование объектов параллелизма в разделе общих данных, например раздел данных, созданный [data_seg](../../preprocessor/data-seg.md) `#pragma` директивой data_seg. Объект параллелизма, совместно используемый в границах процесса, может перевести среду выполнения в несогласованное или недопустимое состояние.

[[Top](#top)]

## <a name="see-also"></a>См. также статью

[Рекомендации по среда выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-best-practices.md)<br/>
[Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)<br/>
[библиотеку асинхронных агентов](../../parallel/concrt/asynchronous-agents-library.md)<br/>
[планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md)<br/>
[Структуры данных синхронизации](../../parallel/concrt/synchronization-data-structures.md)<br/>
[Сравнение структур данных синхронизации с API Windows](../../parallel/concrt/comparing-synchronization-data-structures-to-the-windows-api.md)<br/>
[Как использовать Alloc и Free для повышения производительности памяти](../../parallel/concrt/how-to-use-alloc-and-free-to-improve-memory-performance.md)<br/>
[Как использовать превышение лимита подписки для смещения задержки](../../parallel/concrt/how-to-use-oversubscription-to-offset-latency.md)<br/>
[Как использовать класс контекста для реализации параллельного семафора](../../parallel/concrt/how-to-use-the-context-class-to-implement-a-cooperative-semaphore.md)<br/>
[Пошаговое руководство. Удаление работы из потока пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md)<br/>
[Рекомендации в библиотеке параллельных шаблонов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md)<br/>
[Рекомендации в библиотеке асинхронных агентов](../../parallel/concrt/best-practices-in-the-asynchronous-agents-library.md)
