---
title: Пошаговое руководство. Создание агента потоков данных
ms.date: 04/25/2019
helpviewer_keywords:
- creating dataflow agents [Concurrency Runtime]
- dataflow agents, creating [Concurrency Runtime]
ms.assetid: 9db5ce3f-c51b-4de1-b79b-9ac2a0cbd130
ms.openlocfilehash: fa19d965a35909dfefc5f586c772bc9b4565e814
ms.sourcegitcommit: a8ef52ff4a4944a1a257bdaba1a3331607fb8d0f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/11/2020
ms.locfileid: "77142973"
---
# <a name="walkthrough-creating-a-dataflow-agent"></a>Пошаговое руководство. Создание агента потоков данных

В этом документе показано, как создать основанные на агентах приложения, основанные на потоке данных, а не в потоке управления.

*Поток управления* — это порядок выполнения операций в программе. Управление потоком регулируется с помощью структур управления, таких как условные операторы, циклы и т. д. Кроме того, *поток* данных относится к модели программирования, в которой вычисления выполняются только при наличии всех необходимых данных. Модель программирования потоков данных связана с концепцией передачи сообщений, при которой независимые компоненты программы взаимодействуют друг с другом, отправляя сообщения.

Асинхронные агенты поддерживают модели программирования потока управления и потока данных. Хотя модель потока управления подходит во многих случаях, модель потока данных подходит для других пользователей, например, когда агент получает данные и выполняет действие, основанное на полезных данных.

## <a name="prerequisites"></a>предварительные требования

Прежде чем приступить к работе с этим пошаговым руководством, прочитайте следующие документы:

- [Асинхронные агенты](../../parallel/concrt/asynchronous-agents.md)

- [Асинхронные блоки сообщений](../../parallel/concrt/asynchronous-message-blocks.md)

- [Практическое руководство. Использование фильтра блоков сообщений](../../parallel/concrt/how-to-use-a-message-block-filter.md)

## <a name="top"></a> Разделы

Это пошаговое руководство содержит следующие разделы:

- [Создание базового агента потока управления](#control-flow)

- [Создание основного агента потоков данных](#dataflow)

- [Создание агента ведения журнала сообщений](#logging)

## <a name="control-flow"></a>Создание базового агента потока управления

Рассмотрим следующий пример, определяющий класс `control_flow_agent`. Класс `control_flow_agent` работает с тремя буферами сообщений: одним входным буфером и двумя выходными буферами. Метод `run` считывает из буфера исходного сообщения в цикле и использует условный оператор для направления потока выполнения программы. Агент увеличивает один счетчик для ненулевых отрицательных значений и увеличивает другой счетчик для ненулевых положительных значений. После того как агент получает значение Sentinel, равное нулю, он отправляет значения счетчиков в выходные буферы сообщений. Методы `negatives` и `positives` позволяют приложению считывать количество отрицательных и положительных значений от агента.

[!code-cpp[concrt-dataflow-agent#1](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_1.cpp)]

Несмотря на то что этот пример делает базовое использование потока управления в агенте, он демонстрирует последовательное представление программирования на основе потока управления. Каждое сообщение должно обрабатываться последовательно, несмотря на то, что в буфере входящих сообщений могут быть доступны несколько сообщений. Модель потока данных позволяет параллельно оценивать обе ветви условного оператора. Модель потоков данных также позволяет создавать более сложные сети обмена сообщениями, работающие с данными по мере их поступления.

[[В начало](#top)]

## <a name="dataflow"></a>Создание основного агента потоков данных

В этом разделе показано, как преобразовать класс `control_flow_agent`, чтобы использовать модель потока данных для выполнения той же задачи.

Агент потоков данных работает путем создания сети буферов сообщений, каждая из которых служит определенной цели. Некоторые блоки сообщений используют функцию фильтра для принятия или отклонения сообщения на основе его полезных данных. Функция фильтра гарантирует, что блок сообщений получит только определенные значения.

#### <a name="to-convert-the-control-flow-agent-to-a-dataflow-agent"></a>Преобразование агента потока управления в агент потока данных

1. Скопируйте текст класса `control_flow_agent` в другой класс, например `dataflow_agent`. Кроме того, можно переименовать `control_flow_agent` класс.

1. Удалите тело цикла, который вызывает `receive` из метода `run`.

[!code-cpp[concrt-dataflow-agent#2](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_2.cpp)]

1. В методе `run` после инициализации переменных `negative_count` и `positive_count`добавьте объект `countdown_event`, который отслеживает количество активных операций.

[!code-cpp[concrt-dataflow-agent#6](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_3.cpp)]

   Класс `countdown_event` показан далее в этом разделе.

1. Создайте объекты буфера сообщений, которые будут участвовать в сети потока данных.

[!code-cpp[concrt-dataflow-agent#3](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_4.cpp)]

1. Подключите буферы сообщений для формирования сети.

[!code-cpp[concrt-dataflow-agent#4](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_5.cpp)]

1. Дождитесь установки `event` и `countdown event` объектов. Эти события сообщают, что агент получил значение Sentinel и все операции завершены.

[!code-cpp[concrt-dataflow-agent#5](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_6.cpp)]

На следующей схеме показана полная сеть потока данных для класса `dataflow_agent`.

![Сеть потока данных](../../parallel/concrt/media/concrt_dataflow.png "Сеть потока данных")

Следующая таблица описывает члены сети.

|Участник|Description|
|------------|-----------------|
|`increment_active`|Объект [concurrency::transformer](../../parallel/concrt/reference/transformer-class.md) , увеличивающий Счетчик активных событий и передающий входное значение остальной части сети.|
|`negatives`, `positives`|[concurrency::Call](../../parallel/concrt/reference/call-class.md) Objects, которые увеличивают число чисел и уменьшают счетчик активных событий. Каждый объект использует фильтр, чтобы принимать отрицательные или положительные числа.|
|`sentinel`|Объект [concurrency::Call](../../parallel/concrt/reference/call-class.md) , принимающий только значение Sentinel, равное нулю, и уменьшающий счетчик активного события.|
|`connector`|Объект [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) , который подключает исходный буфер сообщений к внутренней сети.|

Поскольку метод `run` вызывается в отдельном потоке, другие потоки могут передавать сообщения в сеть до полного подключения к сети. Элемент данных `_source` является объектом `unbounded_buffer`, который замещает все входные данные, отправляемые из приложения агенту. Чтобы убедиться, что сеть обрабатывает все входные сообщения, агент сначала связывает внутренние узлы сети, а затем связывает начало этой сети, `connector`, с `_source`ным членом данных. Это гарантирует, что сообщения не будут обрабатываться при формировании сети.

Так как сеть в этом примере основана на потоке данных, а не на потоке управления, сеть должна взаимодействовать с агентом, который завершил обработку каждого входного значения, и что узел-Метка получил свое значение. В этом примере используется объект `countdown_event`, чтобы сообщить о том, что все входные значения были обработаны, и объект [concurrency::Event](../../parallel/concrt/reference/event-class.md) , чтобы указать, что узел-Метка получил свое значение. Класс `countdown_event` использует объект `event` для сигнализации, когда значение счетчика достигает нуля. Заголовок сети потоков данных увеличивает счетчик каждый раз, когда он получает значение. Каждый узел терминала сети уменьшает счетчик после обработки входного значения. После того как агент формирует сеть потока данных, он ждет, чтобы узел Sentinel установил объект `event` и объект `countdown_event`, чтобы сообщить о том, что его счетчик достиг нуля.

В следующем примере показаны классы `control_flow_agent`, `dataflow_agent`и `countdown_event`. Функция `wmain` создает `control_flow_agent` и объект `dataflow_agent` и использует функцию `send_values` для отправки ряда случайных значений агентам.

[!code-cpp[concrt-dataflow-agent#7](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_7.cpp)]

В этом примере выводится следующий пример выходных данных:

```Output
Control-flow agent:
There are 500523 negative numbers.
There are 499477 positive numbers.
Dataflow agent:
There are 500523 negative numbers.
There are 499477 positive numbers.
```

### <a name="compiling-the-code"></a>Компиляция кода

Скопируйте пример кода и вставьте его в проект Visual Studio или вставьте в файл с именем `dataflow-agent.cpp`, а затем выполните следующую команду в окне командной строки Visual Studio.

**CL. exe/EHsc датафлов-ажент. cpp**

[[В начало](#top)]

## <a name="logging"></a>Создание агента ведения журнала сообщений

В следующем примере показан класс `log_agent`, напоминающий класс `dataflow_agent`. Класс `log_agent` реализует асинхронный агент ведения журнала, который записывает сообщения журнала в файл и в консоль. Класс `log_agent` позволяет приложению классифицировать сообщения как информационные, warning или Error. Он также позволяет приложению указать, записывается ли каждая категория журнала в файл, в консоль или в то и другое. В этом примере все сообщения журнала записываются в файл, а в консоль — только сообщения об ошибках.

[!code-cpp[concrt-log-filter#1](../../parallel/concrt/codesnippet/cpp/walkthrough-creating-a-dataflow-agent_8.cpp)]

В этом примере на консоль записываются следующие выходные данные.

```Output
error: This is a sample error message.
```

В этом примере также создается файл log. txt, который содержит следующий текст.

```Output
info: ===Logging started.===
warning: This is a sample warning message.
error: This is a sample error message.
info: ===Logging finished.===
```

### <a name="compiling-the-code"></a>Компиляция кода

Скопируйте пример кода и вставьте его в проект Visual Studio или вставьте в файл с именем `log-filter.cpp`, а затем выполните следующую команду в окне командной строки Visual Studio.

**CL. exe/EHsc лог-филтер. cpp**

[[В начало](#top)]

## <a name="see-also"></a>См. также раздел

[Пошаговые руководства по среде выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-walkthroughs.md)
