---
title: Рекомендации по работе с библиотекой параллельных шаблонов
ms.date: 11/04/2016
helpviewer_keywords:
- Parallel Patterns Library, practices to avoid
- practices to avoid, Parallel Patterns Library
- best practices, Parallel Patterns Library
- Parallel Patterns Library, best practices
ms.assetid: e43e0304-4d54-4bd8-a3b3-b8673559a9d7
ms.openlocfilehash: 0bd49dda881df402a8c511714c22be37da3a50c4
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231732"
---
# <a name="best-practices-in-the-parallel-patterns-library"></a>Рекомендации по работе с библиотекой параллельных шаблонов

В этом документе описано, как наиболее эффективно использовать библиотеку параллельных шаблонов (PPL). Библиотека PPL предоставляет алгоритмы, объекты и контейнеры общего назначения для выполнения детального параллелизма.

Дополнительные сведения о PPL см. в разделе [Библиотека параллельных шаблонов (PPL)](../../parallel/concrt/parallel-patterns-library-ppl.md).

## <a name="sections"></a><a name="top"></a>Священ

Этот документ содержит следующие разделы.

- [Не выполняйте параллелизацию небольших циклов](#small-loops)

- [Реализуйте параллелизм на самом высоком уровне](#highest)

- [Используйте функцию parallel_invoke для разрешения проблем разобщения](#divide-and-conquer)

- [Используйте отмену или обработку исключений для выхода из параллельного цикла](#breaking-loops)

- [Узнайте, как отмена и обработка исключений влияет на уничтожение объектов](#object-destruction)

- [Не применяйте блокировку несколько раз в параллельном цикле](#repeated-blocking)

- [Не выполняйте операции блокировки при отмене параллельных работ](#blocking)

- [Не выполняйте запись в общие данные в параллельном цикле](#shared-writes)

- [По возможности избегайте ложного совместного использования](#false-sharing)

- [Убедитесь, что переменные допустимы на протяжении времени существования задачи](#lifetime)

## <a name="do-not-parallelize-small-loop-bodies"></a><a name="small-loops"></a>Не выпараллелизации небольшие тела циклов

Распараллеливание относительно небольших тел циклов может привести к дополнительным издержкам при планировании, которые сведут на нет преимущества параллельной обработки. Рассмотрим следующий пример, в котором каждая пара элементов помещается в два массива.

[!code-cpp[concrt-small-loops#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_1.cpp)]

Нагрузка каждой итерации параллельного цикла слишком мала, чтобы почувствовать преимущества параллельной обработки. Можно повысить производительность этого цикла, выполняя больше работы в теле цикла или выполняя цикл последовательно.

[[Top](#top)]

## <a name="express-parallelism-at-the-highest-possible-level"></a><a name="highest"></a>Экспресс параллелизма на максимально возможном уровне

При распараллеливании кода только на низком уровне можно ввести конструкцию ветвления-соединения, которая не масштабируется при увеличении числа процессоров. Конструкция *ветвления-объединения* — это конструкция, в которой одна задача разделяет свою работу на небольшие параллельные подзадачи и ожидает завершения этих подзадач. Каждая подзадача может рекурсивно делиться на еще более мелкие подзадачи.

Хотя модель ветвления-соединения может быть полезна для решения различных проблем, существуют ситуации, когда затраты на синхронизацию могут снизить масштабируемость. Например, рассмотрим следующий последовательный код, обрабатывающий данные изображений.

[!code-cpp[concrt-image-processing-filter#20](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_2.cpp)]

Поскольку каждая итерация цикла независима, можно распараллеливать большую часть работы, как показано в следующем примере. В этом примере для параллелизации внешнего цикла используется алгоритм [arallel_for Concurrency::p](reference/concurrency-namespace-functions.md#parallel_for) .

[!code-cpp[concrt-image-processing-filter#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_3.cpp)]

В следующем примере показана конструкции ветвления-соединения путем вызова функции `ProcessImage` в цикле. Каждый вызов `ProcessImage` не возвращает данные до завершения подзадачи.

[!code-cpp[concrt-image-processing-filter#21](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_4.cpp)]

Если при каждой итерации параллельного цикла выполняется очень мало работы или работа, выполняемая параллельным циклом, несбалансирована (то есть некоторые итерации цикла выполняются дольше, чем другие), затраты на планирование, необходимое для частого ветвления и соединения работы, могут перевесить преимущества параллельного выполнения. Эти затраты растут по мере роста числа процессов.

Чтобы уменьшить объем затрат на планирование в этом примере, можно распараллелить внешние циклы перед внутренними или использовать другие параллельные конструкции, например конвейер. В следующем примере `ProcessImages` функция используется для параллелизации внешнего цикла с помощью алгоритма [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) .

[!code-cpp[concrt-image-processing-filter#22](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_5.cpp)]

Аналогичный пример, использующий конвейер для параллельной обработки изображений, см. в разделе [Пошаговое руководство. Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md).

[[Top](#top)]

## <a name="use-parallel_invoke-to-solve-divide-and-conquer-problems"></a><a name="divide-and-conquer"></a>Использование parallel_invoke для решения проблем деления и властвуй

Проблема *деления и властвуй* — это форма конструкции ветвления-объединения, которая использует рекурсию для разбиения задачи на подзадачи. В дополнение к классам [concurrency::task_group](reference/task-group-class.md) и [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) можно также использовать алгоритм [параллелизма::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) , чтобы решить проблемы деления и властвуй. Алгоритм `parallel_invoke` имеет более сжатый синтаксис, чем объекты группы задач, и удобен при наличии фиксированного числа параллельных задач.

В следующем примере показано использование алгоритма `parallel_invoke` для реализации алгоритма битонной сортировки.

[!code-cpp[concrt-parallel-bitonic-sort#12](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_6.cpp)]

Для снижения затрат алгоритм `parallel_invoke` выполняет последний ряд задач в вызывающем контексте.

Полную версию этого примера см. в разделе [руководство. использование parallel_invoke для написания параллельной подпрограммы сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md). Дополнительные сведения об `parallel_invoke` алгоритме см. в разделе [Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

[[Top](#top)]

## <a name="use-cancellation-or-exception-handling-to-break-from-a-parallel-loop"></a><a name="breaking-loops"></a>Использование отмены или обработки исключений для прерывания из параллельного цикла

Библиотека PPL предоставляет два способа отмены параллельной работы, выполняемой группой задач или параллельным алгоритмом. Один из способов — использовать механизм отмены, предоставляемый классами [concurrency::task_group](reference/task-group-class.md) и [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) . Второй способ — создать исключение в теле рабочей функции задачи. Механизм отмены более эффективен, чем обработка исключений при отмене дерева параллельной работы. *Дерево параллельной работы* — это группа связанных групп задач, в которой некоторые группы задач содержат другие группы задач. Механизм отмены отменяет группу задач и ее дочерние группы в порядке «сверху вниз». И наоборот, обработка исключений работает в режиме «снизу вверх» и необходимо отменять каждую дочернюю группу задач независимо, поскольку исключение распространяется вверх.

При работе непосредственно с объектом группы задач используйте методы [concurrency::task_group:: Cancel](reference/task-group-class.md#cancel) или [concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) , чтобы отменить работу, относящуюся к этой группе задач. Чтобы отменить параллельный алгоритм, например `parallel_for`, создайте родительскую группу задач и отмените ее. Например, рассмотрим следующую функцию, `parallel_find_any`, которая выполняет поиск значения в массиве в параллельном режиме.

[!code-cpp[concrt-parallel-array-search#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_7.cpp)]

Поскольку параллельные алгоритмы используют группы задач, когда одна из параллельных итераций отменяет родительскую группу задач, общая задача также отменяется. Полную версию этого примера см. в разделе [как использовать отмену для перерыва в параллельном цикле](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md).

Хотя обработка исключений является менее эффективным способом отмены параллельной работы, чем механизм отмены, существуют случаи, в которых лучше применять обработку исключений. Например, следующий метод, `for_all`, рекурсивно выполняет рабочую функцию для каждого узла структуры `tree`. В этом примере `_children` элемент данных — это [std:: List](../../standard-library/list-class.md) , содержащий `tree` объекты.

[!code-cpp[concrt-task-tree-search#6](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_8.cpp)]

Вызывающий объект метода `tree::for_all` может создать исключение, если ему не требуется вызывать рабочую функцию для каждого элемента дерева. В следующем примере показана функция `search_for_value`, которая выполняет поиск значения в предоставленном объекте `tree`. Функция `search_for_value` использует рабочую функцию, которая создает исключение, если текущий элемент дерева соответствует предоставленному значению. Функция `search_for_value` использует блок `try-catch`, чтобы зафиксировать исключение и вывести результат на консоль.

[!code-cpp[concrt-task-tree-search#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_9.cpp)]

Полную версию этого примера см. в разделе [как использовать обработку исключений для прерывания работы параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).

Дополнительные общие сведения о механизмах отмены и обработки исключений, предоставляемых PPL, см. [в разделе Отмена в PPL](cancellation-in-the-ppl.md) и [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

[[Top](#top)]

## <a name="understand-how-cancellation-and-exception-handling-affect-object-destruction"></a><a name="object-destruction"></a>Узнайте, как отмена и обработка исключений влияют на уничтожение объектов.

В дереве параллельной работы отмененная задача предотвращает запуск дочерних задач. Это может привести к проблемам, если одна из дочерних задач выполняет операцию, важную для приложения, например высвобождает ресурс. Кроме того, отмена задачи может привести к тому, что исключение распространится через деструктор объектов и вызовет неопределенное поведение в приложении.

В следующем примере класс `Resource` описывает ресурс, а класс `Container` — контейнер, содержащий ресурсы. В его деструкторе класс `Container` вызывает метод `cleanup` для двух из его членов `Resource` в параллельном режиме, а затем вызывает метод `cleanup` для третьего члена `Resource`.

[!code-cpp[concrt-parallel-resource-destruction#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_10.h)]

Несмотря на то что эта схема сама по себе не представляет никаких проблем, рассмотрим следующий код, выполняющий две задачи параллельно. Первая задача создает объект `Container`, а вторая задача отменяет общую задачу. Для иллюстрации пример использует два объекта [concurrency::Event](../../parallel/concrt/reference/event-class.md) , чтобы убедиться, что отмена происходит после `Container` создания объекта и что `Container` объект уничтожается после выполнения операции отмены.

[!code-cpp[concrt-parallel-resource-destruction#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_11.cpp)]

В этом примере выводятся следующие данные:

```Output
Container 1: Freeing resources...Exiting program...
```

Данный пример кода содержит следующие проблемы, которые могут привести к неожиданному поведению.

- Отмена родительской задачи приводит к тому, что дочерняя задача, вызов метода [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke), также будут отменены. Таким образом, эти два ресурса не высвобождаются.

- Отмена родительской задачи приводит к тому, что дочерняя задача создает внутреннее исключение. Поскольку деструктор `Container` не обрабатывает это исключение, оно распространяется вверх и третий ресурс не высвобождается.

- Исключение, создаваемое дочерней задачей, распространяется по всему деструктору `Container`. Создание исключения из деструктора приводит приложение в неопределенное состояние.

Рекомендуется не выполнять важные операции, например высвобождение ресурсов, в задачах, если нельзя гарантировать, что эти задачи не будут отменены. Также рекомендуется не использовать функции среды выполнения, которые могут создавать исключение в деструкторе типов.

[[Top](#top)]

## <a name="do-not-block-repeatedly-in-a-parallel-loop"></a><a name="repeated-blocking"></a>Не блокируйте несколько раз в параллельном цикле

Параллельный цикл, такой как [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for) или [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) , который находится в результате блокирующих операций, может привести к тому, что среда выполнения создаст много потоков в течение короткого промежутка времени.

Среда выполнения с параллелизмом выполняет дополнительную работу, когда задача завершается или выполняет совместную блокировку либо выход. Когда одна итерация параллельного цикла блокируется, среда выполнения может начать другую итерацию. Если нет свободных бездействующих потоков, среда выполнения создает новый поток.

В случае блокировки тела параллельного цикла, этот механизм позволяет увеличить производительность общей задачи. Однако, если блокируется много итераций, среда выполнения может создавать много потоков для выполнения дополнительной работы. Это может привести к условиям нехватки памяти или неэффективного использования аппаратных ресурсов.

Рассмотрим следующий пример, который вызывает функцию [concurrency::send](reference/concurrency-namespace-functions.md#send) в каждой итерации `parallel_for` цикла. Поскольку функция `send` выполняет совместную блокировку, среда выполнения создает новый поток для выполнения дополнительной работы при каждом вызове `send`.

[!code-cpp[concrt-repeated-blocking#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_12.cpp)]

Рекомендуется выполнить рефакторинг кода, чтобы избежать этой ситуации. В этом примере можно избежать создания дополнительных потоков путем вызова `send` в последовательном **`for`** цикле.

[[Top](#top)]

## <a name="do-not-perform-blocking-operations-when-you-cancel-parallel-work"></a><a name="blocking"></a>Не выполнять блокирующие операции при отмене параллельной работы

По возможности не выполняйте блокирующие операции перед вызовом метода [concurrency::task_group:: Cancel](reference/task-group-class.md#cancel) или [concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) для отмены параллельной работы.

Когда задача выполняет операцию совместной блокировки, среда выполнения может выполнять другую работу, пока первая задача ожидает получения данных. Среда выполнения переносит выполнение ожидающей задачи на момент после разблокирования. Как правило, среда выполнения сначала переносит выполнение задач, разблокированных недавно, а затем — задач, разблокированных ранее. Поэтому среда выполнения может запланировать лишнюю работу во время операции блокировки, что приводит к снижению производительности. Соответственно, при выполнении операции блокировки до отмены параллельной работы операция блокировки может задержать вызов метода `cancel`. В этом случае другие задачи выполняют лишнюю работу.

Рассмотрим следующий пример, определяющий функцию `parallel_find_answer`, которая выполняет поиск элемента указанного массива, удовлетворяющего заданной предикативной функции. При возврате функции предиката **`true`** функция Parallel `Answer` Task создает объект и отменяет общую задачу.

[!code-cpp[concrt-blocking-cancel#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_13.cpp)]

Оператор `new` выполняет выделение кучи, которое может блокироваться. Среда выполнения выполняет другую работу, только если задача выполняет параллельный вызов блокировки, например вызов [concurrency::critical_section:: Lock](reference/critical-section-class.md#lock).

В следующем примере показано, как предотвратить лишнюю работу и тем самым повысить производительность. Этот пример отменяет группу задач до выделения хранилища для объекта `Answer`.

[!code-cpp[concrt-blocking-cancel#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_14.cpp)]

[[Top](#top)]

## <a name="do-not-write-to-shared-data-in-a-parallel-loop"></a><a name="shared-writes"></a>Не записывать в общие данные в параллельном цикле

Среда выполнения с параллелизмом предоставляет несколько структур данных, например [concurrency::critical_section](../../parallel/concrt/reference/critical-section-class.md), которые синхронизируют одновременный доступ к общим данным. Эти структуры данных удобны во многих случаях, например, если нескольким задачам нечасто нужен общий доступ к ресурсу.

Рассмотрим следующий пример, использующий алгоритм [concurrency::parallel_for_each](reference/concurrency-namespace-functions.md#parallel_for_each) и `critical_section` объект для вычисления числа простых чисел в объекте [std:: Array](../../standard-library/array-class-stl.md) . Этот пример нельзя масштабировать, так как каждый поток должен ждать доступа к общей переменной `prime_sum`.

[!code-cpp[concrt-parallel-sum-of-primes#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_15.cpp)]

Этот пример также может привести к снижению производительности, поскольку частое выполнение операции блокировки эффективно сериализует цикл. Кроме того, когда объект среды выполнения с параллелизмом выполняет операцию блокировки, планировщик может создавать дополнительный поток, чтобы выполнять другую работу, пока первый поток ожидает поступления данных. Если среда выполнения создает много потоков (поскольку многие задачи ожидают доступ к общим данным), может наблюдаться снижение производительности или переход приложения в состояние нехватки ресурсов.

PPL определяет класс [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) , который помогает исключить общее состояние, предоставляя доступ к общим ресурсам без блокировки. Класс `combinable` предоставляет локальное для потока хранилище, которое позволяет выполнять детализированные вычисления и объединять их в общий результат. Объект `combinable` можно рассматривать как переменную уменьшения.

Следующий пример изменяет предыдущий, используя объект `combinable` вместо объекта `critical_section` для вычисления суммы. Этот пример масштабируется, так как каждый поток содержит свою собственную локальную копию суммы. В этом примере используется метод [concurrency::combinable:: Combine](reference/combinable-class.md#combine) для слияния локальных вычислений в окончательный результат.

[!code-cpp[concrt-parallel-sum-of-primes#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_16.cpp)]

Полную версию этого примера см. в разделе [как использовать комбинирование для повышения производительности](../../parallel/concrt/how-to-use-combinable-to-improve-performance.md). Дополнительные сведения о `combinable` классе см. в разделе [Parallel Containers and Objects](../../parallel/concrt/parallel-containers-and-objects.md).

[[Top](#top)]

## <a name="when-possible-avoid-false-sharing"></a><a name="false-sharing"></a>По возможности избегайте ложного совместного доступа

*Ложное совместное использование* происходит, когда несколько параллельных задач, выполняемых на разных процессорах, записывают переменные, расположенные в одной строке кэша. Когда одна задача записывает данные в одну из переменных, строка кэша для обоих переменных становится недействительной. Каждый процессор должен перезагружать строку кэша каждый раз, когда строка кэша становится недействительной. Таким образом, ложное совместное использование может привести к снижению производительности приложения.

Следующий простой пример демонстрирует две параллельные задачи, увеличивающие значение общей переменной счетчика.

[!code-cpp[concrt-false-sharing#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_17.cpp)]

Чтобы исключить совместное использование данных двумя задачами, можно изменить этот пример для использования двух переменных счетчика. В этом примере окончательное значение счетчика вычисляется после выполнения задач. Тем не менее этот пример иллюстрирует ложное совместное использование, так как переменные `count1` и `count2`, скорее всего, расположены в одной и той же строке кэша.

[!code-cpp[concrt-false-sharing#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_18.cpp)]

Одним из способов исключить ложное совместное использование является использование переменных счетчика в разных строках кэша. Следующий пример выравнивает переменные `count1` и `count2` в границах 64 байтов.

[!code-cpp[concrt-false-sharing#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_19.cpp)]

В этом примере предполагается, что размер кэша памяти — 64 байта или менее.

Рекомендуется использовать класс [concurrency::combinable](../../parallel/concrt/reference/combinable-class.md) , если необходимо передавать данные между задачами. Класс `combinable` создает локальные для потока переменные таким образом, что ложное совместное использование становится менее вероятным. Дополнительные сведения о `combinable` классе см. в разделе [Parallel Containers and Objects](../../parallel/concrt/parallel-containers-and-objects.md).

[[Top](#top)]

## <a name="make-sure-that-variables-are-valid-throughout-the-lifetime-of-a-task"></a><a name="lifetime"></a>Убедитесь, что переменные допустимы в течение всего времени существования задачи.

При предоставлении лямбда-выражения группе задач или параллельному алгоритму предложение фиксации указывает, получает ли тело лямбда-выражения доступ к переменным во внешней области по значению или по ссылке. При передаче переменных в лямбда-выражение по ссылке необходимо обеспечить сохранение существования этой переменной до завершения задачи.

Рассмотрим следующий пример, определяющий класс `object` и функцию `perform_action`. Функция `perform_action` создает переменную `object` и выполняет некоторые действия с этой переменной асинхронно. Поскольку нет гарантий, что выполнение задачи завершится до возвращения данных функцией `perform_action`, можно ожидать сбой или непредвиденное поведение программы в случае уничтожения переменной `object` во время выполнения задачи.

[!code-cpp[concrt-lambda-lifetime#1](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_20.cpp)]

В зависимости от требований приложения можно использовать один из следующих способов, чтобы гарантировать, что переменные будут оставаться действительными на протяжении всего времени существования каждой задачи.

В следующем примере переменная `object` передается задаче по значению. Поэтому задача работает с собственной копией переменной.

[!code-cpp[concrt-lambda-lifetime#2](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_21.cpp)]

Поскольку переменная `object` передается по значению, любые изменения состояния этой переменной не отражаются в исходной копии.

В следующем примере используется метод [concurrency::task_group:: wait](reference/task-group-class.md#wait) , чтобы убедиться, что задача завершается перед `perform_action` возвратом функции.

[!code-cpp[concrt-lambda-lifetime#3](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_22.cpp)]

Так как задача завершается до возвращения данных функцией, функция `perform_action` больше не может обеспечить асинхронное поведение.

В следующем примере демонстрируется изменение функции `perform_action`, чтобы использовать ссылку на переменную `object`. Вызывающий объект должен гарантировать, что время существования переменной `object` будет действительно до завершения задачи.

[!code-cpp[concrt-lambda-lifetime#4](../../parallel/concrt/codesnippet/cpp/best-practices-in-the-parallel-patterns-library_23.cpp)]

Кроме того, для управления временем существования объекта, передаваемого в группу задач или параллельный алгоритм, можно использовать указатель.

Дополнительные сведения о лямбда-выражениях см. в разделе [лямбда-выражения](../../cpp/lambda-expressions-in-cpp.md).

[[Top](#top)]

## <a name="see-also"></a>См. также раздел

[Рекомендации по среда выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime-best-practices.md)<br/>
[Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)<br/>
[Параллельные контейнеры и объекты](../../parallel/concrt/parallel-containers-and-objects.md)<br/>
[Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md)<br/>
[Отмена в библиотеке параллельных шаблонов](cancellation-in-the-ppl.md)<br/>
[Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)<br/>
[Пошаговое руководство. Создание сети обработки изображений](../../parallel/concrt/walkthrough-creating-an-image-processing-network.md)<br/>
[Как использовать parallel_invoke для написания параллельной подпрограммы сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)<br/>
[Как прервать выполнение из параллельного цикла с помощью отмены](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md)<br/>
[Как использовать комбинирование для повышения производительности](../../parallel/concrt/how-to-use-combinable-to-improve-performance.md)<br/>
[Рекомендации в библиотеке асинхронных агентов](../../parallel/concrt/best-practices-in-the-asynchronous-agents-library.md)<br/>
[Общие рекомендации в среда выполнения с параллелизмом](../../parallel/concrt/general-best-practices-in-the-concurrency-runtime.md)
