---
title: Обработка исключений в среде выполнения с параллелизмом
ms.date: 11/04/2016
helpviewer_keywords:
- lightweight tasks, exception handling [Concurrency Runtime]
- exception handling [Concurrency Runtime]
- structured task groups, exception handling [Concurrency Runtime]
- agents, exception handling [Concurrency Runtime]
- task groups, exception handling [Concurrency Runtime]
ms.assetid: 4d1494fb-3089-4f4b-8cfb-712aa67d7a7a
ms.openlocfilehash: f85bf5c96ef31944e84473f1fedb077123801153
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87230406"
---
# <a name="exception-handling-in-the-concurrency-runtime"></a>Обработка исключений в среде выполнения с параллелизмом

Среда выполнения с параллелизмом использует обработку исключений C++ для обмена сообщениями различных типов. В число этих ошибок включено недопустимое использование исполняющей среды, такие ошибки исполняющей среды, как сбой в получении ресурса, а также ошибки в рабочих функциях, предоставляемых задачам и группам задач. Когда задача или группа задач создает исключение, исполняющая среда хранит это исключение и маршалирует его в контекст, ожидающий завершения задачи или группы задач. Для таких компонентов, как упрощенные задачи и агенты, среда выполнения не управляет исключениями. В таких случаях необходимо реализовать собственный механизм обработки исключений. В этом разделе описывается обработка в среде выполнения исключений, созданных задачами, группами задач, упрощенными задачами и асинхронными агентами, а также способы реагирования на исключения в приложениях.

## <a name="key-points"></a>Основные моменты

- Когда задача или группа задач создает исключение, исполняющая среда хранит это исключение и маршалирует его в контекст, ожидающий завершения задачи или группы задач.

- По возможности заключайте каждый вызов к [concurrency::Task:: Get](reference/task-class.md#get) и [concurrency::Task:: wait](reference/task-class.md#wait) с **`try`** / **`catch`** блоком для обработки ошибок, из которых можно выполнить восстановление. Среда выполнения завершает приложение, если задача создает исключение и это исключение не перехватывается задачей, одним из ее продолжений или основным приложением.

- Основанное на задаче продолжение выполняется всегда вне зависимости от того, завершилась ли предыдущая задача успешно, создала исключение или была отменена. Основанное на значении продолжение не выполняется, если предыдущая задача была отменена или создала исключение.

- Поскольку основанное на задаче продолжение задачи выполняется всегда, рассмотрите возможность добавления продолжения, основанного на задаче, в конец цепочки продолжения. Это позволяет гарантировать, что код проверяет все исключения.

- Среда выполнения вызывает метод [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) при вызове [concurrency::Task:: Get](reference/task-class.md#get) и отмене задачи.

- Среда выполнения не управляет исключениями для легковесных задач и агентов.

## <a name="in-this-document"></a><a name="top"></a>В этом документе

- [Задачи и продолжения](#tasks)

- [Группы задач и параллельные алгоритмы](#task_groups)

- [Исключения, вызываемые средой выполнения](#runtime)

- [Несколько исключений](#multiple)

- [Отмена](#cancellation)

- [Упрощенные задачи](#lwts)

- [Асинхронные агенты](#agents)

## <a name="tasks-and-continuations"></a><a name="tasks"></a>Задачи и продолжения

В этом разделе описывается, как среда выполнения обрабатывает исключения, вызываемые объектами [concurrency::Task](../../parallel/concrt/reference/task-class.md) и их продолжениями. Дополнительные сведения о модели задач и продолжения см. в разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md).

При возникновении исключения в теле рабочей функции, которая передается в `task` объект, среда выполнения сохраняет это исключение и маршалирует его в контекст, вызывающий [concurrency::Task:: Get](reference/task-class.md#get) или [concurrency::Task:: wait](reference/task-class.md#wait). [Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) в документе описывает продолжения на основе задач и на основе значений, но для суммирования продолжение на основе значений принимает параметр типа `T` , а продолжение на основе задачи принимает параметр типа `task<T>` . Если задача, которая создает исключение, имеет одно или несколько продолжений, основанных на значении, эти продолжения не ставятся в очередь для запуска. Это демонстрируется в приведенном ниже примере.

[!code-cpp[concrt-eh-task#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_1.cpp)]

Продолжение на основе задачи позволяет обрабатывать любое исключение, созданное предшествующей задачей. Основанное на задаче продолжение выполняется всегда вне зависимости от того, завершилась ли задача успешно, создала исключение или была отменена. Если задача создает исключение, ее продолжения на основе задач вносятся в план для выполнения. В следующем примере показана задача, которая всегда создает исключение. У задачи два продолжения: одно основано на значении, а другое — на задаче. Продолжение на основе задачи выполняется всегда и, таким образом, может перехватить исключение, созданное предшествующей задачей. Если в примере ожидается завершение обоих продолжений, исключение создается повторно, поскольку исключение задачи всегда создается при вызове `task::get` или `task::wait`.

[!code-cpp[concrt-eh-continuations#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_2.cpp)]

Рекомендуется использовать продолжения на основе задачи, чтобы перехватывать исключения, которые вы можете обработать. Поскольку основанное на задаче продолжение задачи выполняется всегда, рассмотрите возможность добавления продолжения, основанного на задаче, в конец цепочки продолжения. Это позволяет гарантировать, что код проверяет все исключения. В следующем примере показана простая цепочка продолжений на основе значений. Третья задача в цепочке создает исключение, и поэтому все последующие продолжения на основе значений не выполняются. Однако последнее продолжение основано на задаче, и поэтому всегда выполняется. Последнее продолжение обрабатывает исключение, которое создается третьей задачей.

Рекомендуется перехватывать максимально конкретные исключения. Можно опустить это последнее продолжение на основе задачи, если у вас нет определенных исключений, которые необходимо перехватывать. Любое исключение останется необработанным и может завершить приложение.

[!code-cpp[concrt-eh-task-chain#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_3.cpp)]

> [!TIP]
> Чтобы связать исключение с событием завершения задачи, можно использовать метод [concurrency::task_completion_event:: set_exception](../../parallel/concrt/reference/task-completion-event-class.md) . [Параллелизм задачи](../../parallel/concrt/task-parallelism-concurrency-runtime.md) «документ» описывает класс [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) более подробно.

[concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) является важным типом исключения среды выполнения, относящимся к `task` . Среда выполнения создает `task_canceled` при вызове `task::get`, если эта задача отменена. (И наоборот, `task::wait` возвращает [task_status:: Canceled](reference/concurrency-namespace-enums.md#task_group_status) и не создает исключение.) Это исключение можно перехватить и обработать из продолжения на основе задачи или при вызове метода `task::get` . Дополнительные сведения об отмене задач см. [в разделе Отмена в библиотеке PPL](cancellation-in-the-ppl.md).

> [!CAUTION]
> Никогда не вызывайте исключение `task_canceled` из своего кода. Вместо этого вызовите [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) .

Среда выполнения завершает приложение, если задача создает исключение и это исключение не перехватывается задачей, одним из ее продолжений или основным приложением. Если приложение аварийно завершается, можно настроить Visual Studio, чтобы прерывать выполнение при создании исключений C++. После выяснения расположения необработанного исключения используйте продолжение на основе задачи, чтобы обработать его.

Исключения раздела, [вызываемые средой выполнения](#runtime) в этом документе, описывают, как работать с исключениями среды выполнения более подробно.

[[Top](#top)]

## <a name="task-groups-and-parallel-algorithms"></a><a name="task_groups"></a>Группы задач и параллельные алгоритмы

В этом разделе описывается, как среда выполнения обрабатывает исключения, создаваемые группами задач. Этот раздел также применяется к параллельным алгоритмам, таким как [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), так как эти алгоритмы создаются в группах задач.

> [!CAUTION]
> Убедитесь, что вы понимаете влияние исключений на зависимые задачи. Рекомендации по использованию обработки исключений с задачами или параллельными алгоритмами см. в разделе [понимание того, как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) в рекомендациях в библиотеке параллельных шаблонов.

Дополнительные сведения о группах задач см. в разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md). Дополнительные сведения о параллельных алгоритмах см. в разделе [Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

При возникновении исключения в теле рабочей функции, которая передается в [concurrency::task_group](reference/task-group-class.md) или [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) Object среда выполнения сохраняет это исключение и маршалирует его в контекст, вызывающий [concurrency::task_group:: wait](reference/task-group-class.md#wait), [concurrency::structured_task_group:: wait](reference/structured-task-group-class.md#wait), [concurrency::task_group:: run_and_wait](reference/task-group-class.md#run_and_wait)или [concurrency::structured_task_group:: run_and_wait](reference/structured-task-group-class.md#run_and_wait). Среда выполнения также останавливает все активные задачи, находящиеся в группе задач (в том числе в дочерних группах задач), и удаляет все задачи, которые еще не запущены.

В следующем примере показана базовая структура рабочей функции, которая создает исключение. В примере используется `task_group` объект для параллельного вывода значений двух `point` объектов. `print_point`Рабочая функция выводит значения `point` объекта на консоль. Рабочая функция создает исключение, если входное значение равно `NULL` . Среда выполнения сохраняет это исключение и маршалирует его в контекст, вызывающий `task_group::wait` .

[!code-cpp[concrt-eh-task-group#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_4.cpp)]

В этом примере формируются следующие данные:

```Output
X = 15, Y = 30Caught exception: point is NULL.
```

Полный пример использования обработки исключений в группе задач см. в разделе [как использовать обработку исключений для прерывания работы параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).

[[Top](#top)]

## <a name="exceptions-thrown-by-the-runtime"></a><a name="runtime"></a>Исключения, вызываемые средой выполнения

Исключение может быть результатом вызова среды выполнения. Большинство типов исключений, за исключением [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md) и [concurrency::operation_timed_out](../../parallel/concrt/reference/operation-timed-out-class.md), указывают на ошибку программирования. Эти ошибки обычно невосстанавливаемы, поэтому их не следует перехватывать или обрабатывать с помощью кода приложения. Рекомендуется перехватывать или справляться с неустранимыми ошибками в коде приложения, если требуется диагностировать ошибки программирования. Однако понимание типов исключений, определенных средой выполнения, может помочь в диагностике ошибок программирования.

Механизм обработки исключений одинаков для исключений, вызываемых средой выполнения, как исключения, создаваемые рабочими функциями. Например, функция [concurrency::Receive](reference/concurrency-namespace-functions.md#receive) создает исключение, `operation_timed_out` если оно не получает сообщение за указанный период времени. Если `receive` вызывает исключение в рабочей функции, которая передается в группу задач, среда выполнения сохраняет это исключение и маршалирует его в контекст, который вызывает,, `task_group::wait` `structured_task_group::wait` `task_group::run_and_wait` или `structured_task_group::run_and_wait` .

В следующем примере алгоритм [параллелизма::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) используется для параллельного выполнения двух задач. Первая задача ожидает пять секунд, а затем отправляет сообщение в буфер сообщений. Вторая задача использует функцию, `receive` чтобы подождать три секунды, чтобы получить сообщение из того же буфера сообщений. `receive`Функция создает исключение, `operation_timed_out` если она не получает сообщение за период времени.

[!code-cpp[concrt-eh-time-out#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_5.cpp)]

В этом примере формируются следующие данные:

```Output
The operation timed out.
```

Чтобы предотвратить аварийное завершение работы приложения, убедитесь, что код обрабатывает исключения при вызове среды выполнения. Также Обрабатывайте исключения при вызове внешнего кода, который использует среда выполнения с параллелизмом, например библиотеку стороннего разработчика.

[[Top](#top)]

## <a name="multiple-exceptions"></a><a name="multiple"></a>Несколько исключений

Если задача или параллельный алгоритм получает несколько исключений, среда выполнения маршалирует только одно из этих исключений в вызывающий контекст. Среда выполнения не гарантирует, какое исключение оно маршалирует.

В следующем примере алгоритм используется `parallel_for` для вывода чисел на консоль. Он создает исключение, если входное значение меньше минимального значения или больше некоторого максимального значения. В этом примере несколько рабочих функций могут вызывать исключение.

[!code-cpp[concrt-eh-multiple#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_6.cpp)]

Ниже приведен пример выходных данных для этого примера.

```Output
8293104567Caught exception: -5: the value is less than the minimum.
```

[[Top](#top)]

## <a name="cancellation"></a><a name="cancellation"></a>Уведомление

Не все исключения указывают на ошибку. Например, алгоритм поиска может использовать обработку исключений для отмены связанной задачи при обнаружении результата. Дополнительные сведения об использовании механизмов отмены в коде см. [в разделе Отмена в библиотеке PPL](../../parallel/concrt/cancellation-in-the-ppl.md).

[[Top](#top)]

## <a name="lightweight-tasks"></a><a name="lwts"></a>Упрощенные задачи

Упрощенная задача — это задача, запланированная непосредственно из объекта [concurrency::Scheduler](../../parallel/concrt/reference/scheduler-class.md) . Упрощенные задачи наносят меньше ресурсов, чем обычные задачи. Однако среда выполнения не перехватывает исключения, создаваемые упрощенными задачами. Вместо этого исключение перехватывается обработчиком необработанных исключений, который по умолчанию завершает процесс. Поэтому используйте в приложении подходящий механизм обработки ошибок. Дополнительные сведения о упрощенных задачах см. в разделе [планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md).

[[Top](#top)]

## <a name="asynchronous-agents"></a><a name="agents"></a>Асинхронные агенты

Как и в случае с упрощенными задачами, среда выполнения не управляет исключениями, создаваемыми асинхронными агентами.

В следующем примере показан один из способов обработки исключений в классе, производном от [concurrency::Agent](../../parallel/concrt/reference/agent-class.md). В этом примере определяется `points_agent` класс. `points_agent::run`Метод считывает `point` объекты из буфера сообщений и выводит их на консоль. `run`Метод создает исключение, если получает `NULL` указатель.

`run`Метод окружает всю работу в **`try`** - **`catch`** блоке. **`catch`** Блок хранит исключение в буфере сообщений. Приложение проверяет, обнаружил ли агент ошибку, считывая из этого буфера после завершения работы агента.

[!code-cpp[concrt-eh-agents#1](../../parallel/concrt/codesnippet/cpp/exception-handling-in-the-concurrency-runtime_7.cpp)]

В этом примере формируются следующие данные:

```Output
X: 10 Y: 20
X: 20 Y: 30
error occurred in agent: point must not be NULL
the status of the agent is: done
```

Поскольку **`try`** - **`catch`** блок существует за пределами **`while`** цикла, агент завершает обработку при возникновении первой ошибки. Если **`try`** - **`catch`** блок находится внутри **`while`** цикла, агент продолжит работу после возникновения ошибки.

В этом примере исключения хранятся в буфере сообщений, чтобы другой компонент мог отслеживать на нем ошибки по мере его выполнения. В этом примере используется объект [concurrency::single_assignment](../../parallel/concrt/reference/single-assignment-class.md) для хранения ошибки. Если агент обрабатывает несколько исключений, `single_assignment` класс сохраняет только первое передаваемое ему сообщение. Чтобы сохранить только Последнее исключение, используйте класс [concurrency::overwrite_buffer](../../parallel/concrt/reference/overwrite-buffer-class.md) . Чтобы сохранить все исключения, используйте класс [concurrency::unbounded_buffer](reference/unbounded-buffer-class.md) . Дополнительные сведения об этих блоках сообщений см. в разделе [асинхронные блоки сообщений](../../parallel/concrt/asynchronous-message-blocks.md).

Дополнительные сведения об асинхронных агентах см. в разделе [асинхронные агенты](../../parallel/concrt/asynchronous-agents.md).

[[Top](#top)]

## <a name="summary"></a><a name="summary"></a> Сводка

[[Top](#top)]

## <a name="see-also"></a>См. также статью

[Среда выполнения с параллелизмом](../../parallel/concrt/concurrency-runtime.md)<br/>
[Параллельное выполнение задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md)<br/>
[Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md)<br/>
[Отмена в библиотеке параллельных шаблонов](cancellation-in-the-ppl.md)<br/>
[планировщик задач](../../parallel/concrt/task-scheduler-concurrency-runtime.md)<br/>
[Асинхронные агенты](../../parallel/concrt/asynchronous-agents.md)
