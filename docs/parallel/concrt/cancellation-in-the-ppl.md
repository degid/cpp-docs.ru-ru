---
title: Отмена в библиотеке параллельных шаблонов
ms.date: 11/19/2018
helpviewer_keywords:
- parallel algorithms, canceling [Concurrency Runtime]
- canceling parallel algorithms [Concurrency Runtime]
- parallel tasks, canceling [Concurrency Runtime]
- cancellation in the PPL
- parallel work trees [Concurrency Runtime]
- canceling parallel tasks [Concurrency Runtime]
ms.assetid: baaef417-b2f9-470e-b8bd-9ed890725b35
ms.openlocfilehash: e85de9a07b625030976e6f03c9e965d34c3134d4
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87220981"
---
# <a name="cancellation-in-the-ppl"></a>Отмена в библиотеке параллельных шаблонов

В этом документе рассматривается роль отмены в библиотеке параллельных шаблонов (PPL), а также объясняется, как отменить параллельную работу и как определить, что параллельная работа отменена.

> [!NOTE]
> Среда выполнения использует обработку исключений для реализации отмены. Не следует перехватывать или обрабатывать эти исключения в своем коде. Кроме того, рекомендуется писать безопасный в отношении исключений код в функциях для ваших задач. Например, можно использовать шаблон « *получение ресурсов — инициализация* » (RAII), чтобы обеспечить правильную обработку ресурсов при возникновении исключения в тексте задачи. Полный пример использования шаблона RAII для очистки ресурса в отменяемой задаче см. в разделе [Пошаговое руководство. Удаление работы из потока пользовательского интерфейса](../../parallel/concrt/walkthrough-removing-work-from-a-user-interface-thread.md).

## <a name="key-points"></a>Основные моменты

- Отмена выполняется совместно и обеспечивает координацию между кодом, запрашивающим отмену запросов, и задачей, которая отвечает за отмену.

- Если возможно, используйте токены отмены, чтобы отменить работу. Класс [concurrency::cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md) определяет токен отмены.

- При использовании токенов отмены используйте метод [concurrency::cancellation_token_source:: Cancel](reference/cancellation-token-source-class.md#cancel) , чтобы инициировать отмену, и функцию [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) для реагирования на отмену. Используйте метод [concurrency::cancellation_token:: is_canceled](reference/cancellation-token-class.md#is_canceled) , чтобы проверить, была ли другая задача запросила отмену.

- Отмена не происходит немедленно. Хотя новая работа не запускается при отмене задачи или группы задач, активная работа должна проверять и отвечать на отмену.

- Продолжение, основанное на значении, наследует токен отмены своей предшествующей задачи. Продолжение на основе задачи никогда не наследует токен своей предшествующей задачи.

- Используйте метод [concurrency::cancellation_token:: None](reference/cancellation-token-class.md#none) при вызове конструктора или функции, принимающей `cancellation_token` объект, но не требующей отмены операции. Кроме того, если не передать токен отмены в конструктор [concurrency::Task](../../parallel/concrt/reference/task-class.md) или функцию [concurrency::create_task](reference/concurrency-namespace-functions.md#create_task) , эта задача не может быть отменена.

## <a name="in-this-document"></a><a name="top"></a>В этом документе

- [Деревья параллельной работы](#trees)

- [Отмена параллельных задач](#tasks)

  - [Использование токена отмены для отмены параллельной работы](#tokens)

  - [Использование метода cancel для отмены параллельной работы](#cancel)

  - [Использование исключений для отмены параллельной работы](#exceptions)

- [Отмена параллельных алгоритмов](#algorithms)

- [Когда не следует использовать отмену](#when)

## <a name="parallel-work-trees"></a><a name="trees"></a>Деревья параллельной работы

В PPL для управления детализированными задачами и вычислениями используются задачи и группы задач. Группы задач можно вкладывать в *деревья* параллельной работы. На следующем рисунке показано дерево параллельной работы. На этом рисунке `tg1` и `tg2` представляют группы задач; `t1`, `t2`, `t3`, `t4` и `t5` представляют работы, которые выполняют группы задач.

![Дерево параллельной работы](../../parallel/concrt/media/parallelwork_trees.png "Дерево параллельной работы")

В следующем примере показан код, который необходим для создания дерева на рисунке. В этом примере `tg1` и `tg2` являются объектами [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) ,,, `t1` и `t2` , `t3` `t4` `t5` являются объектами [concurrency::task_handle](../../parallel/concrt/reference/task-handle-class.md) .

[!code-cpp[concrt-task-tree#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_1.cpp)]

Для создания подобного дерева работы можно также использовать класс [concurrency::task_group](reference/task-group-class.md) . Класс [concurrency::Task](../../parallel/concrt/reference/task-class.md) также поддерживает понятие дерева работы. Однако дерево `task` является деревом зависимостей. В дереве `task` следующие задания выполняются после текущих. В дереве группы задач внутренняя работа завершается до внешней работы. Дополнительные сведения о различиях между задачами и группами задач см. в разделе [параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md).

[[Top](#top)]

## <a name="canceling-parallel-tasks"></a><a name="tasks"></a>Отмена параллельных задач

Существует несколько способов отмены параллельной работы. Предпочтительный способ — использование токена отмены. Группы задач также поддерживают метод [concurrency::task_group:: Cancel](reference/task-group-class.md#cancel) и метод [concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) . Еще один способ — создать исключение в теле рабочей функции задачи. Какой бы метод вы ни выбрали, нужно понимать, что отмена не происходит немедленно. Хотя новая работа не запускается при отмене задачи или группы задач, активная работа должна проверять и отвечать на отмену.

Дополнительные примеры отмены параллельных задач см. в статьях [Пошаговое руководство. подключение с помощью задач и HTTP-запросов XML](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md), [Практическое руководство. использование отмены для разбиения из параллельного цикла](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md)и [Практическое руководство. Использование обработки исключений для прерывания работы параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md).

### <a name="using-a-cancellation-token-to-cancel-parallel-work"></a><a name="tokens"></a>Использование токена отмены для отмены параллельной работы

Классы `task`, `task_group` и `structured_task_group` поддерживают отмену посредством использования токенов отмены. PPL определяет классы [concurrency::cancellation_token_source](../../parallel/concrt/reference/cancellation-token-source-class.md) и [concurrency::cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md) для этой цели. При использовании токена отмены, чтобы отменить работу, среда выполнения не запускает новую работу, которая подписывается на этот токен. Работа, которая уже активна, может использовать функцию-член [is_canceled](../../parallel/concrt/reference/cancellation-token-class.md#is_canceled) , чтобы отслеживать токен отмены и останавливаться, когда это возможно.

Чтобы инициировать отмену, вызовите метод [concurrency::cancellation_token_source:: Cancel](reference/cancellation-token-source-class.md#cancel) . Можно реагировать на отмену следующими способами.

- Для `task` объектов используйте функцию [concurrency::cancel_current_task](reference/concurrency-namespace-functions.md#cancel_current_task) . `cancel_current_task` отменяет текущую задачу и любое ее продолжение, основанное на значении. (Он не отменяет *токен* отмены, связанный с задачей или ее продолжениями.)

- Для групп задач и параллельных алгоритмов используйте функцию [concurrency::is_current_task_group_canceling](reference/concurrency-namespace-functions.md#is_current_task_group_canceling) для обнаружения отмены и возврата как можно быстрее из тела задачи, когда эта функция возвращает значение **`true`** . (Не вызывайте `cancel_current_task` из группы задач.)

В следующем примере показан первый базовый шаблон для отмены задачи. Тело задачи время от времени проверяет, нет ли отмены внутри цикла.

[!code-cpp[concrt-task-basic-cancellation#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_2.cpp)]

Функция `cancel_current_task` создает исключение, поэтому нет необходимости явно возвращаться из текущего цикла или функции.

> [!TIP]
> Кроме того, можно вызвать функцию [concurrency::interruption_point](reference/concurrency-namespace-functions.md#interruption_point) , а не `cancel_current_task` .

Необходимо вызвать `cancel_current_task` при реагировании на отмену, поскольку она переводит задачу в отмененное состояние. Если вы вернулись раньше вместо вызова `cancel_current_task`, операция переходит в состояние завершения, и все продолжения, основанные на значении, выполняются.

> [!CAUTION]
> Никогда не вызывайте исключение `task_canceled` из своего кода. Вместо него вызовите метод `cancel_current_task`.

Когда задача завершается в состоянии Canceled, метод [concurrency::Task:: Get](reference/task-class.md#get) вызывает [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md). (С другой стороны, [concurrency::Task:: wait](reference/task-class.md#wait) возвращает [task_status:: Canceled](reference/concurrency-namespace-enums.md#task_group_status) и не создает исключение.) В следующем примере показано это поведение для продолжения на основе задачи. Продолжение на основе задачи вызывается всегда, даже если предшествующая задача отменяется.

[!code-cpp[concrt-task-canceled#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_3.cpp)]

Поскольку продолжения, основанные на значении, наследуют токен их предшествующей задачи, если они не были созданы с явным токеном, продолжения немедленно входят в отмененное состояние, даже если предшествующая задача по-прежнему выполняется. Поэтому любое исключение, создаваемое предшествующей задачей после отмены, не распространяется задачам продолжения. Отмена всегда переопределяет состояние предшествующей задачи. Следующий пример похож на предыдущий, но показывает поведение продолжения, основанного на значении.

[!code-cpp[concrt-task-canceled#2](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_4.cpp)]

> [!CAUTION]
> Если токен отмены не передается `task` конструктору или функции [concurrency::create_task](reference/concurrency-namespace-functions.md#create_task) , эта задача не может быть отменена. Кроме того необходимо передать один и тот же токен отмены конструктору всех вложенных задач (т. е. задач, которые создаются в теле другой задачи), чтобы отменить все задачи одновременно.

Может понадобиться выполнить собственный код, когда токен отмены отменен. Например, если пользователь нажимает кнопку **Отмена** в пользовательском интерфейсе для отмены операции, эту кнопку можно отключить, пока пользователь не запустит другую операцию. В следующем примере показано, как использовать метод [concurrency::cancellation_token:: register_callback](reference/cancellation-token-class.md#register_callback) для регистрации функции обратного вызова, которая выполняется при отмене токена отмены.

[!code-cpp[concrt-task-cancellation-callback#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_5.cpp)]

[Параллелизм задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md) для документов объясняет разницу между продолжениями и задачами, основанными на значениях. Если не предоставить объект `cancellation_token` задаче продолжения, продолжение наследует токен отмены из предшествующей задачи следующими способами.

- Продолжение, основанное на значении, всегда наследует токен отмены предшествующей задачи.

- Продолжение на основе задач никогда не наследует токен отмены предшествующей задачи. Единственный способ сделать продолжение на основе задач отменяемым — явно передать токен отмены.

Эти поведения не изменяются из-за сбоя задачи (той, которая создает исключение). В этом случае продолжение на основе значения отменяется; продолжение на основе задачи не отменено.

> [!CAUTION]
> Задача, которая создается внутри другой задачи (вложенная задача), не наследует токен отмены от родительской задачи. Только продолжение, основанное на значении, наследует токен отмены своей предшествующей задачи.

> [!TIP]
> Используйте метод [concurrency::cancellation_token:: None](reference/cancellation-token-class.md#none) при вызове конструктора или функции, которая принимает `cancellation_token` объект, и вы не хотите, чтобы операция была отменена.

Также можно предоставить токен отмены конструктору объекта `task_group` или `structured_task_group`. Важным аспектом является то, что дочерние группы задач наследуют этот токен отмены. Пример, демонстрирующий эту концепцию с помощью функции [concurrency::run_with_cancellation_token](reference/concurrency-namespace-functions.md#run_with_cancellation_token) , выполняемой для вызова `parallel_for` , см. в разделе [Отмена параллельных алгоритмов](#algorithms) далее в этом документе.

[[Top](#top)]

#### <a name="cancellation-tokens-and-task-composition"></a>Токены отмены и композиция задач

Функции [concurrency::when_all](reference/concurrency-namespace-functions.md#when_all) и [concurrency::when_any](reference/concurrency-namespace-functions.md#when_all) могут помочь составить несколько задач для реализации общих шаблонов. В этом разделе описывается, как эти функции работают с токенами отмены.

Если вы предоставляете токен отмены для `when_all` `when_any` функции и, эта функция отменяется только при отмене маркера отмены или когда одна из задач-участников завершается в отмененном состоянии или вызывает исключение.

Функция `when_all` наследует токен отмены от каждой задачи, формирующей общую операцию, если ей не предоставляется токен отмены. Задача, возвращаемая из `when_all` , отменяется, когда любой из этих токенов отменяется и хотя бы одна из задач-участников еще не запущена или не запущена. Аналогичное поведение возникает, когда одна из задач создает исключение. задача, которая возвращается из, `when_all` немедленно отменяется с этим исключением.

Среда выполнения выбирает токен отмены для задачи, которая возвращается из функции `when_any`, когда эта задача завершается. Если ни одна из участвующих задач не заканчивается в завершенном состоянии или одна или более задач создают исключение, одна из создавших исключение задач выбирается для выполнения `when_any`, а ее токен выбирается как токен для окончательной задачи. Если более чем одна задача заканчивается в завершенном состоянии, задача, возвращаемая `when_any`, заканчивается в завершенном состоянии. Среда выполнения пытается выбрать завершенную задачу, токен которой не отменяется во время завершения, чтобы задача, которая возвращается из `when_any`, не отменялась сразу же, даже если остальные выполняющиеся задачи могут завершиться позднее.

[[Top](#top)]

### <a name="using-the-cancel-method-to-cancel-parallel-work"></a><a name="cancel"></a>Использование метода Cancel для отмены параллельной работы

Методы [concurrency::task_group:: Cancel](reference/task-group-class.md#cancel) и [concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) устанавливают для группы задач отмененное состояние. После вызова метода `cancel` группа задач не начинает выполнение следующих задач. Методы `cancel` могут вызываться несколькими дочерними задачами. Отмененная задача приводит к тому, что методы [concurrency::task_group:: wait](reference/task-group-class.md#wait) и [concurrency::structured_task_group:: wait](reference/structured-task-group-class.md#wait) возвращают [concurrency::Canceled](reference/concurrency-namespace-enums.md#task_group_status).

Если группа задач отменена, вызовы из каждой дочерней задачи в среду выполнения могут вызвать *точку прерывания*, которая заставляет среду выполнения создавать и перехватывать внутренние типы исключений для отмены активных задач. Среда выполнения с параллелизмом не определяет конкретные точки прерывания; они могут возникать в любом вызове среды выполнения. Среда выполнения должна обрабатывать исключения, которые она вызывает, чтобы выполнить отмену. Таким образом, не следует обрабатывать неизвестные исключения в теле задачи.

Если дочерняя задача выполняет длительную операцию и не выполняет вызовы, направленные в среду выполнения, необходимо периодически проверять ее для своевременной отмены и выхода. В следующем примере показывается один из способов определения, когда работа отменяется. Задача `t4` отменяет родительскую группу задач при обнаружении ошибки. Задача `t5` периодически вызывает метод `structured_task_group::is_canceling` для проверки отмены. Если родительская группа задач отменяется, задача `t5` выводит сообщение и завершает работу.

[!code-cpp[concrt-task-tree#6](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_6.cpp)]

В этом примере выполняется проверка на отмену каждых 100-<sup>го</sup> прохода цикла задач. Частота, с которой выполняется проверка отмены, зависит от объема работы, выполняемой задачей, и того, как быстро задачи должны реагировать на отмену.

Если у вас нет доступа к объекту родительской группы задач, вызовите функцию [concurrency::is_current_task_group_canceling](reference/concurrency-namespace-functions.md#is_current_task_group_canceling) , чтобы определить, отменена ли родительская группа задач.

Метод `cancel` влияет только на дочерние задачи. Например, если отменить группу задач `tg1`, показанную на рисунке дерева параллельной работы, будут затронуты все задачи в дереве (`t1`, `t2`, `t3`, `t4` и `t5`). Если отменить вложенную группу задач `tg2`, будут затронуты только задачи `t4` и `t5`.

При вызове метода `cancel` будут также отменены все дочерние группы задач. Однако отмена не повлияет ни на какие родительские объекты группы задач в дереве параллельной работы. В следующих примерах это демонстрируется с опорой на иллюстрацию дерева параллельной работы.

В первом из этих примеров создается рабочая функция для задачи `t4`, которая является дочерним элементом группы задач `tg2`. Эта рабочая функция вызывает функцию `work` в цикле. Если какой-либо вызов `work` завершается неудачно, задача отменяет свою родительскую группу задач. В результате группа задач `tg2` переходит в отмененное состояние, но группа задач `tg1` не отменяется.

[!code-cpp[concrt-task-tree#2](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_7.cpp)]

Второй пример аналогичен первому, но за тем исключением, что задача отменяет группу задач `tg1`. Это влияет на все задачи в дереве (`t1`, `t2`, `t3`, `t4` и `t5`).

[!code-cpp[concrt-task-tree#3](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_8.cpp)]

Класс `structured_task_group` не является потокобезопасным. Таким образом, дочерняя задача, которая вызывает метод своего родительского объекта `structured_task_group`, приводит к непредсказуемому поведению. Исключениями из этого правила являются `structured_task_group::cancel` методы и [concurrency::structured_task_group:: is_canceling](reference/structured-task-group-class.md#is_canceling) . Дочерняя задача может вызывать эти методы для отмены родительской группы задач и проверки на предмет отмены.

> [!CAUTION]
> Хотя можно использовать токен отмены, чтобы отменить работу, выполняемую группой задач, которая выполняется как дочерний элемент объекта `task`, невозможно использовать методы `task_group::cancel` или `structured_task_group::cancel`, чтобы отменить объекты `task`, выполняемые в группе задач.

[[Top](#top)]

### <a name="using-exceptions-to-cancel-parallel-work"></a><a name="exceptions"></a>Использование исключений для отмены параллельной работы

Использование токенов отмены и метода `cancel` более эффективно, чем обработка исключений при отмене дерева параллельной работы. Токены отмены и метод `cancel` отменяют задачу и все дочерние задачи сверху вниз. И наоборот, обработка исключений работает в режиме «снизу вверх» и необходимо отменять каждую дочернюю группу задач независимо, поскольку исключение распространяется вверх. В разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md) объясняется, как среда выполнения с параллелизмом использует исключения для сообщения об ошибках. Однако не все исключения указывают на ошибку. Например, алгоритм поиска может отменить связанную задачу при нахождении результата. Тем не менее, как упоминалось ранее, обработка исключений менее эффективна, чем использование метода `cancel` для отмены параллельной работы.

> [!CAUTION]
> Рекомендуется использовать исключения для отмены параллельной работы только при необходимости. Токены отмены и методы `cancel` группы задач более эффективны и менее подвержены возникновению ошибок.

При создании исключения в теле рабочей функции, передаваемой в группу задач, среда выполнения сохраняет это исключение и маршалирует его в контекст, ожидающий завершения этой группы задач. Как и в случае использования метода `cancel`, среда выполнения удаляет любые задачи, которые еще не были запущены, и не принимает новые задачи.

Третий пример напоминает второй, за исключением того, что задача `t4` создает исключение для отмены группы задач `tg2`. В этом примере используется **`try`** - **`catch`** блок для проверки отмены, когда группа задач `tg2` ожидает завершения ее дочерних задач. Как и в первом примере, в результате группа задач `tg2` переходит в отмененное состояние, но группа задач `tg1` не отменяется.

[!code-cpp[concrt-task-tree#4](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_9.cpp)]

В четвертом примере используется обработка исключений для отмены всего дерева работы. В этом примере перехватывается исключение, когда группа задач `tg1` ожидает завершения своих дочерних задач вместо группы задач `tg2`, ожидающей своих дочерних задач. Как и во втором примере, это приводит к переходу в отмененное состояние обеих групп задач в дереве, `tg1` и `tg2`.

[!code-cpp[concrt-task-tree#5](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_10.cpp)]

Так как методы `task_group::wait` и `structured_task_group::wait` вызываются, когда дочерняя задача создает исключение, вы не получите от них возвращаемое значение.

[[Top](#top)]

## <a name="canceling-parallel-algorithms"></a><a name="algorithms"></a>Отмена параллельных алгоритмов

Параллельные алгоритмы в PPL (например, `parallel_for`) основаны на группах задач. Таким образом, многие из тех же способов можно использовать для для отмены параллельного алгоритма.

Следующие примеры иллюстрируют несколько способов отмены параллельного алгоритма.

В следующем примере функция `run_with_cancellation_token` используется для вызова алгоритма `parallel_for`. Функция `run_with_cancellation_token` принимает в качестве аргумента токен отмены и одновременно вызывает предоставленную рабочую функцию. Поскольку параллельные алгоритмы строятся на задачах, они наследуют токен отмены родительской задачи. Поэтому `parallel_for` может реагировать на отмену.

[!code-cpp[concrt-cancel-parallel-for#1](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_11.cpp)]

В следующем примере используется метод [concurrency::structured_task_group:: run_and_wait](reference/structured-task-group-class.md#run_and_wait) для вызова `parallel_for` алгоритма. Метод `structured_task_group::run_and_wait` ожидает завершения предоставленной задачи. Объект `structured_task_group` позволяет рабочей функции отменить задачу.

[!code-cpp[concrt-task-tree#7](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_12.cpp)]

В этом примере формируются следующие данные:

```Output
The task group status is: canceled.
```

В следующем примере используется обработка исключений для отмены цикла `parallel_for`. Среда выполнения маршалирует исключение в вызывающий контекст.

[!code-cpp[concrt-task-tree#9](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_13.cpp)]

В этом примере формируются следующие данные:

```Output
Caught 50
```

В следующем примере используется логический флаг для координации отмены в цикле `parallel_for` Каждая задача выполняется, поскольку в этом примере не используется метод `cancel` или обработка исключений, чтобы отменить весь набор задач. Таким образом, этот метод может использовать больше вычислительных ресурсов, чем механизм отмены.

[!code-cpp[concrt-task-tree#8](../../parallel/concrt/codesnippet/cpp/cancellation-in-the-ppl_14.cpp)]

Каждый метод отмены имеет свои преимущества по сравнению с другими. Выбирайте метод, который соответствует вашим конкретным требованиям.

[[Top](#top)]

## <a name="when-not-to-use-cancellation"></a><a name="when"></a>Когда не следует использовать отмену

Использование отмены подходит в тех случаях, когда каждый член группы связанных задач может выполнить выход своевременно. Однако существуют некоторые сценарии, в которых отмена может не подойти для вашего приложения. Например, поскольку отмена задач осуществляется совместно, весь набор задач не будет отменен, если одна из задач заблокирована. Например, если одна задача еще не запущена, но разблокирует другую активную задачу, эта задача не запустится, если отменяется группа задач. Это может вызвать взаимоблокировку в приложении. Второй пример, когда использование отмены может не подойти: задача отменяется, но ее дочерняя задача выполняет важную операцию, например высвобождение ресурса. Так как при отмене родительской задачи отменяется весь набор задач, эта операция не будет выполнена. Пример, иллюстрирующий этот момент, см. в разделе понимание того, [как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) в рекомендациях в библиотеке параллельных шаблонов.

[[Top](#top)]

## <a name="related-topics"></a>См. также

|Заголовок|Описание|
|-----------|-----------------|
|[Как прервать выполнение из параллельного цикла с помощью отмены](../../parallel/concrt/how-to-use-cancellation-to-break-from-a-parallel-loop.md)|Показывается, как использовать отмену для реализации алгоритма параллельного поиска.|
|[Как использовать обработку исключений для разрыва из параллельного цикла](../../parallel/concrt/how-to-use-exception-handling-to-break-from-a-parallel-loop.md)|Здесь приводятся способы использования класса `task_group` для записи алгоритма поиска для базовой структуры дерева.|
|[Обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md)|В этом разделе описывается обработка в среде выполнения исключений, созданных группами задач, упрощенными задачами и асинхронными агентами, а также способы реагирования на исключения в приложениях.|
|[Параллельное выполнение задач](../../parallel/concrt/task-parallelism-concurrency-runtime.md)|В этом разделе описывается, как задачи связаны с группами задач и как можно использовать структурированные и неструктурированные задачи в приложениях.|
|[Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md)|В этом разделе описываются параллельные алгоритмы, одновременно выполняющие работу с коллекциями данных.|
|[Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)|Общие сведения о библиотеке параллельных задач.|

## <a name="reference"></a>Справочник

[Класс Task (среда выполнения с параллелизмом)](../../parallel/concrt/reference/task-class.md)

[Класс cancellation_token_source](../../parallel/concrt/reference/cancellation-token-source-class.md)

[Класс cancellation_token](../../parallel/concrt/reference/cancellation-token-class.md)

[Класс task_group](reference/task-group-class.md)

[Класс structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md)

[Функция parallel_for](reference/concurrency-namespace-functions.md#parallel_for)
