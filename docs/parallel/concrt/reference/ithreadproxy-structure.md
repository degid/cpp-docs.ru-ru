---
title: Структура IThreadProxy
ms.date: 11/04/2016
f1_keywords:
- IThreadProxy
- CONCRTRM/concurrency::IThreadProxy
- CONCRTRM/concurrency::IThreadProxy::IThreadProxy::GetId
- CONCRTRM/concurrency::IThreadProxy::IThreadProxy::SwitchOut
- CONCRTRM/concurrency::IThreadProxy::IThreadProxy::SwitchTo
- CONCRTRM/concurrency::IThreadProxy::IThreadProxy::YieldToSystem
helpviewer_keywords:
- IThreadProxy structure
ms.assetid: feb89241-a555-4e61-ad48-40add54daeca
ms.openlocfilehash: fc2fb2df06225a5c963fe39178c1b4a10f77953d
ms.sourcegitcommit: c123cc76bb2b6c5cde6f4c425ece420ac733bf70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/14/2020
ms.locfileid: "81368130"
---
# <a name="ithreadproxy-structure"></a>Структура IThreadProxy

Абстракция для потока выполнения. В зависимости от ключа политики `SchedulerType` созданного планировщика, диспетчер ресурсов предоставит прокси-поток, поддерживаемый обычным потоком Win32 или потоком планировщика пользовательского режима (UMS). Потоки UMS поддерживаются в 64-разрядных операционных системах Windows 7 и более поздних версий.

## <a name="syntax"></a>Синтаксис

```cpp
struct IThreadProxy;
```

## <a name="members"></a>Участники

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[IThreadProxy::GetId](#getid)|Возвращает уникальный идентификатор для прокси потока.|
|[IThreadProxy::SwitchOut](#switchout)|Отсоединяет контекст от базового корневого виртуального процессора.|
|[IThreadProxy::SwitchTo](#switchto)|Выполняет кооперативный контекст, переключаясь из контекста выполнения в настоящее время в другой.|
|[IThreadProxy::YieldtoSystem](#yieldtosystem)|Позволяет вызвавшему потоку передать выполнение другому потоку, готовому к использованию на текущем процессоре. Операционная система выбирает следующий поток для выполнения.|

## <a name="remarks"></a>Примечания

Прокси-сообщения потоков соединяются с контекстами выполнения, представленными интерфейсом `IExecutionContext` как средством диспетчеризации работы.

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`IThreadProxy`

## <a name="requirements"></a>Требования

**Заголовок:** concrtrm.h

**Название:** параллелизм

## <a name="ithreadproxygetid-method"></a><a name="getid"></a>IThreadProxy::GetId метод

Возвращает уникальный идентификатор для прокси потока.

```cpp
virtual unsigned int GetId() const = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Уникальный идентификатор несбыванного.

## <a name="ithreadproxyswitchout-method"></a><a name="switchout"></a>IThreadProxy::SwitchOut Метод

Отсоединяет контекст от базового корневого виртуального процессора.

```cpp
virtual void SwitchOut(SwitchingProxyState switchState = Blocking) = 0;
```

### <a name="parameters"></a>Параметры

*switchState*<br/>
Указывает состояние прокси потока, который выполняет коммутатор. Параметр типа `SwitchingProxyState`.

### <a name="remarks"></a>Примечания

Используйте `SwitchOut` при необходимости отсоединения контекста от корневого виртуального процессора, на котором он выполняется, по любой причине. В зависимости от значения, переданного параметру `switchState`, и от того, выполняется ли он на корневом виртуальном процессоре, вызов немедленно вернет управление или заблокирует прокси-поток, связанный с контекстом. Вызов `SwitchOut` с параметром со значением `Idle` является ошибочным. Это приведет к [invalid_argument](../../../standard-library/invalid-argument-class.md) исключения.

Метод `SwitchOut` полезен, когда требуется сократить число корневых виртуальных процессоров у вашего планировщика либо потому, что диспетчер ресурсов рекомендовал так сделать, либо потому, что вы запросили корневой виртуальный процессор, который временно переподписан, и завершили работу с ним. В этом случае вы должны вызвать метод [IVirtualProcessorRoot::Удалить](iexecutionresource-structure.md#remove) на корень виртуального процессора, прежде чем звонить `SwitchOut` с набором `switchState` `Blocking`параметра. Это заблокирует прокси-поток и возобновит выполнение, когда другой корневой виртуальный процессор в планировщике будет доступен для его выполнения. Прокси-сервер блокирующего потока можно `SwitchTo` возобновить, позвонив функции для переключения в контекст выполнения этого прокси-потока. Вы также можете возобновить прокси потока, используя связанный с ним контекст для активации корней виртуального процессора. Для получения дополнительной информации о том, как это сделать, [см.](ivirtualprocessorroot-structure.md#activate)

`SwitchOut` также может использоваться, когда требуется повторная инициализация виртуального процессора, чтобы его можно было активировать в будущем либо при блокировке прокси-потока, либо при временном отсоединении его от корневого виртуального процессора, на котором он выполняется, и от планировщика, который обслуживается потоком. Используйте `SwitchOut` с параметром `switchState` со значением `Blocking`, если необходимо заблокировать прокси-поток. Позже его можно будет возобновить с помощью или `SwitchTo`, или `IVirtualProcessorRoot::Activate`, как указано выше. Используйте `SwitchOut` со значением `Nesting` для этого параметра, если необходимо временно отсоединить этот прокси-поток от корневого виртуального процессора, на котором он выполняется, и от планировщика, с которым связан виртуальный процессор. Вызов `SwitchOut` с параметром `switchState` со значением `Nesting` при выполнении на корневом виртуальном процессоре вызовет повторную инициализацию корня и продолжение работы текущего прокси-потока, когда это не будет требоваться. Прокси-сервер потока, как считается, покинул планировщик до тех пор, пока `Blocking` он не вызывает [метод IThreadProxy::SwitchOut](#switchout) с на более поздний момент времени. Второй вызов `SwitchOut` со значением параметра `Blocking` предназначен для возврата контекста в заблокированное состояние, чтобы он мог быть возобновлен с помощью или `SwitchTo`, или `IVirtualProcessorRoot::Activate` в планировщике, от которого его отсоединили. Поскольку он не выполнялся на корневом виртуальном процессоре, повторная инициализация не происходит.

Повторно инициализированный корневой виртуальный процессор ничем не отличается от абсолютно нового виртуального процессора, выделенного диспетчером ресурсов планировщику. Его можно использовать для выполнения, активировав его с контекстом выполнения с помощью `IVirtualProcessorRoot::Activate`.

`SwitchOut`должен быть вызван `IThreadProxy` на интерфейс, представляющий в настоящее время выполнение потока или результаты не определены.

В библиотеках и заголовках, поставляемых вместе с Visual Studio 2010, этот метод не принимает параметров и не инициализирует повторно корневой виртуальный процессор. Для сохранения старого поведения значение параметра по умолчанию задано как `Blocking`.

## <a name="ithreadproxyswitchto-method"></a><a name="switchto"></a>IThreadProxy::SwitchTo Метод

Выполняет кооперативный контекст, переключаясь из контекста выполнения в настоящее время в другой.

```cpp
virtual void SwitchTo(
    _Inout_ IExecutionContext* pContext,
    SwitchingProxyState switchState) = 0;
```

### <a name="parameters"></a>Параметры

*pContext*<br/>
Контекст выполнения для совместного переключения.

*switchState*<br/>
Указывает состояние прокси потока, который выполняет коммутатор. Параметр типа `SwitchingProxyState`.

### <a name="remarks"></a>Примечания

Используйте этот метод для переключения из контекста выполнения в другой, из метода [IExecutionContext::Dispatch](iexecutioncontext-structure.md#dispatch) первого контекста выполнения. Метод связывает контекст `pContext` выполнения с прокси-сервером потока, если он еще не связан с ним. Владение текущим прокси потока определяется значением, `switchState` указанным для аргумента.

Используйте `Idle` значение, когда требуется вернуть прокси-сервер выполнения потока в настоящее время менеджеру ресурсов. Вызов `SwitchTo` с `switchState` набором `Idle` параметров приведет `pContext` к запуску контекста выполнения на базовом ресурсе выполнения. Владение этим прокси-сервером потока передается диспетчеру ресурсов, и ожидается, что `SwitchTo` вскоре после возврата вы будете возвращаться из контекста `Dispatch` выполнения, чтобы завершить передачу. Контекст выполнения, который отправлял прокси потока, отмежевался от прокси потока, и планировщик может свободно использовать его или уничтожить по мере того, как он считает нужным.

Используйте `Blocking` значение, когда вы хотите, чтобы прокси-сервер потока вошел в заблокированное состояние. Вызов `SwitchTo` с `switchState` набором `Blocking` параметров приведет `pContext` к запуску контекста выполнения и блокировке прокси текущего потока до его возобновления. Планировщик сохраняет право собственности на прокси потока, когда `Blocking` прокси потока находится в состоянии. Прокси-сервер блокирующего потока можно `SwitchTo` возобновить, позвонив функции для переключения в контекст выполнения этого прокси-потока. Вы также можете возобновить прокси потока, используя связанный с ним контекст для активации корней виртуального процессора. Для получения дополнительной информации о том, как это сделать, [см.](ivirtualprocessorroot-structure.md#activate)

Используйте `Nesting` значение, когда вы хотите временно отсоединить этот прокси-сервер потока от исходного корня виртуального процессора, на который он работает, и планировщика, для него он отправляет работу. Вызов `SwitchTo` с `switchState` набором `Nesting` параметров приведет `pContext` к запуску контекста выполнения, а текущий прокси потока также продолжает исполнять без необходимости в корне виртуального процессора. Прокси-сервер потока, как считается, покинул планировщик до тех пор, пока он не вызывает метод [IThreadProxy::SwitchOut](#switchout) на более поздний момент времени. Метод `IThreadProxy::SwitchOut` может блокировать прокси потока до тех пор, пока не будет доступен корень виртуального процессора для его переноса.

`SwitchTo`должен быть вызван `IThreadProxy` на интерфейс, представляющий в настоящее время выполнение потока или результаты не определены. Функция бросает, `invalid_argument` если `pContext` параметр `NULL`установлен на .

## <a name="ithreadproxyyieldtosystem-method"></a><a name="yieldtosystem"></a>IThreadProxy::Метод YieldtoSystem

Позволяет вызвавшему потоку передать выполнение другому потоку, готовому к использованию на текущем процессоре. Операционная система выбирает следующий поток для выполнения.

```cpp
virtual void YieldToSystem() = 0;
```

### <a name="remarks"></a>Примечания

При вызове прокси потока, поддерживаемого `YieldToSystem` обычным потоком Windows, `SwitchToThread`он ведет себя точно так же, как функция Windows. Однако при вызове из потоков, управляемых режимом пользователя `SwitchToThread` (UMS), функция делегирует задачу выбора следующего потока для запуска в планировщик пользовательского режима, а не на операционную систему. Для достижения желаемого эффекта перехода на другой готовый `YieldToSystem`поток в системе используйте.

`YieldToSystem`должен быть вызван `IThreadProxy` на интерфейс, представляющий в настоящее время выполнение потока или результаты не определены.

## <a name="see-also"></a>См. также раздел

[Пространство имен concurrency](concurrency-namespace.md)<br/>
[Структура IExecutionContext](iexecutioncontext-structure.md)<br/>
[Структура IScheduler](ischeduler-structure.md)<br/>
[Структура IVirtualProcessorRoot](ivirtualprocessorroot-structure.md)
