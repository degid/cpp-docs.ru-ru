---
title: Класс task_group
ms.date: 07/20/2018
f1_keywords:
- task_group
- PPL/concurrency::task_group
- PPL/concurrency::task_group::task_group
helpviewer_keywords:
- task_group class
ms.openlocfilehash: 4d11a7fc25d95884418a3062721df75cc11be520
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87224959"
---
# <a name="task_group-class"></a>Класс task_group

Класс `task_group` представляет коллекцию параллельной работы, для которой возможно ожидание или отмена.

## <a name="syntax"></a>Синтаксис

```cpp
class task_group;
```

## <a name="members"></a>Участники

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[task_group](#ctor)|Перегружен. Создает новый объект `task_group`.|
|[Деструктор ~ task_group](#dtor)|Уничтожает объект `task_group` . Ожидается вызов `wait` `run_and_wait` метода или для объекта до выполнения деструктора, если только деструктор не выполняется как результат очистки стека из-за исключения.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[cancel](#cancel)|Предпринимает попытку отменить поддерево работы с корнем в этой группе задач. Если возможно, все задачи, запланированные в группе задач, будут отменены транзитивно.|
|[is_canceling](#is_canceling)|Информирует вызывающий объект о том, находится ли группа задач в данный момент в процессе отмены. Это не обязательно означает, что `cancel` метод был вызван для `task_group` объекта (хотя, безусловно, этот метод должен быть возвращен **`true`** ). Это может быть случай, когда `task_group` объект выполняется в строке, а группа задач в рабочем дереве была отменена. В таких случаях, где среда выполнения может заранее определить, что отмена будет передаваться через этот `task_group` объект, **`true`** также будет возвращена.|
|[запуска](#run)|Перегружен. Планирует задачу для `task_group` объекта. Если `task_handle` объект передается в качестве параметра в `run` , вызывающий объект отвечает за управление временем существования `task_handle` объекта. Версия метода, которая принимает ссылку на объект функции в качестве параметра, включает выделение кучи внутри среды выполнения, что может выполняться менее эффективно, чем использование версии, которая принимает ссылку на `task_handle` объект. Версия, принимающая параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.|
|[run_and_wait](#run_and_wait)|Перегружен. Планирует выполнение задачи в вызывающем контексте с помощью `task_group` объекта для полной поддержки отмены. Затем функция ожидает `task_group` завершения или отмены любой работы над объектом. Если `task_handle` объект передается в качестве параметра в `run_and_wait` , вызывающий объект отвечает за управление временем существования `task_handle` объекта.|
|[ожидания](#wait)|Ожидает завершения или отмены любой работы над `task_group` объектом.|

## <a name="remarks"></a>Примечания

В отличие от сильно ограниченного `structured_task_group` класса, `task_group` класс является гораздо более общей конструкцией. В нем отсутствуют ограничения, описанные в [structured_task_group](structured-task-group-class.md). `task_group`объекты можно безопасно использовать в потоках и использовать в произвольных направлениях. Недостатком `task_group` конструкции является то, что она может не выполняться, а также `structured_task_group` конструкцию для задач, выполняющих небольшие объемы работы.

Дополнительные сведения см. в разделе [параллелизм задач](../task-parallelism-concurrency-runtime.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`task_group`

## <a name="requirements"></a>Требования

**Заголовок:** PPL.h

**Пространство имен:** concurrency

## <a name="cancel"></a><a name="cancel"></a>Отмена

Предпринимает попытку отменить поддерево работы с корнем в этой группе задач. Если возможно, все задачи, запланированные в группе задач, будут отменены транзитивно.

```cpp
void cancel();
```

### <a name="remarks"></a>Примечания

Дополнительные сведения см. в разделе [Отмена](../cancellation-in-the-ppl.md).

## <a name="is_canceling"></a><a name="is_canceling"></a>is_canceling

Информирует вызывающий объект о том, находится ли группа задач в данный момент в процессе отмены. Это не обязательно означает, что `cancel` метод был вызван для `task_group` объекта (хотя, безусловно, этот метод должен быть возвращен **`true`** ). Это может быть случай, когда `task_group` объект выполняется в строке, а группа задач в рабочем дереве была отменена. В таких случаях, где среда выполнения может заранее определить, что отмена будет передаваться через этот `task_group` объект, **`true`** также будет возвращена.

```cpp
bool is_canceling();
```

### <a name="return-value"></a>Возвращаемое значение

Указывает, `task_group` находится ли объект в процессе отмены (или гарантированно будет вскоре).

### <a name="remarks"></a>Примечания

Дополнительные сведения см. в разделе [Отмена](../cancellation-in-the-ppl.md).

## <a name="run"></a><a name="run"></a>запуска

Планирует задачу для `task_group` объекта. Если `task_handle` объект передается в качестве параметра в `run` , вызывающий объект отвечает за управление временем существования `task_handle` объекта. Версия метода, которая принимает ссылку на объект функции в качестве параметра, включает выделение кучи внутри среды выполнения, что может выполняться менее эффективно, чем использование версии, которая принимает ссылку на `task_handle` объект. Версия, принимающая параметр `_Placement`, заставляет задачу стремиться к выполнению в расположении, указанном этим параметром.

```cpp
template<
   typename _Function
>
void run(
   const _Function& _Func
);

template<
   typename _Function
>
void run(
   const _Function& _Func,
   location& _Placement
);

template<
   typename _Function
>
void run(
   task_handle<_Function>& _Task_handle
);

template<
   typename _Function
>
void run(
   task_handle<_Function>& _Task_handle,
   location& _Placement
);
```

### <a name="parameters"></a>Параметры

*_Function*<br/>
Тип объекта функции, который будет вызываться для выполнения тела маркера задачи.

*_Func*<br/>
Функция, которая будет вызываться для вызова текста задачи. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()` .

*_Placement*<br/>
Ссылка на расположение, в котором должна выполняться задача, представленная параметром `_Func`.

*_Task_handle*<br/>
Маркер запланированной работы. Обратите внимание, что вызывающий объект отвечает за время существования этого объекта. Среда выполнения продолжит ожидать, пока для `wait` `run_and_wait` этого объекта не будет вызван метод или `task_group` .

### <a name="remarks"></a>Примечания

Среда выполнения планирует выполнение предоставленной рабочей функции позднее, что может быть после возврата вызывающей функции. Этот метод использует объект [task_handle](task-handle-class.md) для хранения копии предоставленной рабочей функции. Таким образом, любые изменения состояния, происходящие в объекте функции, который передается в этот метод, не будут отображаться в копии этого объекта функции. Кроме того, убедитесь, что время существования всех объектов, передаваемых по указателю или по ссылке на рабочую функцию, остается допустимым до тех пор, пока Рабочая функция не вернет значение.

Если `task_group` деструкторы являются результатом очистки стека из-за исключения, нет необходимости гарантировать, что был сделан вызов `wait` `run_and_wait` метода или. В этом случае деструктор будет отменяться соответствующим образом и ожидать завершения задачи, представленной `_Task_handle` параметром.

Метод вызывает исключение [invalid_multiple_scheduling](invalid-multiple-scheduling-class.md) , если обработчик задач, заданный `_Task_handle` параметром, уже был запланирован в объекте группы задач с помощью `run` метода, и в данной группе задач не был выполнен промежуточный вызов `wait` метода или `run_and_wait` .

## <a name="run_and_wait"></a><a name="run_and_wait"></a>run_and_wait

Планирует выполнение задачи в вызывающем контексте с помощью `task_group` объекта для полной поддержки отмены. Затем функция ожидает `task_group` завершения или отмены любой работы над объектом. Если `task_handle` объект передается в качестве параметра в `run_and_wait` , вызывающий объект отвечает за управление временем существования `task_handle` объекта.

```cpp
template<
   class _Function
>
task_group_status run_and_wait(
   task_handle<_Function>& _Task_handle
);

template<
   class _Function
>
task_group_status run_and_wait(
   const _Function& _Func
);
```

### <a name="parameters"></a>Параметры

*_Function*<br/>
Тип объекта функции, который будет вызван для выполнения основной части задачи.

*_Task_handle*<br/>
Обработчик для задачи, который будет выполняться встроенным в контекст вызывающего. Обратите внимание, что вызывающий объект отвечает за время существования этого объекта. Среда выполнения будет продолжать ожидать, пока `run_and_wait` метод не завершит выполнение.

*_Func*<br/>
Функция, которая будет вызываться для вызова текста работы. Это может быть лямбда-выражение или другой объект, который поддерживает версию оператора вызова функции с сигнатурой `void operator()()` .

### <a name="return-value"></a>Возвращаемое значение

Значение, указывающее, было ли выполнено ожидание или отменена группа задач из-за явной операции отмены или исключения, вызываемого одной из задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md#task_group_status).

### <a name="remarks"></a>Примечания

Обратите внимание, что одна или несколько задач, запланированных на этот `task_group` объект, могут выполняться встроенным в контекст вызывающего.

Если одна или несколько задач, запланированных на этот `task_group` объект, вызывают исключение, среда выполнения выберет одно из таких исключений и распространит его из вызова `run_and_wait` метода.

При возврате из `run_and_wait` метода `task_group` объекта среда выполнения сбрасывает объект в исходное состояние, в котором его можно использовать повторно. Это включает случай, когда `task_group` объект был отменен.

В неисключительном пути выполнения у вас есть требование вызывать этот метод или `wait` метод перед деструктором `task_group` выполнения.

## <a name="task_group"></a><a name="ctor"></a>task_group

Создает новый объект `task_group`.

```cpp
task_group();

task_group(
   cancellation_token _CancellationToken
);
```

### <a name="parameters"></a>Параметры

*_CancellationToken*<br/>
Токен отмены для связывания с этой группой задач. Группа задач будет отменена, когда будет отменен токен.

### <a name="remarks"></a>Примечания

Конструктор, который принимает токен отмены, создает `task_group`, которая будет отменена, когда будет отменен источник, связанный с этим токеном. Предоставление явного токена отмены также изолирует эту группу задач от участия в неявной отмене из родительской группы с другим токеном или без токена.

## <a name="task_group"></a><a name="dtor"></a>~ task_group

Уничтожает объект `task_group` . Ожидается вызов `wait` `run_and_wait` метода или для объекта до выполнения деструктора, если только деструктор не выполняется как результат очистки стека из-за исключения.

```cpp
~task_group();
```

### <a name="remarks"></a>Примечания

Если деструктор выполняется как результат обычного выполнения (например, если не используется Очистка стека из-за исключения) и ни один из методов и `wait` не `run_and_wait` вызван, деструктор может вызвать исключение [missing_wait](missing-wait-class.md) .

## <a name="wait"></a><a name="wait"></a>ожидания

Ожидает завершения или отмены любой работы над `task_group` объектом.

```cpp
task_group_status wait();
```

### <a name="return-value"></a>Возвращаемое значение

Значение, указывающее, было ли выполнено ожидание или отменена группа задач из-за явной операции отмены или исключения, вызываемого одной из задач. Дополнительные сведения см. в разделе [task_group_status](concurrency-namespace-enums.md#task_group_status).

### <a name="remarks"></a>Примечания

Обратите внимание, что одна или несколько задач, запланированных на этот `task_group` объект, могут выполняться встроенным в контекст вызывающего.

Если одна или несколько задач, запланированных на этот `task_group` объект, вызывают исключение, среда выполнения выберет одно из таких исключений и распространит его из вызова `wait` метода.

Вызов `wait` для `task_group` объекта сбрасывает его в исходное состояние, в котором его можно использовать повторно. Это включает случай, когда `task_group` объект был отменен.

В неисключительном пути выполнения у вас есть требование вызывать этот метод или `run_and_wait` метод перед деструктором `task_group` выполнения.

## <a name="see-also"></a>См. также статью

[Пространство имен Concurrency](concurrency-namespace.md)<br/>
[Класс structured_task_group](structured-task-group-class.md)<br/>
[Класс task_handle](task-handle-class.md)
