---
title: Класс CurrentScheduler
ms.date: 11/04/2016
f1_keywords:
- CurrentScheduler
- CONCRT/concurrency::CurrentScheduler
- CONCRT/concurrency::CurrentScheduler::Create
- CONCRT/concurrency::CurrentScheduler::CreateScheduleGroup
- CONCRT/concurrency::CurrentScheduler::Detach
- CONCRT/concurrency::CurrentScheduler::Get
- CONCRT/concurrency::CurrentScheduler::GetNumberOfVirtualProcessors
- CONCRT/concurrency::CurrentScheduler::GetPolicy
- CONCRT/concurrency::CurrentScheduler::Id
- CONCRT/concurrency::CurrentScheduler::IsAvailableLocation
- CONCRT/concurrency::CurrentScheduler::RegisterShutdownEvent
- CONCRT/concurrency::CurrentScheduler::ScheduleTask
helpviewer_keywords:
- CurrentScheduler class
ms.assetid: 31c20e0e-4cdf-49b4-8220-d726130aad2b
ms.openlocfilehash: 6bf61af9ff55722553353a045c87501dbd27fad9
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2020
ms.locfileid: "79427413"
---
# <a name="currentscheduler-class"></a>Класс CurrentScheduler

Представляет абстракцию для текущего планировщика, связанного с вызывающим контекстом.

## <a name="syntax"></a>Синтаксис

```cpp
class CurrentScheduler;
```

## <a name="members"></a>Члены

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[Создание](#create)|Создает новый планировщик, поведение которого описывается параметром `_Policy` и прикрепляет его к вызывающему контексту. Вновь созданный планировщик станет текущим планировщиком для вызывающего контекста.|
|[CreateScheduleGroup](#createschedulegroup)|Перегружен. Создает новую группу расписаний в планировщике, связанном с вызывающим контекстом. Версия, которая принимает параметр `_Placement` вызывает смещение задач в вновь созданной группе расписаний в направлении выполнения в расположении, указанном этим параметром.|
|[Отсоединить](#detach)|Отсоединяет текущий планировщик от вызывающего контекста и восстанавливает ранее присоединенный планировщик в качестве текущего планировщика, если он существует. После возврата из этого метода контекст вызова управляется планировщиком, который ранее был присоединен к контексту с помощью метода `CurrentScheduler::Create` или `Scheduler::Attach`.|
|[Get](#get)|Возвращает указатель на планировщик, связанный с контекстом вызова, который также называется текущим планировщиком.|
|[жетнумберофвиртуалпроцессорс](#getnumberofvirtualprocessors)|Возвращает текущее число виртуальных процессоров для планировщика, связанного с контекстом вызова.|
|[GetPolicy](#getpolicy)|Возвращает копию политики, с которой был создан текущий планировщик.|
|[Id](#id)|Возвращает уникальный идентификатор текущего планировщика.|
|[исаваилаблелокатион](#isavailablelocation)|Определяет, доступно ли данное расположение в текущем планировщике.|
|[регистершутдовневент](#registershutdownevent)|Приводит к тому, что дескриптор событий Windows, переданный в параметре `_ShutdownEvent`, получает сигнал, когда планировщик, связанный с текущим контекстом, завершает работу и удаляет себя. В момент получения сигнала о событии все запланированные работы планировщика завершены. С помощью этого метода можно зарегистрировать несколько событий завершения работы.|
|[ScheduleTask](#scheduletask)|Перегружен. Планирует задачу с невысокой плотностью в планировщике, связанном с вызывающим контекстом. Упрощенная задача будет размещена в группе расписаний, определенной средой выполнения. Версия, принимающая параметр `_Placement`, склоняет задачу к выполнению в указанном расположении.|

## <a name="remarks"></a>Примечания

Если планировщик (см. раздел [Scheduler](scheduler-class.md)), связанный с контекстом вызова, не существует, многие методы в классе `CurrentScheduler` приведут к вложению планировщика процесса по умолчанию. Это может также предположить, что планировщик процесса по умолчанию создается во время такого вызова.

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`CurrentScheduler`

## <a name="requirements"></a>Требования

**Заголовок:** ConcRT.h

**Пространство имен:** concurrency

## <a name="create"></a> Создание

Создает новый планировщик, поведение которого описывается параметром `_Policy` и прикрепляет его к вызывающему контексту. Вновь созданный планировщик станет текущим планировщиком для вызывающего контекста.

```cpp
static void __cdecl Create(const SchedulerPolicy& _Policy);
```

### <a name="parameters"></a>Параметры

*_Policy*<br/>
Политика планировщика, которая описывает поведение только что созданного планировщика.

### <a name="remarks"></a>Примечания

При присоединении планировщика к контексту вызова неявно накладывается счетчик ссылок на планировщик.

После создания планировщика с помощью метода `Create` необходимо вызвать метод [CurrentScheduler::D етач](#detach) в некоторый момент в будущем, чтобы разрешить завершение работы планировщика.

Если этот метод вызывается из контекста, уже присоединенного к другому планировщику, существующий планировщик запоминается как предыдущий планировщик, а вновь созданный планировщик становится текущим планировщиком. При последующем вызове метода `CurrentScheduler::Detach` предыдущий планировщик восстанавливается как текущий планировщик.

Этот метод может вызывать различные исключения, в том числе [scheduler_resource_allocation_error](scheduler-resource-allocation-error-class.md) и [invalid_scheduler_policy_value](invalid-scheduler-policy-value-class.md).

## <a name="createschedulegroup"></a>CreateScheduleGroup

Создает новую группу расписаний в планировщике, связанном с вызывающим контекстом. Версия, которая принимает параметр `_Placement` вызывает смещение задач в вновь созданной группе расписаний в направлении выполнения в расположении, указанном этим параметром.

```cpp
static ScheduleGroup* __cdecl CreateScheduleGroup();

static ScheduleGroup* __cdecl CreateScheduleGroup(location& _Placement);
```

### <a name="parameters"></a>Параметры

*_Placement*<br/>
Ссылка на расположение, в котором задачи в группе расписаний будут смещены в сторону выполнения в.

### <a name="return-value"></a>Возвращаемое значение

Указатель на только что созданную группу расписаний. На этом `ScheduleGroup`ном объекте размещено начальное количество ссылок.

### <a name="remarks"></a>Примечания

В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.

При завершении планирования работы для группы расписаний необходимо вызвать метод [Release](schedulegroup-class.md#release) . Планировщик удалит группу расписаний после завершения всей работы в очереди.

Обратите внимание, что если вы явно создали этот планировщик, необходимо освободить все ссылки на группы планирования в нем, прежде чем освободить ссылку на планировщик, отменив текущий контекст.

## <a name="detach"></a>Соединил

Отсоединяет текущий планировщик от вызывающего контекста и восстанавливает ранее присоединенный планировщик в качестве текущего планировщика, если он существует. После возврата из этого метода контекст вызова управляется планировщиком, который ранее был присоединен к контексту с помощью метода `CurrentScheduler::Create` или `Scheduler::Attach`.

```cpp
static void __cdecl Detach();
```

### <a name="remarks"></a>Примечания

Метод `Detach` неявно удаляет счетчик ссылок из планировщика.

При отсутствии планировщика, присоединенного к контексту вызова, вызов этого метода приведет к возникновению [scheduler_not_attached](scheduler-not-attached-class.md) исключения.

Вызов этого метода из контекста, который является внутренним и управляется планировщиком, или контекст, который был присоединен с помощью метода, отличного от методов [Scheduler:: Attach](scheduler-class.md#attach) или [CurrentScheduler:: Create](#create) , приведет к возникновению исключения [improper_scheduler_detach](improper-scheduler-detach-class.md) .

## <a name="get"></a>Получить

Возвращает указатель на планировщик, связанный с контекстом вызова, который также называется текущим планировщиком.

```cpp
static Scheduler* __cdecl Get();
```

### <a name="return-value"></a>Возвращаемое значение

Указатель на планировщик, связанный с вызывающим контекстом (текущим планировщиком).

### <a name="remarks"></a>Примечания

В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом. Для объекта `Scheduler`, возвращаемого этим методом, не размещается дополнительная ссылка.

## <a name="getnumberofvirtualprocessors"></a>жетнумберофвиртуалпроцессорс

Возвращает текущее число виртуальных процессоров для планировщика, связанного с контекстом вызова.

```cpp
static unsigned int __cdecl GetNumberOfVirtualProcessors();
```

### <a name="return-value"></a>Возвращаемое значение

Значение, если планировщик связан с контекстом вызова, текущим числом виртуальных процессоров для этого планировщика; в противном случае значение `-1`.

### <a name="remarks"></a>Примечания

Этот метод не приведет к присоединению планировщика, если вызывающий контекст еще не связан с планировщиком.

Возвращаемое значение этого метода — это мгновенное выборка количества виртуальных процессоров для планировщика, связанного с вызывающим контекстом. Это значение может быть устаревшим в момент возврата.

## <a name="getpolicy"></a>GetPolicy

Возвращает копию политики, с которой был создан текущий планировщик.

```cpp
static SchedulerPolicy __cdecl GetPolicy();
```

### <a name="return-value"></a>Возвращаемое значение

Копия политики, с которой был создан текущий планировщик.

### <a name="remarks"></a>Примечания

В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.

## <a name="id"></a>Удостоверения

Возвращает уникальный идентификатор текущего планировщика.

```cpp
static unsigned int __cdecl Id();
```

### <a name="return-value"></a>Возвращаемое значение

Если планировщик связан с вызывающим контекстом, уникальный идентификатор для этого планировщика; в противном случае значение `-1`.

### <a name="remarks"></a>Примечания

Этот метод не приведет к присоединению планировщика, если вызывающий контекст еще не связан с планировщиком.

## <a name="isavailablelocation"></a>исаваилаблелокатион

Определяет, доступно ли данное расположение в текущем планировщике.

```cpp
static bool __cdecl IsAvailableLocation(const location& _Placement);
```

### <a name="parameters"></a>Параметры

*_Placement*<br/>
Ссылка на расположение, о котором необходимо отправить запрос текущему планировщику.

### <a name="return-value"></a>Возвращаемое значение

Индикация доступности расположения, указанного параметром `_Placement`, в текущем планировщике.

### <a name="remarks"></a>Примечания

Этот метод не приведет к присоединению планировщика, если вызывающий контекст еще не связан с планировщиком.

Обратите внимание, что возвращаемое значение является результатом проверки доступности указанного расположения в данный момент. При наличии нескольких планировщиков динамическое управление ресурсами может добавлять или забирать ресурсы у планировщиков в любой момент. Если это произошло, доступность заданного расположения может измениться.

## <a name="registershutdownevent"></a>регистершутдовневент

Приводит к тому, что дескриптор событий Windows, переданный в параметре `_ShutdownEvent`, получает сигнал, когда планировщик, связанный с текущим контекстом, завершает работу и удаляет себя. В момент получения сигнала о событии все запланированные работы планировщика завершены. С помощью этого метода можно зарегистрировать несколько событий завершения работы.

```cpp
static void __cdecl RegisterShutdownEvent(HANDLE _ShutdownEvent);
```

### <a name="parameters"></a>Параметры

*_ShutdownEvent*<br/>
Дескриптор объекта события Windows, который будет оповещен среде выполнения, когда планировщик, связанный с текущим контекстом, завершает работу и удаляет себя.

### <a name="remarks"></a>Примечания

При отсутствии планировщика, присоединенного к контексту вызова, вызов этого метода приведет к возникновению [scheduler_not_attached](scheduler-not-attached-class.md) исключения.

## <a name="scheduletask"></a>ScheduleTask

Планирует задачу с невысокой плотностью в планировщике, связанном с вызывающим контекстом. Упрощенная задача будет размещена в группе расписаний, определенной средой выполнения. Версия, принимающая параметр `_Placement`, склоняет задачу к выполнению в указанном расположении.

```cpp
static void __cdecl ScheduleTask(
    TaskProc _Proc,
    _Inout_opt_ void* _Data);

static void __cdecl ScheduleTask(
    TaskProc _Proc,
    _Inout_opt_ void* _Data,
    location& _Placement);
```

### <a name="parameters"></a>Параметры

*_Proc*<br/>
Указатель на функцию, которая должна быть выполнена, чтобы выполнить задачу неплотности.

*_Data*<br/>
Указатель типа void на данные, которые будут переданы в качестве параметра в текст задачи.

*_Placement*<br/>
Ссылка на расположение, где будет склонна выполняться упрощенная задача.

### <a name="remarks"></a>Примечания

В результате этого метода в процессе будет создан планировщик по умолчанию и/или присоединен к вызывающему контексту, если отсутствует планировщик, в данный момент связанный с вызывающим контекстом.

## <a name="see-also"></a>См. также раздел

[Пространство имен concurrency](concurrency-namespace.md)<br/>
[Класс Scheduler](scheduler-class.md)<br/>
[PolicyElementKey](concurrency-namespace-enums.md)<br/>
[Планировщик заданий](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)
