---
title: Класс concurrent_vector
ms.date: 11/04/2016
f1_keywords:
- concurrent_vector
- CONCURRENT_VECTOR/concurrency::concurrent_vector
- CONCURRENT_VECTOR/concurrency::concurrent_vector::concurrent_vector
- CONCURRENT_VECTOR/concurrency::concurrent_vector::assign
- CONCURRENT_VECTOR/concurrency::concurrent_vector::at
- CONCURRENT_VECTOR/concurrency::concurrent_vector::back
- CONCURRENT_VECTOR/concurrency::concurrent_vector::begin
- CONCURRENT_VECTOR/concurrency::concurrent_vector::capacity
- CONCURRENT_VECTOR/concurrency::concurrent_vector::cbegin
- CONCURRENT_VECTOR/concurrency::concurrent_vector::cend
- CONCURRENT_VECTOR/concurrency::concurrent_vector::clear
- CONCURRENT_VECTOR/concurrency::concurrent_vector::crbegin
- CONCURRENT_VECTOR/concurrency::concurrent_vector::crend
- CONCURRENT_VECTOR/concurrency::concurrent_vector::empty
- CONCURRENT_VECTOR/concurrency::concurrent_vector::end
- CONCURRENT_VECTOR/concurrency::concurrent_vector::front
- CONCURRENT_VECTOR/concurrency::concurrent_vector::get_allocator
- CONCURRENT_VECTOR/concurrency::concurrent_vector::grow_by
- CONCURRENT_VECTOR/concurrency::concurrent_vector::grow_to_at_least
- CONCURRENT_VECTOR/concurrency::concurrent_vector::max_size
- CONCURRENT_VECTOR/concurrency::concurrent_vector::push_back
- CONCURRENT_VECTOR/concurrency::concurrent_vector::rbegin
- CONCURRENT_VECTOR/concurrency::concurrent_vector::rend
- CONCURRENT_VECTOR/concurrency::concurrent_vector::reserve
- CONCURRENT_VECTOR/concurrency::concurrent_vector::resize
- CONCURRENT_VECTOR/concurrency::concurrent_vector::shrink_to_fit
- CONCURRENT_VECTOR/concurrency::concurrent_vector::size
- CONCURRENT_VECTOR/concurrency::concurrent_vector::swap
helpviewer_keywords:
- concurrent_vector class
ms.assetid: a217b4ac-af2b-4d41-94eb-09a75ee28622
ms.openlocfilehash: 9144fd0870bfb72e923a7271ffdd655e03a9bd57
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87215846"
---
# <a name="concurrent_vector-class"></a>Класс concurrent_vector

Класс `concurrent_vector` представляет собой класс контейнера последовательности, обеспечивающий доступ к элементам в случайном порядке. Позволяет параллельно-безопасно выполнять операции присоединения, получения доступа к элементу, доступа к итератору и обхода итератора. В данном случае, безопасность с параллелизмом означает, что указатели или итераторы всегда действительны. Не гарантируется инициализация элементов или определенный порядок обхода.

## <a name="syntax"></a>Синтаксис

```cpp
template<typename T, class _Ax>
class concurrent_vector: protected details::_Allocator_base<T,
    _Ax>,
private details::_Concurrent_vector_base_v4;
```

### <a name="parameters"></a>Параметры

*T*<br/>
Тип данных элементов, которые должны храниться в векторе.

*_Ax*<br/>
Тип, представляющий сохраненный объект распределителя, который инкапсулирует сведения о выделении и освобождении памяти для параллельного вектора. Этот аргумент является необязательным, и значением по умолчанию является `allocator<T>`.

## <a name="members"></a>Элементы

### <a name="public-typedefs"></a>Общедоступные определения типов

|Имя|Описание|
|----------|-----------------|
|`allocator_type`|Тип, представляющий класс распределителя для параллельного вектора.|
|`const_iterator`|Тип, предоставляющий итератор произвольного доступа, который может считывать **`const`** элемент в параллельном векторе.|
|`const_pointer`|Тип, предоставляющий указатель на **`const`** элемент в параллельном векторе.|
|`const_reference`|Тип, предоставляющий ссылку на **`const`** элемент, хранящийся в параллельном векторе для чтения и выполнения **`const`** операций.|
|`const_reverse_iterator`|Тип, предоставляющий итератор произвольного доступа, который может считывать любой **`const`** элемент в параллельном векторе.|
|`difference_type`|Тип, предоставляющий расстояние со знаком между двумя элементами в параллельном векторе.|
|`iterator`|Тип, предоставляющий итератор произвольного доступа, который может считывать любой элемент в параллельном векторе. Изменение элемента с помощью итератора не является типобезопасным.|
|`pointer`|Тип, предоставляющий указатель на элемент в параллельном векторе.|
|`reference`|Тип, предоставляющий ссылку на элемент, хранящийся в параллельном векторе.|
|`reverse_iterator`|Тип, предоставляющий итератор произвольного доступа, который может считывать любой элемент в инвертированном параллельном векторе. Изменение элемента с помощью итератора не является типобезопасным.|
|`size_type`|Тип, который подсчитывает количество элементов в параллельном векторе.|
|`value_type`|Тип, представляющий тип данных, хранящийся в параллельном векторе.|

### <a name="public-constructors"></a>Открытые конструкторы

|Имя|Описание|
|----------|-----------------|
|[concurrent_vector](#ctor)|Перегружен. Конструирует параллельный вектор.|
|[Деструктор ~ concurrent_vector](#dtor)|Стирает все элементы и уничтожает этот параллельный вектор.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[assign](#assign)|Перегружен. Стирает элементы параллельного вектора и присваивает ему либо `_N` копии `_Item` , либо значения, указанные в диапазоне итератора [ `_Begin` , `_End` ). Этот метод не является типобезопасным в режиме параллелизма.|
|[at](#at)|Перегружен. Предоставляет доступ к элементу по заданному индексу в параллельном векторе. Этот метод является типобезопасным для операций чтения, а также при увеличении вектора, пока вы уверены, что значение `_Index` меньше, чем размер параллельного вектора.|
|[back](#back)|Перегружен. Возвращает ссылку или **`const`** ссылку на последний элемент в параллельном векторе. Если параллельный вектор пуст, возвращаемое значение не определено. Этот метод является типобезопасным в режиме параллелизма.|
|[begin](#begin)|Перегружен. Возвращает итератор типа `iterator` или `const_iterator` в начало параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[capacity](#capacity)|Возвращает максимальный размер, до которого может увеличиваться параллельный вектор без выделения большего объема памяти. Этот метод является типобезопасным в режиме параллелизма.|
|[cbegin](#cbegin)|Возвращает итератор типа `const_iterator` на начало параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[cend](#cend)|Возвращает итератор типа `const_iterator` на конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[clear](#clear)|Стирает все элементы в параллельном векторе. Этот метод не является типобезопасным в режиме параллелизма.|
|[crbegin](#crbegin)|Возвращает итератор типа `const_reverse_iterator` на начало параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[crend](#crend)|Возвращает итератор типа `const_reverse_iterator` на конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[empty](#empty)|Проверяет, является ли одновременный вектор пустым во время вызова этого метода. Этот метод является типобезопасным в режиме параллелизма.|
|[end](#end)|Перегружен. Возвращает итератор типа `iterator` или `const_iterator` в конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[front](#front)|Перегружен. Возвращает ссылку или **`const`** ссылку на первый элемент в параллельном векторе. Если параллельный вектор пуст, возвращаемое значение не определено. Этот метод является типобезопасным в режиме параллелизма.|
|[get_allocator](#get_allocator)|Возвращает копию распределителя, используемую для создания параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[grow_by](#grow_by)|Перегружен. Увеличивает этот одновременный вектор по `_Delta` элементам. Этот метод является типобезопасным в режиме параллелизма.|
|[grow_to_at_least](#grow_to_at_least)|Увеличивает этот одновременный вектор, пока он не содержит по меньшей мере `_N` элементы. Этот метод является типобезопасным в режиме параллелизма.|
|[max_size](#max_size)|Возвращает максимальное количество элементов, которое может содержать параллельный вектор. Этот метод является типобезопасным в режиме параллелизма.|
|[push_back](#push_back)|Перегружен. Добавляет заданный элемент в конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[rbegin](#rbegin)|Перегружен. Возвращает итератор типа `reverse_iterator` или `const_reverse_iterator` в начало параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[rend](#rend)|Перегружен. Возвращает итератор типа `reverse_iterator` или `const_reverse_iterator` в конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.|
|[reserve](#reserve)|Выделяет достаточно места для увеличения параллельного вектора до размера `_N` без необходимости выделять больше памяти позже. Этот метод не является типобезопасным в режиме параллелизма.|
|[resize](#resize)|Перегружен. Изменяет размер параллельного вектора на запрошенный размер, удаляя или добавляя элементы при необходимости. Этот метод не является типобезопасным в режиме параллелизма.|
|[shrink_to_fit](#shrink_to_fit)|Сжимает внутреннее представление параллельного вектора, чтобы снизить фрагментацию и оптимизировать использование памяти. Этот метод не является типобезопасным в режиме параллелизма.|
|[size](#size)|Возвращает количество элементов в параллельном векторе. Этот метод является типобезопасным в режиме параллелизма.|
|[swap](#swap)|Меняет местами содержимое двух одновременных векторов. Этот метод не является типобезопасным в режиме параллелизма.|

### <a name="public-operators"></a>Открытые операторы

|Имя|Описание|
|----------|-----------------|
|[оператор\[\]](#operator_at)|Перегружен. Предоставляет доступ к элементу по заданному индексу в параллельном векторе. Этот метод является типобезопасным для операций чтения, а также при увеличении вектора, пока вы уверены, что значение `_Index` меньше, чем размер параллельного вектора.|
|[operator=](#operator_eq)|Перегружен. Присваивает `concurrent_vector` этому объекту содержимое другого объекта. Этот метод не является типобезопасным в режиме параллелизма.|

## <a name="remarks"></a>Примечания

Подробные сведения о `concurrent_vector` классе см. в разделе [Parallel Containers and Objects](../../../parallel/concrt/parallel-containers-and-objects.md).

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`_Concurrent_vector_base_v4`

`_Allocator_base`

`concurrent_vector`

## <a name="requirements"></a>Требования

**Заголовок:** concurrent_vector.h

**Пространство имен:** concurrency

## <a name="assign"></a><a name="assign"></a>назначать

Стирает элементы параллельного вектора и присваивает ему либо `_N` копии `_Item` , либо значения, указанные в диапазоне итератора [ `_Begin` , `_End` ). Этот метод не является типобезопасным в режиме параллелизма.

```cpp
void assign(
    size_type _N,
    const_reference _Item);

template<class _InputIterator>
void assign(_InputIterator _Begin,
    _InputIterator _End);
```

### <a name="parameters"></a>Параметры

*_InputIterator*<br/>
Тип указанного итератора.

*_N*<br/>
Число элементов, копируемых в параллельный вектор.

*_Item*<br/>
Ссылка на значение, используемое для заполнения параллельного вектора.

*_Begin*<br/>
Итератор на первый элемент исходного диапазона.

*_End*<br/>
Итератор, который должен находиться за последним элементом исходного диапазона.

### <a name="remarks"></a>Примечания

`assign`не является типобезопасным. Необходимо убедиться, что никакие другие потоки не вызывают методы в параллельном векторе при вызове этого метода.

## <a name="at"></a><a name="at"></a>в

Предоставляет доступ к элементу по заданному индексу в параллельном векторе. Этот метод является типобезопасным для операций чтения, а также при увеличении вектора, пока вы уверены, что значение `_Index` меньше, чем размер параллельного вектора.

```cpp
reference at(size_type _Index);

const_reference at(size_type _Index) const;
```

### <a name="parameters"></a>Параметры

*_Index*<br/>
Индекс извлекаемого элемента.

### <a name="return-value"></a>Возвращаемое значение

Ссылка на элемент по заданному индексу.

### <a name="remarks"></a>Примечания

Версия функции `at` , которая возвращает **`const`** нессылочную, не может использоваться для параллельной записи в элемент из разных потоков. Для синхронизации одновременных операций чтения и записи с одним и тем же элементом данных следует использовать другой объект синхронизации.

Метод создает исключение, `out_of_range` Если `_Index` значение больше или равно размеру параллельного вектора, и `range_error` Если индекс предназначен для неработающей части вектора. Дополнительные сведения о том, как вектор может стать недействительным, см. в разделе [Parallel Containers and Objects](../../../parallel/concrt/parallel-containers-and-objects.md).

## <a name="back"></a><a name="back"></a>Назад

Возвращает ссылку или **`const`** ссылку на последний элемент в параллельном векторе. Если параллельный вектор пуст, возвращаемое значение не определено. Этот метод является типобезопасным в режиме параллелизма.

```cpp
reference back();

const_reference back() const;
```

### <a name="return-value"></a>Возвращаемое значение

Ссылка или **`const`** ссылка на последний элемент в параллельном векторе.

## <a name="begin"></a><a name="begin"></a>начале

Возвращает итератор типа `iterator` или `const_iterator` в начало параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
iterator begin();

const_iterator begin() const;
```

### <a name="return-value"></a>Возвращаемое значение

Итератор типа `iterator` или `const_iterator` на начало параллельного вектора.

## <a name="capacity"></a><a name="capacity"></a>ресурсов

Возвращает максимальный размер, до которого может увеличиваться параллельный вектор без выделения большего объема памяти. Этот метод является типобезопасным в режиме параллелизма.

```cpp
size_type capacity() const;
```

### <a name="return-value"></a>Возвращаемое значение

Максимальный размер, до которого может расти параллельный вектор без необходимости выделения дополнительной памяти.

### <a name="remarks"></a>Примечания

В отличие от стандартной библиотеки C++ `vector` , `concurrent_vector` объект не перемещает существующие элементы, если выделяет больше памяти.

## <a name="cbegin"></a><a name="cbegin"></a>cbegin

Возвращает итератор типа `const_iterator` на начало параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
const_iterator cbegin() const;
```

### <a name="return-value"></a>Возвращаемое значение

Итератор типа `const_iterator` на начало параллельного вектора.

## <a name="cend"></a><a name="cend"></a>cend

Возвращает итератор типа `const_iterator` на конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
const_iterator cend() const;
```

### <a name="return-value"></a>Возвращаемое значение

Итератор типа `const_iterator` на конец параллельного вектора.

## <a name="clear"></a><a name="clear"></a>открытым

Стирает все элементы в параллельном векторе. Этот метод не является типобезопасным в режиме параллелизма.

```cpp
void clear();
```

### <a name="remarks"></a>Примечания

`clear`не является типобезопасным. Необходимо убедиться, что никакие другие потоки не вызывают методы в параллельном векторе при вызове этого метода. `clear`не освобождает внутренние массивы. Чтобы освободить внутренние массивы, вызовите функцию `shrink_to_fit` после `clear` .

## <a name="concurrent_vector"></a><a name="ctor"></a>concurrent_vector

Конструирует параллельный вектор.

```cpp
explicit concurrent_vector(
    const allocator_type& _Al = allocator_type());

concurrent_vector(
    const concurrent_vector& _Vector);

template<class M>
concurrent_vector(
    const concurrent_vector<T,
    M>& _Vector,
    const allocator_type& _Al = allocator_type());

concurrent_vector(
    concurrent_vector&& _Vector);

explicit concurrent_vector(
    size_type _N);

concurrent_vector(
    size_type _N,
    const_reference _Item,
    const allocator_type& _Al = allocator_type());

template<class _InputIterator>
concurrent_vector(_InputIterator _Begin,
    _InputIterator _End,
    const allocator_type& _Al = allocator_type());
```

### <a name="parameters"></a>Параметры

*M*<br/>
Тип распределителя исходного вектора.

*_InputIterator*<br/>
Тип итератора ввода.

*_Al*<br/>
Класс распределителя для использования с данным объектом.

*_Vector*<br/>
Исходный объект `concurrent_vector` для копирования или перемещения элементов.

*_N*<br/>
Начальная производительность объекта `concurrent_vector`.

*_Item*<br/>
Значение элементов в созданном объекте.

*_Begin*<br/>
Положение первого элемента в диапазоне копируемых элементов.

*_End*<br/>
Положение первого элемента за пределами диапазона копируемых элементов.

### <a name="remarks"></a>Примечания

Все конструкторы хранят объект распределителя `_Al` и инициализируют вектор.

Первый конструктор задает пустой Исходный вектор и явно указывает тип распределителя. для использования.

Второй и третий конструкторы указывают копию параллельного вектора `_Vector` .

Четвертый конструктор определяет перемещение параллельного вектора `_Vector`.

Пятый конструктор указывает повторение указанного числа ( `_N` ) элементов значения по умолчанию для класса `T` .

Шестой конструктор задает повторение ( `_N` ) элементов value `_Item` .

Последний конструктор указывает значения, предоставляемые диапазоном итератора [ `_Begin` , `_End` ).

## <a name="concurrent_vector"></a><a name="dtor"></a>~ concurrent_vector

Стирает все элементы и уничтожает этот параллельный вектор.

```cpp
~concurrent_vector();
```

## <a name="crbegin"></a><a name="crbegin"></a>crbegin

Возвращает итератор типа `const_reverse_iterator` на начало параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
const_reverse_iterator crbegin() const;
```

### <a name="return-value"></a>Возвращаемое значение

Итератор типа `const_reverse_iterator` на начало параллельного вектора.

## <a name="crend"></a><a name="crend"></a>crend

Возвращает итератор типа `const_reverse_iterator` на конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
const_reverse_iterator crend() const;
```

### <a name="return-value"></a>Возвращаемое значение

Итератор типа `const_reverse_iterator` на конец параллельного вектора.

## <a name="empty"></a><a name="empty"></a>указано

Проверяет, является ли одновременный вектор пустым во время вызова этого метода. Этот метод является типобезопасным в режиме параллелизма.

```cpp
bool empty() const;
```

### <a name="return-value"></a>Возвращаемое значение

**`true`** значение, если вектор был пустым в момент вызова функции, **`false`** в противном случае.

## <a name="end"></a><a name="end"></a>конце

Возвращает итератор типа `iterator` или `const_iterator` в конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
iterator end();

const_iterator end() const;
```

### <a name="return-value"></a>Возвращаемое значение

Итератор типа `iterator` или `const_iterator` до конца параллельного вектора.

## <a name="front"></a><a name="front"></a>крышку

Возвращает ссылку или **`const`** ссылку на первый элемент в параллельном векторе. Если параллельный вектор пуст, возвращаемое значение не определено. Этот метод является типобезопасным в режиме параллелизма.

```cpp
reference front();

const_reference front() const;
```

### <a name="return-value"></a>Возвращаемое значение

Ссылка или **`const`** ссылка на первый элемент в параллельном векторе.

## <a name="get_allocator"></a><a name="get_allocator"></a>get_allocator

Возвращает копию распределителя, используемую для создания параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
allocator_type get_allocator() const;
```

### <a name="return-value"></a>Возвращаемое значение

Копия распределителя, используемая для создания `concurrent_vector` объекта.

## <a name="grow_by"></a><a name="grow_by"></a>grow_by

Увеличивает этот одновременный вектор по `_Delta` элементам. Этот метод является типобезопасным в режиме параллелизма.

```cpp
iterator grow_by(
    size_type _Delta);

iterator grow_by(
    size_type _Delta,
    const_reference _Item);
```

### <a name="parameters"></a>Параметры

*_Delta*<br/>
Число элементов, добавляемых к объекту.

*_Item*<br/>
Значение для инициализации новых элементов с помощью.

### <a name="return-value"></a>Возвращаемое значение

Итератор, к которому добавляется первый элемент.

### <a name="remarks"></a>Примечания

Если `_Item` параметр не указан, то создаются новые элементы по умолчанию.

## <a name="grow_to_at_least"></a><a name="grow_to_at_least"></a>grow_to_at_least

Увеличивает этот одновременный вектор, пока он не содержит по меньшей мере `_N` элементы. Этот метод является типобезопасным в режиме параллелизма.

```cpp
iterator grow_to_at_least(size_type _N);
```

### <a name="parameters"></a>Параметры

*_N*<br/>
Новый минимальный размер `concurrent_vector` объекта.

### <a name="return-value"></a>Возвращаемое значение

Итератор, указывающий на начало добавленной последовательности или на элемент по индексу, `_N` Если элементы не были добавлены.

## <a name="max_size"></a><a name="max_size"></a>max_size

Возвращает максимальное количество элементов, которое может содержать параллельный вектор. Этот метод является типобезопасным в режиме параллелизма.

```cpp
size_type max_size() const;
```

### <a name="return-value"></a>Возвращаемое значение

Максимальное число элементов, которое `concurrent_vector` может хранить объект.

## <a name="operator"></a><a name="operator_eq"></a>Оператор =

Присваивает `concurrent_vector` этому объекту содержимое другого объекта. Этот метод не является типобезопасным в режиме параллелизма.

```cpp
concurrent_vector& operator= (
    const concurrent_vector& _Vector);

template<class M>
concurrent_vector& operator= (
    const concurrent_vector<T, M>& _Vector);

concurrent_vector& operator= (
    concurrent_vector&& _Vector);
```

### <a name="parameters"></a>Параметры

*M*<br/>
Тип распределителя исходного вектора.

*_Vector*<br/>
Исходный объект `concurrent_vector`.

### <a name="return-value"></a>Возвращаемое значение

Ссылка на этот `concurrent_vector` объект.

## <a name="operator"></a><a name="operator_at"></a>operator []

Предоставляет доступ к элементу по заданному индексу в параллельном векторе. Этот метод является типобезопасным для операций чтения, а также при увеличении вектора, пока вы уверены, что значение `_Index` меньше, чем размер параллельного вектора.

```cpp
reference operator[](size_type _index);

const_reference operator[](size_type _index) const;
```

### <a name="parameters"></a>Параметры

*_Index*<br/>
Индекс извлекаемого элемента.

### <a name="return-value"></a>Возвращаемое значение

Ссылка на элемент по заданному индексу.

### <a name="remarks"></a>Примечания

Версия `operator []` , которая возвращает **`const`** нессылающийся, не может использоваться для параллельной записи в элемент из разных потоков. Для синхронизации одновременных операций чтения и записи с одним и тем же элементом данных следует использовать другой объект синхронизации.

Проверка границ не выполняется, чтобы гарантировать, что `_Index` является допустимым индексом в параллельном векторе.

## <a name="push_back"></a><a name="push_back"></a>push_back

Добавляет заданный элемент в конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
iterator push_back(const_reference _Item);

iterator push_back(T&& _Item);
```

### <a name="parameters"></a>Параметры

*_Item*<br/>
Добавляемое значение.

### <a name="return-value"></a>Возвращаемое значение

Итератор на добавленный элемент.

## <a name="rbegin"></a><a name="rbegin"></a>rbegin

Возвращает итератор типа `reverse_iterator` или `const_reverse_iterator` в начало параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
reverse_iterator rbegin();

const_reverse_iterator rbegin() const;
```

### <a name="return-value"></a>Возвращаемое значение

Итератор типа `reverse_iterator` или `const_reverse_iterator` на начало параллельного вектора.

## <a name="rend"></a><a name="rend"></a>rend

Возвращает итератор типа `reverse_iterator` или `const_reverse_iterator` в конец параллельного вектора. Этот метод является типобезопасным в режиме параллелизма.

```cpp
reverse_iterator rend();

const_reverse_iterator rend() const;
```

### <a name="return-value"></a>Возвращаемое значение

Итератор типа `reverse_iterator` или `const_reverse_iterator` до конца параллельного вектора.

## <a name="reserve"></a><a name="reserve"></a>предназначен

Выделяет достаточно места для увеличения параллельного вектора до размера `_N` без необходимости выделять больше памяти позже. Этот метод не является типобезопасным в режиме параллелизма.

```cpp
void reserve(size_type _N);
```

### <a name="parameters"></a>Параметры

*_N*<br/>
Количество элементов, для которых резервируется место.

### <a name="remarks"></a>Примечания

`reserve`не является типобезопасным. Необходимо убедиться, что никакие другие потоки не вызывают методы в параллельном векторе при вызове этого метода. Емкость параллельного вектора после возврата метода может быть больше запрошенного резервирования.

## <a name="resize"></a><a name="resize"></a>изменить размер

Изменяет размер параллельного вектора на запрошенный размер, удаляя или добавляя элементы при необходимости. Этот метод не является типобезопасным в режиме параллелизма.

```cpp
void resize(
    size_type _N);

void resize(
    size_type _N,
    const T& val);
```

### <a name="parameters"></a>Параметры

*_N*<br/>
Новый размер concurrent_vector.

*Val*<br/>
Значение новых элементов, добавленных в вектор, если новый размер больше исходного. Если значение не указано, новым объектам присваивается значение по умолчанию для их типа.

### <a name="remarks"></a>Примечания

Если размер контейнера меньше запрошенного размера, элементы добавляются в вектор до тех пор, пока не достигнет запрошенного размера. Если размер контейнера превышает запрошенный размер, то элементы, ближайшие к концу контейнера, удаляются до тех пор, пока контейнер не достигнет размера `_N` . Если текущий размер контейнера совпадает с запрошенным, никакие действия не выполняются.

`resize`не является типобезопасным. Необходимо убедиться, что никакие другие потоки не вызывают методы в параллельном векторе при вызове этого метода.

## <a name="shrink_to_fit"></a><a name="shrink_to_fit"></a>shrink_to_fit

Сжимает внутреннее представление параллельного вектора, чтобы снизить фрагментацию и оптимизировать использование памяти. Этот метод не является типобезопасным в режиме параллелизма.

```cpp
void shrink_to_fit();
```

### <a name="remarks"></a>Примечания

Этот метод будет внутренним образом перераспределять элементы перемещения памяти вокруг, делая все итераторы недействительными. `shrink_to_fit`не является типобезопасным. Необходимо убедиться, что никакие другие потоки не вызывают методы в параллельном векторе при вызове этой функции.

## <a name="size"></a><a name="size"></a>изменять

Возвращает количество элементов в параллельном векторе. Этот метод является типобезопасным в режиме параллелизма.

```cpp
size_type size() const;
```

### <a name="return-value"></a>Возвращаемое значение

Число элементов в этом `concurrent_vector` объекте.

### <a name="remarks"></a>Примечания

Возвращаемый размер гарантирует включение всех элементов, добавленных вызовами функции `push_back` , или увеличение операций, завершенных до вызова этого метода. Однако он также может включать элементы, которые выделены, но по-прежнему находятся в процессе создания параллельных вызовов любого из методов роста.

## <a name="swap"></a><a name="swap"></a>позиции

Меняет местами содержимое двух одновременных векторов. Этот метод не является типобезопасным в режиме параллелизма.

```cpp
void swap(concurrent_vector& _Vector);
```

### <a name="parameters"></a>Параметры

*_Vector*<br/>
Объект `concurrent_vector` для обмена содержимым.

## <a name="see-also"></a>См. также раздел

[Пространство имен Concurrency](concurrency-namespace.md)<br/>
[Параллельные контейнеры и объекты](../../../parallel/concrt/parallel-containers-and-objects.md)
