---
title: Класс Scheduler
ms.date: 11/04/2016
f1_keywords:
- Scheduler
- CONCRT/concurrency::Scheduler
- CONCRT/concurrency::Scheduler::Scheduler
- CONCRT/concurrency::Scheduler::Attach
- CONCRT/concurrency::Scheduler::Create
- CONCRT/concurrency::Scheduler::CreateScheduleGroup
- CONCRT/concurrency::Scheduler::GetNumberOfVirtualProcessors
- CONCRT/concurrency::Scheduler::GetPolicy
- CONCRT/concurrency::Scheduler::Id
- CONCRT/concurrency::Scheduler::IsAvailableLocation
- CONCRT/concurrency::Scheduler::Reference
- CONCRT/concurrency::Scheduler::RegisterShutdownEvent
- CONCRT/concurrency::Scheduler::Release
- CONCRT/concurrency::Scheduler::ResetDefaultSchedulerPolicy
- CONCRT/concurrency::Scheduler::ScheduleTask
- CONCRT/concurrency::Scheduler::SetDefaultSchedulerPolicy
helpviewer_keywords:
- Scheduler class
ms.assetid: 34cf7961-048d-4852-8a5c-a32f823e3506
ms.openlocfilehash: 77ad876b8352ab1ae86fde622b05712ec5f2cea9
ms.sourcegitcommit: 7ecd91d8ce18088a956917cdaf3a3565bd128510
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2020
ms.locfileid: "79427353"
---
# <a name="scheduler-class"></a>Класс Scheduler

Представляет абстракцию для планировщика среды выполнения с параллелизмом.

## <a name="syntax"></a>Синтаксис

```cpp
class Scheduler;
```

## <a name="members"></a>Члены

### <a name="protected-constructors"></a>Защищенные конструкторы

|Имя|Описание|
|----------|-----------------|
|[Планировщик](#ctor)|Объект класса `Scheduler` может быть создан только с помощью фабричных методов или неявно.|
|[~ Деструктор планировщика](#dtor)|Объект класса `Scheduler` неявно уничтожается, когда все внешние ссылки на него прекращают существовать.|

### <a name="public-methods"></a>Открытые методы

|Имя|Описание|
|----------|-----------------|
|[Присоединить](#attach)|Присоединяет планировщик к вызывающему контексту. После возврата из этого метода контекст вызова управляется планировщиком, а планировщик становится текущим планировщиком.|
|[Создание](#create)|Создает новый планировщик, поведение которого описывается параметром `_Policy`, помещает начальную ссылку на планировщик и возвращает указатель на него.|
|[CreateScheduleGroup](#createschedulegroup)|Перегружен. Создает новую группу расписаний в планировщике. Версия, которая принимает параметр `_Placement` вызывает смещение задач в вновь созданной группе расписаний в направлении выполнения в расположении, указанном этим параметром.|
|[жетнумберофвиртуалпроцессорс](#getnumberofvirtualprocessors)|Возвращает текущее число виртуальных процессоров для планировщика.|
|[GetPolicy](#getpolicy)|Возвращает копию политики, с которой был создан планировщик.|
|[Id](#id)|Возвращает уникальный идентификатор для планировщика.|
|[исаваилаблелокатион](#isavailablelocation)|Определяет, доступно ли заданное расположение в планировщике.|
|[Справочные материалы](#reference)|Увеличивает счетчик ссылок планировщика.|
|[регистершутдовневент](#registershutdownevent)|Приводит к тому, что дескриптор событий Windows, переданный в параметре `_Event`, получает сигнал при завершении работы планировщика и его уничтожении. В момент получения сигнала о событии все запланированные работы планировщика завершены. С помощью этого метода можно зарегистрировать несколько событий завершения работы.|
|[Выпуск](#release)|Уменьшает значение счетчика ссылок планировщика.|
|[ресетдефаултсчедулерполици](#resetdefaultschedulerpolicy)|Сбрасывает политику планировщика по умолчанию в среду выполнения по умолчанию. При следующем создании планировщика по умолчанию будут использоваться параметры политики по умолчанию для среды выполнения.|
|[ScheduleTask](#scheduletask)|Перегружен. Планирует облегченную задачу в планировщике. Упрощенная задача будет размещена в группе расписаний, определенной средой выполнения. Версия, принимающая параметр `_Placement`, склоняет задачу к выполнению в указанном расположении.|
|[SetDefaultSchedulerPolicy](#setdefaultschedulerpolicy)|Позволяет использовать определенную пользователем политику для создания планировщика по умолчанию. Этот метод можно вызывать только в том случае, если в процессе не существует планировщика по умолчанию. После установки политики по умолчанию она остается действующей до следующего допустимого вызова метода `SetDefaultSchedulerPolicy` или [ресетдефаултсчедулерполици](#resetdefaultschedulerpolicy) .|

## <a name="remarks"></a>Примечания

Планировщик среда выполнения с параллелизмом использует контексты выполнения, которые сопоставляются с контекстами выполнения операционной системы, такими как поток, для выполнения работы, поставленной в очередь приложением. В любое время уровень параллелизма планировщика равен количеству виртуальных процессоров, предоставленных ему диспетчер ресурсов. Виртуальный процессор является абстракцией для обрабатывающего ресурса и сопоставляется аппаратному потоку в базовой системе. Только один контекст планировщика может выполняться на виртуальном процессоре в определенный момент времени.

Среда выполнения с параллелизмом создаст планировщик по умолчанию для каждого процесса, чтобы выполнить параллельную работу. Кроме того, вы можете создавать собственные экземпляры планировщика и манипулировать ими с помощью этого класса.

## <a name="inheritance-hierarchy"></a>Иерархия наследования

`Scheduler`

## <a name="requirements"></a>Требования

**Заголовок:** ConcRT.h

**Пространство имен:** concurrency

## <a name="attach"></a>Вновь

Присоединяет планировщик к вызывающему контексту. После возврата из этого метода контекст вызова управляется планировщиком, а планировщик становится текущим планировщиком.

```cpp
virtual void Attach() = 0;
```

### <a name="remarks"></a>Примечания

При присоединении планировщика неявным образом накладывается ссылка на планировщик.

В некоторый момент в будущем необходимо вызвать метод [CurrentScheduler::D етач](currentscheduler-class.md#detach) , чтобы разрешить завершение работы планировщика.

Если этот метод вызывается из контекста, уже присоединенного к другому планировщику, существующий планировщик запоминается как предыдущий планировщик, а вновь созданный планировщик становится текущим планировщиком. При последующем вызове метода `CurrentScheduler::Detach` предыдущий планировщик восстанавливается как текущий планировщик.

Этот метод вызовет исключение [improper_scheduler_attach](improper-scheduler-attach-class.md) , если этот планировщик является текущим планировщиком вызывающего контекста.

## <a name="create"></a> Создание

Создает новый планировщик, поведение которого описывается параметром `_Policy`, помещает начальную ссылку на планировщик и возвращает указатель на него.

```cpp
static Scheduler* __cdecl Create(const SchedulerPolicy& _Policy);
```

### <a name="parameters"></a>Параметры

*_Policy*<br/>
Политика планировщика, которая описывает поведение только что созданного планировщика.

### <a name="return-value"></a>Возвращаемое значение

Указатель на только что созданный планировщик. На этом `Scheduler`ном объекте размещено начальное количество ссылок.

### <a name="remarks"></a>Примечания

После создания планировщика с помощью метода `Create` необходимо вызвать метод `Release` в некоторый момент в будущем, чтобы удалить начальное значение счетчика ссылок и разрешить завершение работы планировщика.

Планировщик, созданный с помощью этого метода, не присоединен к вызывающему контексту. Его можно присоединить к контексту с помощью метода [attach](#attach) .

Этот метод может вызывать различные исключения, в том числе [scheduler_resource_allocation_error](scheduler-resource-allocation-error-class.md) и [invalid_scheduler_policy_value](invalid-scheduler-policy-value-class.md).

## <a name="createschedulegroup"></a>CreateScheduleGroup

Создает новую группу расписаний в планировщике. Версия, которая принимает параметр `_Placement` вызывает смещение задач в вновь созданной группе расписаний в направлении выполнения в расположении, указанном этим параметром.

```cpp
virtual ScheduleGroup* CreateScheduleGroup() = 0;

virtual ScheduleGroup* CreateScheduleGroup(location& _Placement) = 0;
```

### <a name="parameters"></a>Параметры

*_Placement*<br/>
Ссылка на расположение, в котором задачи в группе расписаний будут смещены в сторону выполнения в.

### <a name="return-value"></a>Возвращаемое значение

Указатель на только что созданную группу расписаний. На этом `ScheduleGroup`ном объекте размещено начальное количество ссылок.

### <a name="remarks"></a>Примечания

При завершении планирования работы для группы расписаний необходимо вызвать метод [Release](schedulegroup-class.md#release) . Планировщик удалит группу расписаний после завершения всей работы в очереди.

Обратите внимание, что если вы явно создали этот планировщик, необходимо освободить все ссылки на группы планирования в нем, прежде чем отпустить ссылки на планировщик.

## <a name="getnumberofvirtualprocessors"></a>жетнумберофвиртуалпроцессорс

Возвращает текущее число виртуальных процессоров для планировщика.

```cpp
virtual unsigned int GetNumberOfVirtualProcessors() const = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Текущее число виртуальных процессоров для планировщика.

## <a name="getpolicy"></a>GetPolicy

Возвращает копию политики, с которой был создан планировщик.

```cpp
virtual SchedulerPolicy GetPolicy() const = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Копия политики, с которой был создан планировщик.

## <a name="id"></a>Удостоверения

Возвращает уникальный идентификатор для планировщика.

```cpp
virtual unsigned int Id() const = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Уникальный идентификатор планировщика.

## <a name="isavailablelocation"></a>исаваилаблелокатион

Определяет, доступно ли заданное расположение в планировщике.

```cpp
virtual bool IsAvailableLocation(const location& _Placement) const = 0;
```

### <a name="parameters"></a>Параметры

*_Placement*<br/>
Ссылка на расположение для запроса к планировщику.

### <a name="return-value"></a>Возвращаемое значение

Указывает, доступно ли в планировщике расположение, заданное аргументом `_Placement`.

### <a name="remarks"></a>Примечания

Обратите внимание, что возвращаемое значение является результатом проверки доступности указанного расположения в данный момент. При наличии нескольких планировщиков динамическое управление ресурсами может добавлять или забирать ресурсы у планировщиков в любой момент. Если это произошло, доступность заданного расположения может измениться.

## <a name="reference"></a>IsReference

Увеличивает счетчик ссылок планировщика.

```cpp
virtual unsigned int Reference() = 0 ;
```

### <a name="return-value"></a>Возвращаемое значение

Вновь увеличивающееся число ссылок.

### <a name="remarks"></a>Примечания

Обычно это используется для управления временем существования планировщика для композиции. Когда значение счетчика ссылок планировщика снижается до нуля, планировщик завершит работу и уничтожится после завершения всей работы, указанной в планировщике.

Метод вызывает исключение [improper_scheduler_reference](improper-scheduler-reference-class.md) , если число ссылок до вызова метода `Reference` было равно нулю и вызов выполняется из контекста, который не принадлежит планировщику.

## <a name="registershutdownevent"></a>регистершутдовневент

Приводит к тому, что дескриптор событий Windows, переданный в параметре `_Event`, получает сигнал при завершении работы планировщика и его уничтожении. В момент получения сигнала о событии все запланированные работы планировщика завершены. С помощью этого метода можно зарегистрировать несколько событий завершения работы.

```cpp
virtual void RegisterShutdownEvent(HANDLE _Event) = 0;
```

### <a name="parameters"></a>Параметры

*_Event*<br/>
Дескриптор объекта события Windows, который будет сигнальным средой выполнения при завершении работы планировщика и его уничтожении.

## <a name="release"></a>Отпускании

Уменьшает значение счетчика ссылок планировщика.

```cpp
virtual unsigned int Release() = 0;
```

### <a name="return-value"></a>Возвращаемое значение

Вновь уменьшенное число ссылок.

### <a name="remarks"></a>Примечания

Обычно это используется для управления временем существования планировщика для композиции. Когда значение счетчика ссылок планировщика снижается до нуля, планировщик завершит работу и уничтожится после завершения всей работы, указанной в планировщике.

## <a name="resetdefaultschedulerpolicy"></a>ресетдефаултсчедулерполици

Сбрасывает политику планировщика по умолчанию в среду выполнения по умолчанию. При следующем создании планировщика по умолчанию будут использоваться параметры политики по умолчанию для среды выполнения.

```cpp
static void __cdecl ResetDefaultSchedulerPolicy();
```

### <a name="remarks"></a>Примечания

Этот метод может быть вызван, когда в процессе существует планировщик по умолчанию. Он не влияет на политику существующего планировщика по умолчанию. Однако если планировщик по умолчанию был завершен и новое значение по умолчанию было создано позже, то новый планировщик будет использовать параметры политики по умолчанию для среды выполнения.

## <a name="ctor"></a>Планировщика

Объект класса `Scheduler` может быть создан только с помощью фабричных методов или неявно.

```cpp
Scheduler();
```

### <a name="remarks"></a>Примечания

Планировщик по умолчанию процесса создается неявно при использовании многих функций среды выполнения, требующих подключения планировщика к вызывающему контексту. Методы в классе `CurrentScheduler` и функции уровней PPL и агентов обычно выполняют неявное вложение.

Планировщик можно также создать явным образом с помощью метода `CurrentScheduler::Create` или метода `Scheduler::Create`.

## <a name="dtor"></a>~ Scheduler

Объект класса `Scheduler` неявно уничтожается, когда все внешние ссылки на него прекращают существовать.

```cpp
virtual ~Scheduler();
```

## <a name="scheduletask"></a>ScheduleTask

Планирует облегченную задачу в планировщике. Упрощенная задача будет размещена в группе расписаний, определенной средой выполнения. Версия, принимающая параметр `_Placement`, склоняет задачу к выполнению в указанном расположении.

```cpp
virtual void ScheduleTask(
    TaskProc _Proc,
    _Inout_opt_ void* _Data) = 0;

virtual void ScheduleTask(
    TaskProc _Proc,
    _Inout_opt_ void* _Data,
    location& _Placement) = 0;
```

### <a name="parameters"></a>Параметры

*_Proc*<br/>
Указатель на функцию, которая должна быть выполнена, чтобы выполнить задачу неплотности.

*_Data*<br/>
Указатель типа void на данные, которые будут переданы в качестве параметра в текст задачи.

*_Placement*<br/>
Ссылка на расположение, где будет склонна выполняться упрощенная задача.

## <a name="setdefaultschedulerpolicy"></a>SetDefaultSchedulerPolicy

Позволяет использовать определенную пользователем политику для создания планировщика по умолчанию. Этот метод можно вызывать только в том случае, если в процессе не существует планировщика по умолчанию. После установки политики по умолчанию она остается действующей до следующего допустимого вызова метода `SetDefaultSchedulerPolicy` или [ресетдефаултсчедулерполици](#resetdefaultschedulerpolicy) .

```cpp
static void __cdecl SetDefaultSchedulerPolicy(const SchedulerPolicy& _Policy);
```

### <a name="parameters"></a>Параметры

*_Policy*<br/>
Политика, которая должна быть задана в качестве политики планировщика по умолчанию.

### <a name="remarks"></a>Примечания

Если метод `SetDefaultSchedulerPolicy` вызывается, когда в процессе уже существует планировщик по умолчанию, среда выполнения выдаст исключение [default_scheduler_exists](default-scheduler-exists-class.md) .

## <a name="see-also"></a>См. также раздел

[Пространство имен concurrency](concurrency-namespace.md)<br/>
[Класс Scheduler](scheduler-class.md)<br/>
[PolicyElementKey](concurrency-namespace-enums.md)<br/>
[Планировщик заданий](../../../parallel/concrt/task-scheduler-concurrency-runtime.md)
