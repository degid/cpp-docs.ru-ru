---
title: Параллелизм задач (среда выполнения с параллелизмом)
ms.date: 11/04/2016
helpviewer_keywords:
- structured task groups [Concurrency Runtime]
- structured tasks [Concurrency Runtime]
- task groups [Concurrency Runtime]
- task parallelism
- tasks [Concurrency Runtime]
ms.assetid: 42f05ac3-2098-494a-ba84-737fcdcad077
ms.openlocfilehash: 09c6153a1440684156226acbda909ca8b0398989
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87224933"
---
# <a name="task-parallelism-concurrency-runtime"></a>Параллелизм задач (среда выполнения с параллелизмом)

В среда выполнения с параллелизмом *задача* — это единица работы, которая выполняет определенное задание и обычно выполняется параллельно с другими задачами. Задачу можно разложить на дополнительные, более детализированные задачи, упорядоченные в *группу задач*.

Задачи используются, когда при создании асинхронного кода требуется, чтобы после завершения асинхронной операции выполнялись некоторые операции. Например, можно использовать задачу для асинхронного считывания из файла, а затем использовать другую задачу — *задачу продолжения*, которая описана далее в этом документе, для обработки данных после того, как она станет доступной. И наоборот, можно использовать группы задач для разбиения параллельной работы на более мелкие части. Например, предположим, что имеется рекурсивный алгоритм, разделяющий оставшуюся работу на два раздела. С помощью групп задач вы можете одновременно запустить эти разделы, а затем подождать, пока выполнится эта разделенная задача.

> [!TIP]
> Если необходимо применить одну и ту же подпрограммы к каждому элементу коллекции параллельно, используйте параллельный алгоритм, например [concurrency::parallel_for](reference/concurrency-namespace-functions.md#parallel_for), а не задачу или группу задач. Дополнительные сведения о параллельных алгоритмах см. в разделе [Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md).

## <a name="key-points"></a>Основные моменты

- При передаче переменных в лямбда-выражение по ссылке необходимо обеспечить сохранение существования этой переменной до завершения задачи.

- Используйте задачи (класс [concurrency::Task](../../parallel/concrt/reference/task-class.md) ) при написании асинхронного кода. Класс задач использует в качестве своего планировщика Windows ThreadPool (пул потоков Windows), а не среду выполнения с параллелизмом.

- Используйте группы задач (класс [concurrency::task_group](reference/task-group-class.md) или метод [concurrency::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) алгоритм), если необходимо разложить параллельную работу на небольшие части, а затем дождаться завершения этих меньших частей.

- Для создания продолжений используйте метод [concurrency::Task:: then](reference/task-class.md#then) . *Продолжение* — это задача, которая выполняется асинхронно после завершения другой задачи. Вы можете подключать любое количество продолжений для формирования цепочки асинхронной работы.

- Продолжение на основе задачи всегда планируется для выполнения после завершения предшествующей задачи, даже если предшествующая задача отменяется или создает исключение.

- Используйте [concurrency::when_all](reference/concurrency-namespace-functions.md#when_all) , чтобы создать задачу, которая завершается после завершения каждого члена набора задач. Используйте [concurrency::when_any](reference/concurrency-namespace-functions.md#when_any) , чтобы создать задачу, которая завершается после завершения одного члена набора задач.

- Задачи и группы задач могут участвовать в механизме отмены библиотеки параллельных шаблонов (PPL). Дополнительные сведения см. [в разделе об отмене в PPL](cancellation-in-the-ppl.md).

- Сведения о том, как среда выполнения обрабатывает исключения, создаваемые задачами и группами задач, см. в разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

## <a name="in-this-document"></a>В этом документе

- [Использование лямбда-выражений](#lambdas)

- [Класс task](#task-class)

- [Задачи продолжения](#continuations)

- [Сравнение продолжения на основе значения и на основе задачи](#value-versus-task)

- [Составление задач](#composing-tasks)

  - [Функция when_all](#when-all)

  - [Функция when_any](#when-any)

- [Отложенное выполнение задач](#delayed-tasks)

- [Группы задач](#task-groups)

- [Сравнение task_group и structured_task_group](#comparing-groups)

- [Пример](#example)

- [Надежное программирование](#robust)

## <a name="using-lambda-expressions"></a><a name="lambdas"></a>Использование лямбда-выражений

Благодаря их лаконичному синтаксису лямбда-выражения часто используют для определения операций, выполняемых задачами и группами задач. Ниже приведены некоторые советы по использованию.

- Поскольку задачи обычно выполняются в фоновых потоках, помните о времени существования объекта при включении переменных в лямбда-выражения. При вводе переменной по значению в тексте лямбда-выражения создается копия этой переменной. При вводе по ссылке копия не создается. Следовательно, необходимо убедиться, что время существования любой введенной по ссылке переменной превышает время существования задачи, которая ее использует.

- При передаче лямбда-выражения задаче не следует захватывать переменные, выделенные в стеке по ссылке.

- Должны быть явными для переменных, захваченных в лямбда-выражениях, чтобы можно было определить, какие данные записываются по значению, а по ссылке. По этой причине рекомендуется не использовать параметры `[=]` или `[&]` для лямбда-выражений.

Распространенный подход заключается в том, что одна задача в цепочке продолжения назначает переменную, а другая задача читает эту переменную. Вы не можете записать по значению, так как каждая задача продолжения будет содержать другую копию переменной. Для переменных, выделенных в стеке, вы также не можете записать по ссылке, так как переменная может быть недействительной.

Чтобы решить эту проблему, используйте интеллектуальный указатель, например [std:: shared_ptr](../../standard-library/shared-ptr-class.md), чтобы заключить переменную и передать смарт-указатель по значению. Таким образом этот базовый объект можно назначать и читать, и срок его существования будет превышать срок существования задач, которые его используют. Используйте этот метод даже в том случае, если переменная является указателем или дескриптором с подсчетом ссылок (`^`) объекта среды выполнения Windows. Простой пример:

[!code-cpp[concrt-lambda-task-lifetime#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_1.cpp)]

Дополнительные сведения о лямбда-выражениях см. в разделе [лямбда-выражения](../../cpp/lambda-expressions-in-cpp.md).

## <a name="the-task-class"></a><a name="task-class"></a>Класс Task

Для составления задач в набор зависимых операций можно использовать класс [concurrency::Task](../../parallel/concrt/reference/task-class.md) . Эта модель композиции поддерживается понятием *продолжений*. Продолжение позволяет выполнять код при завершении предыдущей или *предшествующей*задачи. Результат предшествующей задачи передается в качестве входных данных в одну или несколько задач продолжения. По завершении предшествующей задачи все ожидающие ее задачи продолжения планируются для выполнения. Каждая задача продолжения получает копию результатов предшествующей задачи. В свою очередь, эти задачи продолжения также могут быть предшествующими задачами для других продолжений, тем самым создавая цепочки задач. Продолжения помогают создавать цепочки задач произвольной длины с определенными зависимостями между входящими в них задачами. Кроме того, задача может участвовать в отмене либо до запуска, либо совместно во время выполнения. Дополнительные сведения об этой модели отмены см. [в разделе Отмена в библиотеке PPL](cancellation-in-the-ppl.md).

`task` является классом шаблона. Параметр типа `T` — это тип результата, созданного задачей. Этот тип может быть **`void`** , если задача не возвращает значение. `T`нельзя использовать **`const`** модификатор.

При создании задачи вы предоставляете *рабочую функцию* , которая выполняет тело задачи. Эта рабочая функция поступает в виде лямбда-функции, указателя функции или объекта функции. Чтобы дождаться завершения задачи без получения результата, вызовите метод [concurrency::Task:: wait](reference/task-class.md#wait) . `task::wait`Метод возвращает значение [concurrency::task_status](reference/concurrency-namespace-enums.md#task_group_status) , которое описывает, была ли задача завершена или отменена. Чтобы получить результат задачи, вызовите метод [concurrency::Task:: Get](reference/task-class.md#get) . Этот метод вызывает метод `task::wait` для ожидания завершения задачи и таким образом блокирует выполнение текущего потока, пока не станет доступен результат.

В следующем примере показано, как создать задачу, дождаться ее результата и отобразить полученное значение. В примерах в этой документации используются лямбда-функции, поскольку они обеспечивают более лаконичный синтаксис. Однако при использовании задач вы также можете применять указатели функций и объекты функций.

[!code-cpp[concrt-basic-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_2.cpp)]

При использовании функции [concurrency::create_task](reference/concurrency-namespace-functions.md#create_task) можно использовать **`auto`** ключевое слово вместо объявления типа. Например, рассмотрим следующий код, который создает и печатает матрицу тождественности.

[!code-cpp[concrt-create-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_3.cpp)]

Вы можете использовать функцию `create_task` для создания эквивалентной операции.

[!code-cpp[concrt-create-task#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_4.cpp)]

Если во время выполнения задачи возникает исключение, среда выполнения маршалирует исключение в последующий вызов метода `task::get` или `task::wait`, или в продолжение на основе задачи. Дополнительные сведения о механизме обработки исключений задач см. в разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

Пример, в котором используется метод `task` , [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md), Отмена, см. в разделе [Пошаговое руководство. подключение с использованием задач и HTTP-запросов XML](../../parallel/concrt/walkthrough-connecting-using-tasks-and-xml-http-requests.md). (Класс `task_completion_event` описывается далее в этом документе.)

> [!TIP]
> Дополнительные сведения о задачах в приложениях UWP см. в статье [Асинхронное программирование на c++](/windows/uwp/threading-async/asynchronous-programming-in-cpp-universal-windows-platform-apps) и [Создание асинхронных операций в C++ для приложений UWP](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).

## <a name="continuation-tasks"></a><a name="continuations"></a>Задачи продолжения

В асинхронном программировании очень распространено при завершении одной асинхронной операции вызывать вторую операцию и передавать в нее данные. Как правило, это делается с помощью методов обратного вызова. В среда выполнения с параллелизмом те же функциональные возможности предоставляются *задачами продолжения*. Задача продолжения (также известная как продолжение) — это асинхронная задача, которая вызывается другой задачей, которая называется *предшествующей*, после завершения предшествующей задачи. С помощью продолжений вы можете делать следующее.

- Передавать данные из предшествующей задачи в продолжение.

- Указывать точные условия, при которых продолжение вызывается или не вызывается.

- Отменять продолжение перед его запуском либо совместно во время его выполнения.

- Определять подсказки, как должно планироваться продолжение. (Это относится только к приложениям универсальная платформа Windows (UWP). Дополнительные сведения см. [в статье Создание асинхронных операций в C++ для приложений UWP](../../parallel/concrt/creating-asynchronous-operations-in-cpp-for-windows-store-apps.md).)

- Вызывать несколько продолжений из одной и той же предшествующей задачи.

- Вызывать одно продолжение по завершении всех или одной из нескольких предшествующих задач.

- Прикреплять продолжения одно после другого до любой длины.

- Использовать продолжение для обработки исключений, вызванных предшествующей задачей.

Эти возможности позволяют выполнять одну или несколько задач после завершения первой задачи. Например, можно создать продолжение, которое сжимает файл после того, как первая задача прочитает этот файл с диска.

Следующий пример изменяет предыдущий, чтобы использовать метод [concurrency::Task:: then](reference/task-class.md#then) , чтобы запланировать продолжение, которое выводит значение предшествующей задачи, когда она доступна.

[!code-cpp[concrt-basic-continuation#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_5.cpp)]

Вы можете прикреплять и вкладывать задачи до любой длины. Задача также может иметь несколько продолжений. В следующем примере демонстрируется базовая цепочка продолжений, которая увеличивает значение предыдущей задачи три раза.

[!code-cpp[concrt-continuation-chain#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_6.cpp)]

Продолжение может также возвращать другую задачу. Если отмена отсутствует, то эта задача выполняется до последующего продолжения. Этот прием называется *асинхронным*распаковкой. Асинхронное развертывание удобно использовать, когда требуется выполнить дополнительную работу в фоновом режиме, но так, чтобы текущая задача не блокировала текущий поток. (Это распространено в приложениях UWP, где продолжение может выполняться в потоке пользовательского интерфейса). В следующем примере показаны три задачи. Первая задача возвращает вторую задачу, которая выполняется перед задачей продолжения.

[!code-cpp[concrt-async-unwrapping#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_7.cpp)]

> [!IMPORTANT]
> Когда продолжение задачи возвращает вложенную задачу типа `N`, результирующая задача имеет тип `N`, а не `task<N>`, и завершается при завершении вложенной задачи. Другими словами, продолжение выполняет развертывание вложенной задачи.

## <a name="value-based-versus-task-based-continuations"></a><a name="value-versus-task"></a>Сравнение продолжений на основе значений и задач

Принимая во внимание объект `task`, который имеет возвращаемый тип `T`, вы можете предоставить значение типа `T` или `task<T>` в соответствующие задачи продолжения. Продолжение, принимающее тип, `T` называется *продолжением на основе значения*. Продолжение на основе значения планируется для выполнения, когда предшествующая задача завершается без ошибок и не отменяется. Продолжение, принимающее тип `task<T>` в качестве параметра, называется *продолжением на основе задачи*. Продолжение на основе задачи всегда планируется для выполнения после завершения предшествующей задачи, даже если предшествующая задача отменяется или создает исключение. Затем можно вызвать `task::get`, чтобы получить результат предшествующей задачи. Если предшествующая задача была отменена, `task::get` вызывается метод [concurrency::task_canceled](../../parallel/concrt/reference/task-canceled-class.md). Если предшествующая задача выдала исключение, `task::get` повторно выдает это исключение. Продолжение на основе задачи не отмечается как отмененное, когда отменяется предшествующая задача.

## <a name="composing-tasks"></a><a name="composing-tasks"></a>Составление задач

В этом разделе описываются функции [concurrency::when_all](reference/concurrency-namespace-functions.md#when_all) и [concurrency::when_any](reference/concurrency-namespace-functions.md#when_all) , которые могут помочь составить несколько задач для реализации общих шаблонов.

### <a name="the-when_all-function"></a><a name="when-all"></a>Функция when_all

Функция `when_all` создает задачу, которая выполняется после завершения набора задач. Эта функция возвращает объект std::[vector](../../standard-library/vector-class.md) , который содержит результат каждой задачи в наборе. В следующем базовом примере функция `when_all` используется для создания задачи, которая представляет завершение трех других задач.

[!code-cpp[concrt-join-tasks#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_8.cpp)]

> [!NOTE]
> Задачи, которые вы передаете в функцию `when_all`, должны быть единообразными. Другими словами, все они должны возвращать один и тот же тип.

Для создания задачи, выполняемой после завершения набора задач, можно также использовать синтаксис `&&`, как показано в следующем примере.

`auto t = t1 && t2; // same as when_all`

Обычно для выполнения действия после завершения набора задач используется продолжение вместе с функцией `when_all`. Следующий пример изменяет предыдущий, чтобы напечатать сумму трех задач, каждый из которых формирует **`int`** результат.

[!code-cpp[concrt-join-tasks#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_9.cpp)]

В этом примере можно также указать `task<vector<int>>`, чтобы создать продолжение на основе задачи.

Если какая-либо из задач в наборе задач отменяется или порождает исключение, `when_all` немедленно завершается и не ждет завершения выполнения оставшихся задач. Если выдается исключение, среда выполнения повторно выдает это исключение при вызове `task::get` или `task::wait` в объекте задачи, который возвращает `when_all`. Если исключение выдают несколько задач, среда выполнения выбирает одну из них. Поэтому убедитесь, что вы заметили все исключения после завершения всех задач; необработанное исключение задачи приведет к завершению работы приложения.

Ниже приведена служебная функция, которую можно использовать, чтобы убедиться, что программа отслеживает все исключения. Для каждой задачи в указанном диапазоне эта служебная функция `observe_all_exceptions` запускает повторную выдачу каждого возникшего исключения, а затем поглощает это исключение.

[!code-cpp[concrt-eh-when_all#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_10.cpp)]

Рассмотрим приложение UWP, которое использует C++ и XAML и записывает набор файлов на диск. В следующем примере показано, как использовать функции `when_all` и `observe_all_exceptions`, чтобы убедиться, что программа обнаруживает все исключения.

[!code-cpp[concrt-eh-when_all#2](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_11.cpp)]

##### <a name="to-run-this-example"></a>Запуск примера

1. Добавьте в файл MainPage.xaml элемент управления `Button`.

[!code-xml[concrt-eh-when_all#3](../../parallel/concrt/codesnippet/xaml/task-parallelism-concurrency-runtime_12.xaml)]

1. В MainPage. XAML.h добавьте эти прямые объявления в **`private`** раздел `MainPage` объявления класса.

[!code-cpp[concrt-eh-when_all#4](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_13.h)]

1. В MainPage.xaml.cpp реализуйте обработчик событий `Button_Click`.

[!code-cpp[concrt-eh-when_all#5](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_14.cpp)]

1. В MainPage.xaml.cpp реализуйте `WriteFilesAsync`, как показано в примере.

> [!TIP]
> Функция `when_all` является функцией без блокировки, в качестве результата создающей `task`. В отличие от [Task:: wait](reference/task-class.md#wait), эту функцию можно вызывать в приложении UWP в потоке ASTA (Application STA).

### <a name="the-when_any-function"></a><a name="when-any"></a>Функция when_any

Функция `when_any` создает задачу, которая выполняется после завершения первой задачи в наборе задач. Эта функция возвращает объект [Air std::p](../../standard-library/pair-structure.md) , который содержит результат завершенной задачи, и индекс этой задачи в наборе.

Функция `when_any` особенно полезна в следующих ситуациях.

- Избыточные операции. Рассмотрим алгоритм или операцию, которые можно выполнить несколькими способами. Функцию `when_any` можно использовать для выбора операции, которая завершается первой, и последующей отмены оставшихся операций.

- Операции с чередованием. Можно запустить несколько операций, которые все должны завершиться, и использовать функцию `when_any` для обработки результатов при завершении каждой операции. После завершения одной операции можно запустить одну или несколько дополнительных задач.

- Регулируемые операции. Функцию `when_any` можно использовать для расширения предыдущего сценария путем ограничения количества параллельных операций.

- Операции с истекшим сроком действия. Функцию `when_any` можно использовать, чтобы сделать выбор между одной или несколькими задачами и задачей, завершающейся после определенного времени.

Как и в случае с функцией `when_all`, обычно для выполнения действия после завершения первой задачи в наборе используется продолжение, имеющее функцию `when_any`. В следующем базовом примере функция `when_any` используется для создания задачи, которая выполняется после завершения первой из трех других задач.

[!code-cpp[concrt-select-task#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_15.cpp)]

В этом примере можно также указать `task<pair<int, size_t>>`, чтобы создать продолжение на основе задачи.

> [!NOTE]
> Как и при использовании функции `when_all`, задачи, которые вы передаете в `when_any`, должны возвращать один и тот же тип.

Для создания задачи, выполняемой после завершения первой задачи в наборе, можно также использовать синтаксис `||`, как показано в следующем примере.

`auto t = t1 || t2; // same as when_any`

> [!TIP]
> Как и `when_all` , `when_any` не является блокирующим и является типобезопасным для вызова в приложении UWP в потоке ASTA.

## <a name="delayed-task-execution"></a><a name="delayed-tasks"></a>Выполнение отложенных задач

Иногда требуется отложить выполнение задачи до выполнения условия или запустить задачу в ответ на внешнее событие. Например, в асинхронном программировании может потребоваться запустить задачу в ответ на событие завершения операции ввода-вывода.

Это можно сделать двумя способами: использовать продолжение или для запуска задачи и ожидания события в рабочей функции задачи. Однако бывают случаи, когда невозможно использовать ни один из этих способов. Например, чтобы создать продолжение, необходимо иметь предшествующую задачу. Однако если у вас нет предшествующей задачи, можно создать *событие завершения задачи* и позднее связать событие завершения с предшествующей задачей, когда она станет доступной. Кроме того, поскольку ожидающая задача также блокирует поток, можно использовать события завершения задачи для выполнения работы при завершении асинхронной операции и тем самым освободить поток.

Класс [concurrency::task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md) упрощает такую композицию задач. Как и в классе `task`, параметр типа `T` — это тип результата, созданного задачей. Этот тип может быть **`void`** , если задача не возвращает значение. `T`нельзя использовать **`const`** модификатор. Как правило, объект `task_completion_event` передается в поток или задачу, которые будут сообщать, когда значение для них станет доступным. В то же время одна или несколько задач устанавливаются в качестве прослушивателей этого события. Когда событие возникает, задачи прослушивателя выполняются и их продолжения планируются для запуска.

Пример использования `task_completion_event` для реализации задачи, которая завершается после задержки, см. [в разделе как создать задачу, которая завершается после некоторой задержки](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md).

## <a name="task-groups"></a><a name="task-groups"></a>Группы задач

*Группа задач* организует коллекцию задач. Группы задач помещают задачи в очередь перехвата работы. Планировщик удаляет задачи из этой очереди и выполняет их с использованием доступных вычислительных ресурсов. После добавления задач в группу задач можно ожидать завершения всех задач или отменить задачи, которые еще не запускались.

PPL использует классы [concurrency::task_group](reference/task-group-class.md) и [concurrency::structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md) для представления групп задач, а также класс [concurrency::task_handle](../../parallel/concrt/reference/task-handle-class.md) для представления задач, выполняемых в этих группах. Класс `task_handle` инкапсулирует код, выполняющий работу. Как и в случае класса `task`, эта рабочая функция поступает в виде лямбда-функции, указателя функции или объекта функции. Обычно не требуется работать с объектами `task_handle` напрямую. Вместо этого вы передаете рабочие функции в группу задач, а группа задач создает объекты `task_handle` и управляет ими.

PPL разделяет группы задач на следующие две категории: *неструктурированные группы задач* и *структурированные группы задач*. PPL использует класс `task_group` для представления неструктурированных групп задач и класс `structured_task_group` — для представления структурированных групп задач.

> [!IMPORTANT]
> PPL также определяет алгоритм [параллелизма::parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke) , который использует `structured_task_group` класс для параллельного выполнения набора задач. Поскольку алгоритм `parallel_invoke` имеет более лаконичный синтаксис, рекомендуется по возможности использовать его вместо класса `structured_task_group`. Раздел [Параллельные алгоритмы](../../parallel/concrt/parallel-algorithms.md) `parallel_invoke` более подробно описывается в разделе.

Используйте алгоритм `parallel_invoke`, когда имеется несколько независимых задач, которые требуется выполнить одновременно, и перед продолжением необходимо дождаться завершения всех задач. Этот метод часто называют параллелизмом *разветвления и соединений* . Используйте алгоритм `task_group`, когда имеется несколько независимых задач, которые требуется выполнить одновременно, но дождаться завершения всех задач требуется позднее. Например, вы можете добавить задачи в объект `task_group` и дожидаться завершения этих задач в другой функции или из другого потока.

Группы задач поддерживают принцип отмены. Отмена позволяет сообщить всем активным задачам, что необходимо отменить всю операцию. Отмена также предотвращает запуск задач, которые еще не начали выполняться. Дополнительные сведения об отмене см. [в разделе Отмена в библиотеке PPL](cancellation-in-the-ppl.md).

Среда выполнения также предоставляет модель обработки исключений, которая позволяет вызывать исключение из задачи и обработать это исключение при ожидании завершения группы связанных задач. Дополнительные сведения об этой модели обработки исключений см. в разделе [обработка исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

## <a name="comparing-task_group-to-structured_task_group"></a><a name="comparing-groups"></a>Сравнение task_group с structured_task_group

Несмотря на то что мы рекомендуем использовать `task_group` или `parallel_invoke` вместо класса `structured_task_group`, бывают ситуации, в которых вы захотите использовать класс `structured_task_group`, например при создании параллельного алгоритма, который выполняет переменное количество задач или которому требуется поддержка отмены. В этом разделе описываются различия между классами `task_group` и `structured_task_group`.

Класс `task_group` является потокобезопасным. Поэтому можно добавлять задачи в объект `task_group` из нескольких потоков и ожидать или отменять объект `task_group` из нескольких потоков. Создание и уничтожение объекта `structured_task_group` должно происходить в одной лексической области. Кроме того, все операции с объектом `structured_task_group` должны происходить в одном потоке. Исключением из этого правила являются методы [concurrency::structured_task_group:: Cancel](reference/structured-task-group-class.md#cancel) и [concurrency::structured_task_group:: is_canceling](reference/structured-task-group-class.md#is_canceling) . Дочерняя задача может вызывать эти методы для отмены родительской группы задач или проверки на предмет отмены в любое время.

Можно выполнять дополнительные задачи над `task_group` объектом после вызова метода [concurrency::task_group:: wait](reference/task-group-class.md#wait) или [concurrency::task_group:: run_and_wait](reference/task-group-class.md#run_and_wait) . И наоборот, при выполнении дополнительных задач над `structured_task_group` объектом после вызова методов [concurrency::structured_task_group:: wait](reference/structured-task-group-class.md#wait) или [concurrency::structured_task_group:: run_and_wait](reference/structured-task-group-class.md#run_and_wait) поведение не определено.

Поскольку класс `structured_task_group` не синхронизируется в потоках, он имеет меньше затрат на выполнение, чем класс `task_group`. Таким образом, если проблема не требует планирования работы в нескольких потоках и нельзя использовать алгоритм `parallel_invoke`, класс `structured_task_group` класс может помочь написать более производительный код.

При использовании одного объекта `structured_task_group` внутри другого объекта `structured_task_group` внутренний объект должен быть завершен и уничтожен до завершения внешнего объекта. Класс `task_group` не требуется для завершения вложенных групп задач до завершения внешней группы.

Неструктурированные группы задач и структурированные группы задач работают с дескрипторами задач по-разному. Вы можете передавать рабочие функции непосредственно в объект `task_group`; объект `task_group` будет создавать дескриптор задач и управлять им. Класс `structured_task_group` требует, чтобы вы управляли объектом `task_handle` для каждой задачи. Каждый объект `task_handle` должен оставаться допустимым в течение всего времени существования связанного объекта `structured_task_group`. Используйте функцию [concurrency::make_task](reference/concurrency-namespace-functions.md#make_task) , чтобы создать `task_handle` объект, как показано в следующем примере:

[!code-cpp[concrt-make-task-structure#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_16.cpp)]

Для управления дескрипторами задач в случаях, когда имеется переменное число задач, используйте подпрограммы выделения стека, например [_malloca](../../c-runtime-library/reference/malloca.md) или класс контейнера, например std::[vector](../../standard-library/vector-class.md).

И `task_group`, и `structured_task_group` поддерживают отмену. Дополнительные сведения об отмене см. [в разделе Отмена в библиотеке PPL](cancellation-in-the-ppl.md).

## <a name="example"></a><a name="example"></a> Пример

В следующем базовом примере показано, как работать с группами задач. В этом примере используется алгоритм `parallel_invoke` для выполнения двух задач одновременно. Каждая задача добавляет подзадачи в объект `task_group`. Обратите внимание, что класс `task_group` позволяет добавлять в него задачи одновременно нескольким задачам.

[!code-cpp[concrt-using-task-groups#1](../../parallel/concrt/codesnippet/cpp/task-parallelism-concurrency-runtime_17.cpp)]

Ниже приведен пример выходных данных для данного примера.

```Output
Message from task: Hello
Message from task: 3.14
Message from task: 42
```

Поскольку алгоритм `parallel_invoke` выполняет задачи параллельно, порядок выходных сообщений может меняться.

Полные примеры, демонстрирующие использование `parallel_invoke` алгоритма, см. в разделе [как использовать parallel_invoke для написания параллельной подпрограммы сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md) и [как использовать parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md). Полный пример использования `task_group` класса для реализации асинхронных фьючерсов см. в разделе [Пошаговое руководство. Реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md).

## <a name="robust-programming"></a><a name="robust"></a>Надежное программирование

Убедитесь, что понимаете роль отмены и обработки исключений при использовании задач, групп задач и параллельных алгоритмов. Например, в дереве параллельной работы отмененная задача предотвращает запуск дочерних задач. Это может привести к проблемам, если одна из дочерних задач выполняет операцию, важную для приложения, например высвобождает ресурс. Кроме того, если дочерняя задача создает исключение, это исключение может распространиться через деструктор объекта и вызвать неопределенное поведение в приложении. Пример, демонстрирующий эти моменты, см. в разделе понимание того, [как отмена и обработка исключений влияет на уничтожение объектов](../../parallel/concrt/best-practices-in-the-parallel-patterns-library.md#object-destruction) в рекомендациях в документе Библиотека параллельных шаблонов. Дополнительные сведения о моделях отмены и обработки исключений в PPL см. в разделе [об отмене](../../parallel/concrt/cancellation-in-the-ppl.md) и [обработке исключений](../../parallel/concrt/exception-handling-in-the-concurrency-runtime.md).

## <a name="related-topics"></a>См. также

|Заголовок|Описание:|
|-----------|-----------------|
|[Как использовать parallel_invoke для написания параллельной подпрограммы сортировки](../../parallel/concrt/how-to-use-parallel-invoke-to-write-a-parallel-sort-routine.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности алгоритма битонной сортировки.|
|[Инструкции. Использование parallel_invoke для выполнения параллельных операций](../../parallel/concrt/how-to-use-parallel-invoke-to-execute-parallel-operations.md)|Показывается, как использовать алгоритм `parallel_invoke` для повышения производительности программы, выполняющей несколько операций с общим источником данных.|
|[Как создать задачу, которая завершается после задержки](../../parallel/concrt/how-to-create-a-task-that-completes-after-a-delay.md)|Показывает, как использовать `task` классы, `cancellation_token_source` , `cancellation_token` и `task_completion_event` для создания задачи, которая завершается после некоторой задержки.|
|[Пошаговое руководство. Реализация фьючерсов](../../parallel/concrt/walkthrough-implementing-futures.md)|Показано, как объединить существующие функциональные возможности в среде выполнения с параллелизмом в то, что делает больше.|
|[Библиотека параллельных шаблонов](../../parallel/concrt/parallel-patterns-library-ppl.md)|Описывается библиотека PPL, которая предоставляет императивную модель программирования для разработки параллельных приложений.|

## <a name="reference"></a>Справочник

[Класс Task (среда выполнения с параллелизмом)](../../parallel/concrt/reference/task-class.md)

[Класс task_completion_event](../../parallel/concrt/reference/task-completion-event-class.md)

[Функция when_all](reference/concurrency-namespace-functions.md#when_all)

[Функция when_any](reference/concurrency-namespace-functions.md#when_any)

[Класс task_group](reference/task-group-class.md)

[Функция parallel_invoke](reference/concurrency-namespace-functions.md#parallel_invoke)

[Класс structured_task_group](../../parallel/concrt/reference/structured-task-group-class.md)
