---
title: property (C++/CLI и C++/CX)
ms.date: 10/12/2018
ms.topic: reference
helpviewer_keywords:
- property keyword [C++]
ms.assetid: cc79d2b2-f013-4d81-8252-eece97a18704
ms.openlocfilehash: fbec97a5bd30bb9bb76459ef2f7b0956ae6a264f
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87225141"
---
# <a name="property--ccli-and-ccx"></a>property (C++/CLI и C++/CX)

Объявляет *свойство*, являющееся функцией-членом, которая действует и доступна как элемент данных или элемент массива.

## <a name="all-runtimes"></a>Все среды выполнения

Можно объявить один из следующих типов свойств.

*Простое свойство*<br/>
По умолчанию создает *метод доступа set*, который присваивает значение свойства, *метод доступа get*, получающий значение свойства и создаваемый компилятором закрытый элемент данных, что содержит значение свойства.

*Блок свойств*<br/>
Используется для создания определяемых пользователем методов доступа get и/или set. Свойство доступно для чтения и записи, если заданы оба метода доступа — get и set, доступно только для чтения, если задан только метод доступа get, и доступно только для записи, если задан только метод доступа set.

Вы должны явно объявить элемент данных для хранения значения свойства.

*Индексированное свойство*<br/>
Блок свойств, который можно использовать для получения и задания значения свойства, указанного одним или несколькими индексами.

Вы можете создать индексированное свойство, которое имеет либо заданное пользователем имя, либо имя *по умолчанию*. Имя свойства индекса по умолчанию — это имя класса, в котором это свойство определено. Чтобы объявить свойство по умолчанию, укажите **`default`** ключевое слово вместо имени свойства.

Вы должны явно объявить элемент данных для хранения значения свойства. Для индексированного свойства элементом данных обычно является массив или коллекция.

### <a name="syntax"></a>Синтаксис

```cpp
property type property_name;

property type property_name {
   access-modifier type get() inheritance-modifier {property_body};
   access-modifier void set(type value) inheritance-modifier {property_body};
}

property type property_name[index_list] {
   access-modifier type get(index_list) inheritance-modifier {property_body};
   access-modifier void set(index_list, value) inheritance-modifier {property_body};
}

property type default[index_list] {
   access-modifier type get(index_list) inheritance-modifier {property_body};
   access-modifier void set(index_list, value) inheritance-modifier {property_body};
}
```

### <a name="parameters"></a>Параметры

*type*<br/>
Тип данных значения свойства и, следовательно, самого свойства.

*property_name*<br/>
Имя свойства.

*access-modifier*<br/>
Квалификатор доступа. Допустимые квалификаторы: **`static`** и **`virtual`** .

Методы доступа get или Set не должны быть согласованы с **`virtual`** квалификатором, но они должны согласовать **`static`** квалификатор.

*inheritance-modifier*<br/>
Квалификатор наследования. Допустимые квалификаторы — **абстрактный** и **запечатанный**.

*index_list*<br/>
Разделенный запятыми список из одного или нескольких индексов. Каждый индекс состоит из типа индекса и необязательного идентификатора, который может использоваться в теле метода свойства.

*value*<br/>
Значение для назначения свойству в операции set или извлечения в операции get.

*property_body*<br/>
Тело метода свойства метода доступа set или get. Параметр *property_body* может использовать *index_list* для доступа к базовому элементу данных свойства или в качестве параметров в пользовательской обработке.

## <a name="windows-runtime"></a>Среда выполнения Windows

Дополнительные сведения см. в разделе [Свойства (C++/CX)](../cppcx/properties-c-cx.md).

### <a name="requirements"></a>Требования

Параметр компилятора: `/ZW`

## <a name="common-language-runtime"></a>Среда CLR

### <a name="syntax"></a>Синтаксис

```cpp
modifier property type property_name;

modifier property type property_name {
   modifier void set(type);
   modifier type get();
}
modifier property type property_name[index-list, value] {
   modifier void set(index-list, value);
   modifier type get(index-list);

modifier property type default[index];
}
```

### <a name="parameters"></a>Параметры

*Модификатор*<br/>
Модификатор, который может использоваться в объявлении свойства или в методе доступа get/set свойства. Возможные значения: **`static`** и **`virtual`** .

*type*<br/>
Тип значения, представленного свойством.

*property_name*<br/>
Параметр или параметры для метода raise; необходимо соответствие сигнатуре делегата.

*index_list*<br/>
Разделенный запятыми список из одного или нескольких индексов, указанных в квадратных скобках (оператор индекса, ([])). Для каждого индекса укажите тип и (необязательно) идентификатор, который может использоваться в теле метода свойства.

### <a name="remarks"></a>Примечания

В первом примере синтаксиса показано *простое свойство*, которое неявно объявляет методы `set` и `get`. Компилятор автоматически создает закрытое поле для хранения значения свойства.

Во втором примере синтаксиса показан *блок свойств*, который явно объявляет методы `set` и `get`.

В третьем примере синтаксиса показано определяемое пользователем *свойство индекса*. Свойство индекса принимает параметры, а также значение для установки или получения. Необходимо указать имя для свойства. В отличие от простого свойства методы `set` и `get` свойства индекса должны быть явно определены, и необходимо указать имя для свойства.

В четвертом примере синтаксиса показано свойство *по умолчанию*, которое предоставляет подобный массиву доступ к экземпляру типа. Ключевое слово, **`default`** , служит только для указания свойства по умолчанию. Имя свойства по умолчанию — это имя типа, в котором это свойство определено.

**`property`** Ключевое слово может присутствовать в классе, интерфейсе или типе значения. Свойство может иметь функцию get (только чтение), функцию set (только запись) или обе эти функции (чтение и запись).

Имя свойства не может совпадать с именем управляемого класса, к которому оно относится. Функция получения свойства должна иметь тип, который совпадает с типом последнего параметра в соответствующей функции задания свойства.

В отношении клиентского кода свойство имеет вид обычного элемента данных и может записываться или считываться с помощью того же синтаксиса, что и элемент данных.

Методы get и Set не должны договориться с **`virtual`** модификатором.

Доступность методов get и set может отличаться.

Определение метода свойства может отображаться за пределами тела класса, так же, как в случае обычного метода.

Методы get и Set для свойства должны быть согласованы с **`static`** модификатором.

Свойство является скалярным, если его методы get и set соответствуют следующему описанию.

- Метод get не имеет параметров и возвращает значение типа `T`.

- Метод Set имеет параметр типа `T` и тип возвращаемого значения **`void`** .

Должно существовать только одно скалярное свойство, объявленное в области с тем же идентификатором. Скалярные свойства не могут быть перегружены.

При объявлении элемента данных свойства компилятор вставляет элемент данных — иногда называемый «резервным хранилищем» — в класс. Однако имя элемента данных имеет такую форму, что вы не можете ссылаться на этот элемент в источнике, как если бы это был фактический элемент данных содержащего класса. Используйте Ildasm.exe для просмотра метаданных для вашего типа и созданного компилятором имени для резервного хранилища свойства.

В блоке свойств разрешается разная доступность для методов доступа.  То есть метод set может быть открытым, а метод get может быть закрытым.  Однако было бы ошибкой, если бы метод доступа имел менее строгий доступ, нежели в объявлении самого свойства.

**`property`** контекстно-зависимое ключевое слово.  Дополнительные сведения см. в статье [Context-Sensitive Keywords (C++/CLI and C++/CX)](context-sensitive-keywords-cpp-component-extensions.md) (Контекстно-зависимые ключевые слова (C++/CLI и C++/CX)).

### <a name="requirements"></a>Требования

Параметр компилятора: `/clr`

### <a name="examples"></a>Примеры

В следующем примере показано объявление и использование элемента данных свойства и блока свойств.  В этом примере также показывается, что метод доступа свойства можно определить вне класса.

```cpp
// mcppv2_property.cpp
// compile with: /clr
using namespace System;
public ref class C {
   int MyInt;
public:

   // property data member
   property String ^ Simple_Property;

   // property block
   property int Property_Block {

      int get();

      void set(int value) {
         MyInt = value;
      }
   }
};

int C::Property_Block::get() {
   return MyInt;
}

int main() {
   C ^ MyC = gcnew C();
   MyC->Simple_Property = "test";
   Console::WriteLine(MyC->Simple_Property);

   MyC->Property_Block = 21;
   Console::WriteLine(MyC->Property_Block);
}
```

```Output
test

21
```

## <a name="see-also"></a>См. также статью

[Расширения компонентов для .NET и UWP](component-extensions-for-runtime-platforms.md)
