---
title: enum class (C++/CLI и C++/CX)
ms.date: 10/12/2018
ms.topic: reference
ms.assetid: 8010fa8c-bad6-45b4-8214-b4db64d7ffe1
ms.openlocfilehash: a1b99cb2265c9a9bdb40a7239a21412123772570
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87219720"
---
# <a name="enum-class--ccli-and-ccx"></a>enum class (C++/CLI и C++/CX)

Объявляет перечисление в области видимости пространства имен, которое является определяемым пользователем типом, состоящим из ряда именованных констант, называемых перечислителями.

## <a name="all-runtimes"></a>Все среды выполнения

### <a name="remarks"></a>Примечания

C++/CX и C++/CLI поддерживают **открытый класс перечисления** и **закрытый класс перечисления**, которые схожи со стандартным **классом перечисления** C++, но с добавлением спецификатора доступа. В **/CLR** тип **класса перечисления** C++11 разрешен, но будет создавать предупреждение C4472, предназначенное для того, чтобы убедиться, что вам действительно требуется тип перечисления стандарта ISO, а не типы C++/CX или C++/CLI. Дополнительные сведения о **`enum`** ключевом слове ISO стандарта C++ см. в разделе [перечисления](../cpp/enumerations-cpp.md).

## <a name="windows-runtime"></a>Среда выполнения Windows

### <a name="syntax"></a>Синтаксис

```cpp
      access
      enum class
      enumeration-identifier
      [:underlying-type] { enumerator-list } [var];
accessenum structenumeration-identifier[:underlying-type] { enumerator-list } [var];
```

### <a name="parameters"></a>Параметры

*имеет*<br/>
Доступность перечисления, которая может иметь значение **`public`** или **`private`** .

*enumeration-identifier*<br/>
Имя перечисления.

*базовый тип*<br/>
(Необязательно) Базовый тип перечисления.

(Необязательно. Среда выполнения Windows только) базовый тип перечисления, который может быть **`bool`** , **`char`** ,,,, `char16` `int16` `uint16` **`int`** , `uint32` , `int64` или `uint64` .

*Перечислитель-список*<br/>
Разделенный запятыми список имен перечислителей.

Значением каждого перечислителя является константное выражение, которое либо явно определено компилятором, либо явно в нотации, *enumerator* `=` *константа-выражения*перечислителя. По умолчанию значение первого перечислителя ноль, если он определен неявно. Значение каждого следующего неявно определенного перечислителя — значение предыдущего перечислителя + 1.

*var*<br/>
(Необязательно) Имя переменной типа перечисления.

### <a name="remarks"></a>Примечания

Дополнительные сведения и примеры см. в разделе [Перечисления](../cppcx/enums-c-cx.md).

Обратите внимание, что компилятор выводит сообщения об ошибках, если константное выражение, задающее значение перечислителя, не может быть представлено *underlying-type*.  Однако компилятор не сообщает об ошибке для значения, недопустимого для базового типа. Пример:

- Если тип *underlying-type* числовой и перечислитель определяет максимальное значение для этого типа, то нельзя представить значение следующего неявно указанного перечисления.

- Если *базовый тип* имеет значение **`bool`** , а более двух перечислителей неявно определены, перечислители после первых двух не могут быть представлены.

- Если *underlying-type* является `char16`и значение перечисления в диапазоне от 0xD800 до 0xDFFF, то значение можно представить. Однако логически значение неверно, так как оно представляет половину пары символов-заместителей Юникода и не должно отображаться в изоляции.

### <a name="requirements"></a>Требования

Параметр компилятора: `/ZW`

## <a name="common-language-runtime"></a>Среда CLR

### <a name="syntax"></a>Синтаксис

```cpp
      access
      enum class
      name [:type] { enumerator-list } var;
accessenum structname [:type] { enumerator-list } var;
```

### <a name="parameters"></a>Параметры

*имеет*<br/>
Уровень доступа перечисления. Может иметь значение **`public`** или **`private`** .

*Перечислитель-список*<br/>
Разделенный запятыми список идентификаторов (перечислителей) в перечислении.

*name*<br/>
Имя перечисления. Анонимные управляемые перечисления не допускаются.

*type*<br/>
(Необязательно) Базовый тип *identifiers*. Это может быть любой скалярный тип, такой как подписанные или неподписанные версии **`int`** , **`short`** или **`long`** .  **`bool`****`char`** также допускается использование или.

*var*<br/>
(Необязательно) Имя переменной типа перечисления.

### <a name="remarks"></a>Примечания

**enum class** и **enum struct** являются эквивалентными объявлениями.

Существуют два типа перечислений: управляемые (C++/CX) и стандартные.

Управляемые перечисления (или перечисления C++/CX) могут быть определены следующим образом:

```cpp
public enum class day {sun, mon };
```

Это семантически эквивалентно:

```cpp
ref class day {
public:
   static const int sun = 0;
   static const int mon = 1;
};
```

Стандартное перечисление может быть определено следующим образом:

```cpp
enum day2 { sun, mon };
```

Это семантически эквивалентно:

```cpp
static const int sun = 0;
static const int mon = 1;
```

Управляемые имена перечислителей (*identifiers*) не вводятся в область, в которой определяется перечисление; все ссылки на перечислители должны быть полными (*имя*`::`*идентификатор*).  По этой причине нельзя определить анонимное управляемое перечисление.

Перечислители стандартного перечисления строго вводятся во внешнюю область.  То есть, если есть другой символ с таким же именем, как у перечислителя во внешней области видимости, компилятор выдаст ошибку.

В Visual Studio 2002 и Visual Studio 2003 перечислители были нестрого вводимыми (видимыми во внешней области, если не было другого идентификатора с таким же именем).

Если определено стандартное перечисление C++ (без **`class`** или **`struct`** ), компиляция с помощью `/clr` приведет к компиляции перечисления в качестве управляемого перечисления.  Перечисление по-прежнему имеет семантику неуправляемого перечисления.  Обратите внимание, что компилятор вводит атрибут `Microsoft::VisualC::NativeEnumAttribute` для определения намерения программиста сделать перечисление собственным.  Другие компиляторы просто увидят стандартное перечисление как управляемое перечисление.

Именованное стандартное перечисление, скомпилированное с параметром `/clr`, будет видимо в сборке как управляемое перечисление и может использоваться любым другим управляемым компилятором.   Однако безымянное стандартное перечисление не будет видимо из сборки.

В Visual Studio 2002 и Visual Studio 2003 стандартное перечисление используется в качестве типа в параметре функции.

```cpp
// mcppv2_enum.cpp
// compile with: /clr
enum E { a, b };
void f(E) {System::Console::WriteLine("hi");}

int main() {
   E myi = b;
   f(myi);
}
```

Этот код выдал бы в MSIL для сигнатуры функции следующее:

```cpp
void f(int32);
```

Однако в текущих версиях компилятора стандартное перечисление выдается как управляемое перечисление с [NativeEnumAttribute], а в MSIL для сигнатуры функции выдается следующее:

```cpp
void f(E)
```

Дополнительные сведения о неуправляемых перечислителях см. в разделе [Объявление перечислений C++](../cpp/enumerations-cpp.md).

Дополнительные сведения о перечислителях CLR см. в следующем разделе:

- [Базовый тип перечисления](../dotnet/how-to-define-and-consume-enums-in-cpp-cli.md)

### <a name="requirements"></a>Требования

Параметр компилятора: `/clr`

### <a name="examples"></a>Примеры

```cpp
// mcppv2_enum_2.cpp
// compile with: /clr
// managed enum
public enum class m { a, b };

// standard enum
public enum n { c, d };

// unnamed, standard enum
public enum { e, f } o;

int main()
{
   // consume managed enum
   m mym = m::b;
   System::Console::WriteLine("no automatic conversion to int: {0}", mym);
   System::Console::WriteLine("convert to int: {0}", (int)mym);

   // consume standard enum
   n myn = d;
   System::Console::WriteLine(myn);

   // consume standard, unnamed enum
   o = f;
   System::Console::WriteLine(o);
}
```

```Output
no automatic conversion to int: b

convert to int: 1

1

1
```

## <a name="see-also"></a>См. также раздел

[Расширения компонентов для .NET и UWP](component-extensions-for-runtime-platforms.md)
