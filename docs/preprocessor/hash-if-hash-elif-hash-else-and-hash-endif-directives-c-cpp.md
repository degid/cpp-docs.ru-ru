---
title: '#Директивы if, #elif, #else и #endif (C/C++)'
ms.date: 08/29/2019
f1_keywords:
- '#else'
- '#endif'
- '#if'
- '#elif'
- defined
- __has_include
helpviewer_keywords:
- '#elif directive'
- conditional compilation, directives
- endif directive (#endif)
- preprocessor, directives
- '#else directive'
- '#endif directive'
- if directive (#if)
- else directive (#else)
- '#if directive'
- elif directive (#elif)
- defined directive
ms.assetid: c77a175f-6ca8-47d4-8df9-7bac5943d01b
ms.openlocfilehash: acbc54a80573bbbf29ad5cf67e7e5fd9351eeaa3
ms.sourcegitcommit: 1f009ab0f2cc4a177f2d1353d5a38f164612bdb1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/27/2020
ms.locfileid: "87231602"
---
# <a name="if-elif-else-and-endif-directives-cc"></a>директивы #if, #elif, #else и #endif (C/C++)

Директива **#if** с директивами **#elif**, **#else**и **#endif** управляет компиляцией частей исходного файла. Если выражение, которое вы пишете (после **#if**), имеет ненулевое значение, группа строк сразу после директивы **#if** сохраняется в записи преобразования.

## <a name="grammar"></a>Грамматика

*условное* : \
&nbsp;&nbsp;&nbsp;&nbsp;*Если-Part elif — Parts*to *else-Part (*<sub>неявное</sub> <sub>согласие</sub> ) *— строка*

*If-Part* : \
&nbsp;&nbsp;&nbsp;&nbsp;*текст в виде строки*

*If-Line* : \
&nbsp;&nbsp;&nbsp;&nbsp;**#if** *константное выражение*\
&nbsp;&nbsp;&nbsp;&nbsp;**#ifdef** *идентификатор* #ifdef\
&nbsp;&nbsp;&nbsp;&nbsp;**#ifndef** *идентификатор* #ifndef

*elif — части* : \
&nbsp;&nbsp;&nbsp;&nbsp;*elif — текст строки*\
&nbsp;&nbsp;&nbsp;&nbsp;*elif-Parts elif — текст строки*

*elif-строка* : \
&nbsp;&nbsp;&nbsp;&nbsp;**#elif**  *константное выражение*

*else-Part* : \
&nbsp;&nbsp;&nbsp;&nbsp;*текст в else-строке*

*else-Line* : \
&nbsp;&nbsp;&nbsp;&nbsp;**#else**

*endif-строка* : \
&nbsp;&nbsp;&nbsp;&nbsp;**#endif**

## <a name="remarks"></a>Примечания

Каждая директива **#if** в исходном файле должна соответствовать закрывающей директиве **#endif** . Между директивами **#if** и **#endif** может использоваться любое число директив **#elif** , но допускается не более одной директивы **#else** . Директива **#else** , если она есть, должна быть последней директивой перед **#endif**.

Директивы **#if**, **#elif**, **#else**и **#endif** могут быть вложены в *текстовые* части других директив **#if** . Каждая вложенная директива **#else**, **#elif**или **#endif** принадлежит ближайшей предшествующей директиве **#if** .

Все директивы условной компиляции, такие как **#if** и **#ifdef**, должны соответствовать закрывающей директиве **#endif** перед концом файла. В противном случае создается сообщение об ошибке. Если директивы условной компиляции содержатся во включаемых файлах, они должны удовлетворять одинаковым условиям: в конце включаемого файла не должно оставаться непарных директив условной компиляции.

Замена макросов выполняется в части строки, следующей за командой **#elif** , поэтому в *константном выражении*можно использовать вызов макроса.

Препроцессор выбирает один из заданных вхождений *текста* для дальнейшей обработки. Блок, указанный в *тексте* , может быть любой последовательностью текста. Он может занимать несколько строк. Обычно *текст* — это текст программы, который имеет значение для компилятора или препроцессора.

Препроцессор обрабатывает выбранный *текст* и передает его компилятору. Если *текст* содержит директивы препроцессора, препроцессор выполняет эти директивы. Компилируются только текстовые блоки, выбранные препроцессором.

Препроцессор выбирает один *текстовый* элемент, оценивая константное выражение после каждой директивы **#if** или **#elif** , пока не найдет истинное (ненулевое) константное выражение. Он выбирает весь текст (включая другие директивы препроцессора, начинающиеся с **#** ) со связанными **#elif**, **#else**или **#endif**.

Если все вхождения *константного выражения* имеют значение false или если директивы **#elif** не отображаются, препроцессор выбирает блок текста после предложения **#else** . Если отсутствует предложение **#else** , а все экземпляры *константного выражения* в блоке **#if** имеют значение false, то текстовый блок не выбирается.

*Константное выражение* является целочисленным константным выражением с этими дополнительными ограничениями:

- Выражения должны иметь целочисленный тип и могут включать только целочисленные константы, символьные константы и **определенный** оператор.

- Выражение не может использовать **`sizeof`** или быть оператором приведения типа.

- Целевая среда может не представлять все диапазоны целых чисел.

- Преобразование представляет тип так **`int`** же, как и тип **`long`** , и так **`unsigned int`** же, как и **`unsigned long`** .

- Транслятор может преобразовывать символьные константы в набор кодовых значений, отличающийся от набора для целевой среды. Чтобы определить свойства целевой среды, используйте приложение, созданное для этой среды, чтобы проверить значения *ограничений. H* макросы.

- Выражение не должно запрашивать среду и должно оставаться изолированным от сведений о реализации на целевом компьютере.

## <a name="preprocessor-operators"></a>Операторы препроцессора

### <a name="defined"></a>defined

**Определяемый** Оператор препроцессора можно использовать в специальных константных выражениях, как показано в следующем синтаксисе:

> **определено (** *идентификатор* **)**\
> **определенный** *идентификатор*

Это константное выражение считается истинным (ненулевым), если *идентификатор* в настоящее время определен. В противном случае условие не выполняется (false, значение равно 0). Идентификатор, определенный как пустой текст, считается определенным. **Определенный** оператор может использоваться в **#if** и директиве **#elif** , но нигде не используется.

В следующем примере директивы **#if** и **#endif** управляют компиляцией одного из трех вызовов функций:

```C
#if defined(CREDIT)
    credit();
#elif defined(DEBIT)
    debit();
#else
    printerror();
#endif
```

Вызов функции `credit` компилируется, если определен идентификатор `CREDIT`. Если определен идентификатор `DEBIT`, компилируется вызов функции `debit`. Если ни один из этих идентификаторов не определен, компилируется вызов функции `printerror`. `CREDIT`И `credit` , и — это разные идентификаторы в C и C++, так как их варианты различны.

В следующем примере в операторах условной компиляции используется ранее определенная символьная константа с именем `DLEVEL`.

```C
#if DLEVEL > 5
    #define SIGNAL  1
    #if STACKUSE == 1
        #define STACK   200
    #else
        #define STACK   100
    #endif
#else
    #define SIGNAL  0
    #if STACKUSE == 1
        #define STACK   100
    #else
        #define STACK   50
    #endif
#endif
#if DLEVEL == 0
    #define STACK 0
#elif DLEVEL == 1
    #define STACK 100
#elif DLEVEL > 5
    display( debugptr );
#else
    #define STACK 200
#endif
```

В первом блоке **#if** показаны два набора вложенных директив **#if**, **#else**и **#endif** . Первый набор директив обрабатывается только в том случае, если выполняется условие `DLEVEL > 5`. В противном случае обрабатываются инструкции после **#else** .

Директивы **#elif** и **#else** во втором примере используются, чтобы выбрать один из четырех вариантов в зависимости от значения `DLEVEL` . Константе `STACK` присваивается значение 0, 100 или 200 в зависимости от определения константы `DLEVEL`. Если `DLEVEL` больше 5, то компилируется оператор

```C
#elif DLEVEL > 5
display(debugptr);
```

компилируется и `STACK` не определяется.

Условная компиляция обычно используется для предотвращения нескольких включений одного и того же файла заголовка. В C++, где классы часто определяются в файлах заголовков, такие конструкции можно использовать для предотвращения нескольких определений:

```cpp
/*  EXAMPLE.H - Example header file  */
#if !defined( EXAMPLE_H )
#define EXAMPLE_H

class Example
{
    //...
};

#endif // !defined( EXAMPLE_H )
```

Предыдущий код проверяет, определена ли символьная константа `EXAMPLE_H`. Если да, то файл уже включен и не нуждается в повторной обработке. Если нет, константа `EXAMPLE_H` определяется, чтобы пометить файл EXAMPLE.H как уже обработанный.

### <a name="__has_include"></a>__has_include

**Visual Studio 2017 версии 15,3 и более поздних**версий: определяет, доступен ли заголовок библиотеки для включения:

```cpp
#ifdef __has_include
#  if __has_include(<filesystem>)
#    include <filesystem>
#    define have_filesystem 1
#  elif __has_include(<experimental/filesystem>)
#    include <experimental/filesystem>
#    define have_filesystem 1
#    define experimental_filesystem
#  else
#    define have_filesystem 0
#  endif
#endif
```

## <a name="see-also"></a>См. также раздел

[Директивы препроцессора](../preprocessor/preprocessor-directives.md)
