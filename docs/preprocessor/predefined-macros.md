---
title: Предустановленные макросы
description: Список и описание предопределенных макросов препроцессора компилятора Microsoft C++.
ms.custom: update_every_version
ms.date: 09/11/2020
f1_keywords:
- _ATL_VER
- __ATOM__
- __AVX__
- __AVX2__
- __AVX512BW__
- __AVX512CD__
- __AVX512DQ__
- __AVX512F__
- __AVX512VL__
- _CHAR_UNSIGNED
- __CLR_VER
- _CONTROL_FLOW_GUARD
- __COUNTER__
- __cplusplus
- __cplusplus_cli
- __cplusplus_winrt
- _CPPRTTI
- _CPPUNWIND
- __DATE__
- _DEBUG
- _DLL
- __FILE__
- __FUNCDNAME__
- __FUNCSIG__
- __FUNCTION__
- _INTEGRAL_MAX_BITS
- _ISO_VOLATILE
- _KERNEL_MODE
- __LINE__
- _M_AMD64
- _M_ARM
- _M_ARM_ARMV7VE
- _M_ARM_FP
- _M_ARM64
- _M_CEE
- _M_CEE_PURE
- _M_CEE_SAFE
- _M_FP_EXCEPT
- _M_FP_FAST
- _M_FP_PRECISE
- _M_FP_STRICT
- _M_IX86
- _M_IX86_FP
- _M_X64
- _MANAGED
- _MFC_VER
- _MSC_BUILD
- _MSC_EXTENSIONS
- _MSC_FULL_VER
- _MSC_VER
- _MSVC_LANG
- __MSVC_RUNTIME_CHECKS
- _MT
- _NATIVE_WCHAR_T_DEFINED
- _NO_SIZED_DEALLOCATION
- _OPENMP
- _PREFAST_
- _RESUMABLE_FUNCTIONS_SUPPORTED
- _RTC_CONVERSION_CHECKS_ENABLED
- __STDC__
- __STDC_HOSTED__
- __STDC_NO_ATOMICS__
- __STDC_NO_COMPLEX__
- __STDC_NO_THREADS__
- __STDC_NO_VLA__
- __STDC_VERSION__
- __STDCPP_THREADS__
- __TIME__
- __TIMESTAMP__
- __VA_ARGS__
- _VC_NODEFAULTLIB
- _WCHAR_T_DEFINED
- _WIN32
- _WIN64
- _WINRT_DLL
helpviewer_keywords:
- timestamps, preprocessor macro
- cl.exe compiler, version number
- version numbers, C/C++ compiler (cl.exe)
- macros, predefined C++
- preprocessor, macros
- predefined macros
- _ATL_VER macro
- __ATOM__ macro
- __AVX__ macro
- __AVX2__ macro
- __AVX512BW__ macro
- __AVX512CD__ macro
- __AVX512DQ__ macro
- __AVX512F__ macro
- __AVX512VL__ macro
- _CHAR_UNSIGNED macro
- __CLR_VER macro
- _CONTROL_FLOW_GUARD macro
- __COUNTER__ macro
- __cplusplus macro
- __cplusplus_cli macro
- __cplusplus_winrt macro
- _CPPRTTI macro
- _CPPUNWIND macro
- __DATE__ macro
- _DEBUG macro
- _DLL macro
- __FILE__ macro
- __FUNCDNAME__ macro
- __FUNCSIG__ macro
- __FUNCTION__ macro
- _INTEGRAL_MAX_BITS macro
- _ISO_VOLATILE macro
- _KERNEL_MODE macro
- __LINE__ macro
- _M_AMD64 macro
- _M_ARM macro
- _M_ARM_ARMV7VE macro
- _M_ARM_FP macro
- _M_ARM64 macro
- _M_CEE macro
- _M_CEE_PURE macro
- _M_CEE_SAFE macro
- _M_FP_EXCEPT macro
- _M_FP_FAST macro
- _M_FP_PRECISE macro
- _M_FP_STRICT macro
- _M_IX86 macro
- _M_IX86_FP macro
- _M_X64 macro
- _MANAGED macro
- _MFC_VER macro
- _MSC_BUILD macro
- _MSC_EXTENSIONS macro
- _MSC_FULL_VER macro
- _MSC_VER macro
- _MSVC_LANG macro
- __MSVC_RUNTIME_CHECKS macro
- _MT macro
- _NATIVE_WCHAR_T_DEFINED macro
- _NO_SIZED_DEALLOCATION macro
- _OPENMP macro
- _PREFAST_ macro
- _RESUMABLE_FUNCTIONS_SUPPORTED macro
- _RTC_CONVERSION_CHECKS_ENABLED macro
- __STDC__ macro
- __STDC_HOSTED__ macro
- __STDC_NO_ATOMICS__ macro
- __STDC_NO_COMPLEX__ macro
- __STDC_NO_THREADS__ macro
- __STDC_NO_VLA__ macro
- __STDC_VERSION__ macro
- __STDCPP_THREADS__ macro
- __TIME__ macro
- __TIMESTAMP__ macro
- __VA_ARGS__ macro
- _VC_NODEFAULTLIB macro
- _WCHAR_T_DEFINED macro
- _WIN32 macro
- _WIN64 macro
- _WINRT_DLL macro
- __func__ identifier
ms.assetid: 1cc5f70a-a225-469c-aed0-fe766238e23f
no-loc:
- _ATL_VER
- __ATOM__
- __AVX__
- __AVX2__
- __AVX512BW__
- __AVX512CD__
- __AVX512DQ__
- __AVX512F__
- __AVX512VL__
- _CHAR_UNSIGNED
- __CLR_VER
- _CONTROL_FLOW_GUARD
- __COUNTER__
- __cplusplus
- __cplusplus_cli
- __cplusplus_winrt
- _CPPRTTI
- _CPPUNWIND
- __DATE__
- _DEBUG
- _DLL
- __FILE__
- __FUNCDNAME__
- __FUNCSIG__
- __FUNCTION__
- _INTEGRAL_MAX_BITS
- _ISO_VOLATILE
- _KERNEL_MODE
- __LINE__
- _M_AMD64
- _M_ARM
- _M_ARM_ARMV7VE
- _M_ARM_FP
- _M_ARM64
- _M_CEE
- _M_CEE_PURE
- _M_CEE_SAFE
- _M_FP_EXCEPT
- _M_FP_FAST
- _M_FP_PRECISE
- _M_FP_STRICT
- _M_IX86
- _M_IX86_FP
- _M_X64
- _MANAGED
- _MFC_VER
- _MSC_BUILD
- _MSC_EXTENSIONS
- _MSC_FULL_VER
- _MSC_VER
- _MSVC_LANG
- __MSVC_RUNTIME_CHECKS
- _MT
- _NATIVE_WCHAR_T_DEFINED
- _NO_SIZED_DEALLOCATION
- _OPENMP
- _PREFAST_
- _RESUMABLE_FUNCTIONS_SUPPORTED
- _RTC_CONVERSION_CHECKS_ENABLED
- __STDC__
- __STDC_HOSTED__
- __STDC_NO_ATOMICS__
- __STDC_NO_COMPLEX__
- __STDC_NO_THREADS__
- __STDC_NO_VLA__
- __STDC_VERSION__
- __STDCPP_THREADS__
- __TIME__
- __TIMESTAMP__
- __VA_ARGS__
- _VC_NODEFAULTLIB
- _WCHAR_T_DEFINED
- _WIN32
- _WIN64
- _WINRT_DLL
- __func__
ms.openlocfilehash: 85b467a0ac3db67b2715a849966618697437658b
ms.sourcegitcommit: b492516cc65120250b9ea23f96f7f63f37f99fae
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2020
ms.locfileid: "90075703"
---
# <a name="predefined-macros"></a>Предустановленные макросы

Компилятор Microsoft C/C++ (MSVC) предварительно определяет отдельные макросы препроцессора в зависимости от языка (C или C++ ), целевого объекта компиляции и выбранных параметров компилятора.

MSVC поддерживает предопределенные макросы препроцессора, которые являются обязательными, согласно стандартам ANSI/ISO C99, C11 и C17, а также стандартам ISO C++14 и C++17. Эта реализация также поддерживает несколько дополнительных макросов препроцессора, характерных для систем Майкрософт. Некоторые макросы определяются только для конкретных сред сборки или параметров компилятора. Если не указано иное, макросы определяются по всей единице трансляции, как если бы они были указаны в качестве аргументов параметра компилятора **`/D`** . Когда макросы определены, они развертываются до указанных значений препроцессором перед компиляцией. Предопределенные макросы не принимают аргументы и не могут быть определены повторно.

## <a name="standard-predefined-identifier"></a>Стандартный предопределенный идентификатор

Компилятор поддерживает этот предопределенный идентификатор, описанный стандартами ISO C99 и ISO C++11.

- `__func__` — неполное имя включающей функции без дополнений, записываемое в виде локального для функции массива **static const** с элементами **`char`** .

    ```cpp
    void example(){
        printf("%s\n", __func__);
    } // prints "example"
    ```

## <a name="standard-predefined-macros"></a>Стандартные предопределенные макросы

Компилятор поддерживает эти предопределенные макросы, описанные стандартами ISO C99, C11, C17 и ISO C++17.

- `__cplusplus` — определяется как целочисленное литеральное значение, если единица трансляции компилируется как C++. В противном случае — не определяется.

- `__DATE__` — дата компиляции текущего файла исходного кода. Дата — строковой литерал постоянной длины в формате *ммм дд гггг*. Название месяца *ммм* совпадает с сокращенным названием месяца, созданным функцией [asctime](../c-runtime-library/reference/asctime-wasctime.md) библиотеки времени выполнения C (CRT). Первый символ даты *дд* — это пробел, если значение меньше 10. Этот макрос определяется всегда. Этот макрос определяется всегда.

- `__FILE__` — имя текущего файла исходного кода. `__FILE__` развертывается в литерал строки символов. Чтобы убедиться, что отображается полный путь к файлу, используйте [ **`/FC`** (полный путь к файлу исходного кода в диагностике)](../build/reference/fc-full-path-of-source-code-file-in-diagnostics.md). Этот макрос определяется всегда.

- `__LINE__` определяется как целочисленный номер строки в текущем файле исходного кода. Значение макроса `__LINE__` можно изменить с помощью директивы `#line`. Этот макрос определяется всегда.

- `__STDC__` — определяется как 1 только при компиляции в виде C и при указании параметра компилятора [ **`/Za`** ](../build/reference/za-ze-disable-language-extensions.md). В противном случае — не определяется.

- `__STDC_HOSTED__` определяется как 1, если реализация является *размещенной реализацией*, полностью поддерживающей необходимую стандартную библиотеку. В противном случае определяется как 0.

- `__STDC_NO_ATOMICS__` — определяется как 1, если реализация не поддерживает необязательные стандартные атомарные элементы. Реализация MSVC определяет его как 1 при компиляции в виде C, а также одного из вариантов [ **`/std`** ](../build/reference/std-specify-language-standard-version.md) C11 или C17.

- `__STDC_NO_COMPLEX__` — определяется как 1, если реализация не поддерживает необязательные стандартные комплексные числа. Реализация MSVC определяет его как 1 при компиляции в виде C, а также одного из вариантов [ **`/std`** ](../build/reference/std-specify-language-standard-version.md) C11 или C17.

- `__STDC_NO_THREADS__` — определяется как 1, если реализация не поддерживает необязательные стандартные потоки. Реализация MSVC определяет его как 1 при компиляции в виде C, а также одного из вариантов [ **`/std`** ](../build/reference/std-specify-language-standard-version.md) C11 или C17.

- `__STDC_NO_VLA__` — определяется как 1, если реализация не поддерживает стандартные массивы переменной длины. Реализация MSVC определяет его как 1 при компиляции в виде C, а также одного из вариантов [ **`/std`** ](../build/reference/std-specify-language-standard-version.md) C11 или C17.

- `__STDC_VERSION__` — определяется при компиляции в виде C, а также одного из вариантов **`/std`** C11 или C17. Он разворачивается в `201112L` для [ **`/std:c11`** ](../build/reference/std-specify-language-standard-version.md) и в `201710L` для [ **`/std:c17`** ](../build/reference/std-specify-language-standard-version.md).

- `__STDCPP_THREADS__` определяется как 1, только если программа может иметь только один поток выполнения и cкомпилирована как C++. В противном случае — не определяется.

- `__TIME__` — время, в течение которого выполняется преобразование предварительно обработанной единицы трансляции. Время представляет собой литерал строки символов в форме *чч:мм:сс*, который совпадает со временем, возвращаемым функцией [asctime](../c-runtime-library/reference/asctime-wasctime.md) CRT. Этот макрос определяется всегда.

## <a name="microsoft-specific-predefined-macros"></a>Предопределенные макросы, предназначенные специально для систем Майкрософт

MSVC поддерживает эти дополнительные предопределенные макросы.

- `__ATOM__` — определяется как 1, если задан параметр компилятора [ **`/favor:ATOM`** ](../build/reference/favor-optimize-for-architecture-specifics.md) и компилятор имеет целевую платформу x86 или x64. В противном случае — не определяется.

- `__AVX__` — определяется как 1, если заданы параметры компилятора [ **`/arch:AVX`** ](../build/reference/arch-x86.md), [ **`/arch:AVX2`** ](../build/reference/arch-x86.md) или [ **`/arch:AVX512`** ](../build/reference/arch-x86.md) и компилятор имеет целевую платформу x86 или x64. В противном случае — не определяется.

- `__AVX2__` — определяется как 1, если заданы параметры компилятора [ **`/arch:AVX2`** ](../build/reference/arch-x86.md) или [ **`/arch:AVX512`** ](../build/reference/arch-x86.md) и компилятор имеет целевую платформу x86 или x64. В противном случае — не определяется.

- `__AVX512BW__` — определяется как 1, если задан параметр компилятора [ **`/arch:AVX512`** ](../build/reference/arch-x86.md) и компилятор имеет целевую платформу x86 или x64. В противном случае — не определяется.

- `__AVX512CD__` — определяется как 1, если задан параметр компилятора [ **`/arch:AVX512`** ](../build/reference/arch-x86.md) и компилятор имеет целевую платформу x86 или x64. В противном случае — не определяется.

- `__AVX512DQ__` — определяется как 1, если задан параметр компилятора [ **`/arch:AVX512`** ](../build/reference/arch-x86.md) и компилятор имеет целевую платформу x86 или x64. В противном случае — не определяется.

- `__AVX512F__` — определяется как 1, если задан параметр компилятора [ **`/arch:AVX512`** ](../build/reference/arch-x86.md) и компилятор имеет целевую платформу x86 или x64. В противном случае — не определяется.

- `__AVX512VL__` — определяется как 1, если задан параметр компилятора [ **`/arch:AVX512`** ](../build/reference/arch-x86.md) и компилятор имеет целевую платформу x86 или x64. В противном случае — не определяется.

- `_CHAR_UNSIGNED` — определяется как 1, если по умолчанию используется тип **`char`** без знака. Это значение определяется, если задан параметр компилятора [ **`/J`** (по умолчанию тип char без знака)](../build/reference/j-default-char-type-is-unsigned.md). В противном случае — не определяется.

- `__CLR_VER` определяется как целочисленный литерал, представляющий версию среды CLR, используемую для компиляции приложения. Значение кодируется в виде `Mmmbbbbb`, где `M` является основным номером версии среды выполнения, `mm` — это дополнительный номер версии среды выполнения, а `bbbbb` — номер сборки. `__CLR_VER` определяется, если задан параметр компилятора [ **`/clr`** ](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

    ```cpp
    // clr_ver.cpp
    // compile with: /clr
    using namespace System;
    int main() {
       Console::WriteLine(__CLR_VER);
    }
    ```

- `_CONTROL_FLOW_GUARD` — определяется как 1, если задан параметр компилятора [ **`/guard:cf`** (Включение защиты потока управления)](../build/reference/guard-enable-control-flow-guard.md). В противном случае — не определяется.

- `__COUNTER__` развертывается до целочисленного литерала, начинающегося с 0. Значение увеличивается на 1 каждый раз, когда используется в файле исходного кода или во включенных заголовках файла исходного кода. `__COUNTER__` запоминает свое состояние при использовании предкомпилированных заголовков. Этот макрос определяется всегда.

  В этом примере `__COUNTER__` используется для назначения уникальных идентификаторов трем различным объектам одного типа. Конструктор `exampleClass` принимает целое число в качестве параметра. В `main` приложение объявляет три объекта типа `exampleClass` с использованием `__COUNTER__` в качестве параметра уникального идентификатора:

    ```cpp
    // macro__COUNTER__.cpp
    // Demonstration of __COUNTER__, assigns unique identifiers to
    // different objects of the same type.
    // Compile by using: cl /EHsc /W4 macro__COUNTER__.cpp
    #include <stdio.h>

    class exampleClass {
        int m_nID;
    public:
        // initialize object with a read-only unique ID
        exampleClass(int nID) : m_nID(nID) {}
        int GetID(void) { return m_nID; }
    };

    int main()
    {
        // __COUNTER__ is initially defined as 0
        exampleClass e1(__COUNTER__);

        // On the second reference, __COUNTER__ is now defined as 1
        exampleClass e2(__COUNTER__);

        // __COUNTER__ is now defined as 2
        exampleClass e3(__COUNTER__);

        printf("e1 ID: %i\n", e1.GetID());
        printf("e2 ID: %i\n", e2.GetID());
        printf("e3 ID: %i\n", e3.GetID());

        // Output
        // ------------------------------
        // e1 ID: 0
        // e2 ID: 1
        // e3 ID: 2

        return 0;
    }
    ```

- `__cplusplus_cli` — определяется как целочисленное литеральное значение 200406 при компиляции в виде C++ и при заданном параметре компилятора [ **`/clr`** ](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется. Когда `__cplusplus_cli` задан, он действует во всей единице трансляции.

    ```cpp
    // cplusplus_cli.cpp
    // compile by using /clr
    #include "stdio.h"
    int main() {
       #ifdef __cplusplus_cli
          printf("%d\n", __cplusplus_cli);
       #else
          printf("not defined\n");
       #endif
    }
    ```

- `__cplusplus_winrt` — определяется как целочисленное литеральное значение 201009 при компиляции в виде C++ и при заданном параметре компилятора [ **`/ZW`** (Компиляция для среды выполнения Windows)](../build/reference/zw-windows-runtime-compilation.md). В противном случае — не определяется.

- `_CPPRTTI` — определяется как 1, если задан параметр компилятора [ **`/GR`** (Включение сведений о типе во время выполнения)](../build/reference/gr-enable-run-time-type-information.md). В противном случае — не определяется.

- `_CPPUNWIND` — определяется как 1, если заданы какие-то из следующих параметров компилятора: [ **`/GX`** (Включить обработку исключений)](../build/reference/gx-enable-exception-handling.md), [ **`/clr`** (Компиляция для среды CLR)](../build/reference/clr-common-language-runtime-compilation.md) или [ **`/EH`** (Модель обработки исключений)](../build/reference/eh-exception-handling-model.md). В противном случае — не определяется.

- `_DEBUG` — определяется как 1, если заданы параметры компилятора [ **`/LDd`** ](../build/reference/md-mt-ld-use-run-time-library.md), [ **`/MDd`** ](../build/reference/md-mt-ld-use-run-time-library.md) или [ **`/MTd`** ](../build/reference/md-mt-ld-use-run-time-library.md). В противном случае — не определяется.

- `_DLL` — определяется как 1, если заданы параметры компилятора [ **`/MD`** ](../build/reference/md-mt-ld-use-run-time-library.md) или [ **`/MDd`** ](../build/reference/md-mt-ld-use-run-time-library.md) (Многопоточная библиотека DLL). В противном случае — не определяется.

- `__FUNCDNAME__` определяется как строковый литерал, содержащий [декорированное имя](../build/reference/decorated-names.md) включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCDNAME__` не разворачивается, если используется параметр компилятора [ **`/EP`** ](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [ **`/P`** ](../build/reference/p-preprocess-to-a-file.md).

   В этом примере макросы `__FUNCDNAME__`, `__FUNCSIG__` и `__FUNCTION__` используются для вывода информации о функции.

   [!code-cpp[NVC_Predefined_Macros_Examples#1](../preprocessor/codesnippet/CPP/predefined-macros_1.cpp)]

- `__FUNCSIG__` определяется как строковый литерал, содержащий сигнатуру включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCSIG__` не разворачивается, если используется параметр компилятора [ **`/EP`** ](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [ **`/P`** ](../build/reference/p-preprocess-to-a-file.md). При компиляции для 64-разрядных целевых платформ по умолчанию используется соглашение о вызовах **`__cdecl`** . Пример использования см. в разделе для макроса `__FUNCDNAME__`.

- `__FUNCTION__` определяется как строковый литерал, содержащий недекорированное имя включающей функции. Макрос определен только в пределах функции. Макрос `__FUNCTION__` не разворачивается, если используется параметр компилятора [ **`/EP`** ](../build/reference/ep-preprocess-to-stdout-without-hash-line-directives.md) или [ **`/P`** ](../build/reference/p-preprocess-to-a-file.md). Пример использования см. в разделе для макроса `__FUNCDNAME__`.

- `_INTEGRAL_MAX_BITS` определяется как целочисленное литеральное значение 64, максимальный размер (в битах) для целочисленного типа без вектора. Этот макрос определяется всегда.

   ```cpp
   // integral_max_bits.cpp
   #include <stdio.h>
   int main() {
      printf("%d\n", _INTEGRAL_MAX_BITS);
   }
   ```

- `__INTELLISENSE__` определяется как 1 во время прохода компилятором IntelliSense в интегрированной среде разработки Visual Studio. В противном случае — не определяется. Этот макрос можно использовать для защиты кода, который компилятор IntelliSense не понимает, или для переключения между сборкой и компилятором IntelliSense. Дополнительные сведения см. в разделе [советы по устранению неполадок при медленной работе IntelliSense](https://devblogs.microsoft.com/cppblog/troubleshooting-tips-for-intellisense-slowness/).

- `_ISO_VOLATILE` — определяется как 1, если задан параметр компилятора [ **`/volatile:iso`** ](../build/reference/volatile-volatile-keyword-interpretation.md). В противном случае — не определяется.

- `_KERNEL_MODE` — определяется как 1, если задан параметр компилятора [ **`/kernel`** (Создать двоичный файл режима ядра)](../build/reference/kernel-create-kernel-mode-binary.md). В противном случае — не определяется.

- `_M_AMD64` определяется как целочисленное литеральное значение 100 для компиляций, предназначенных для процессоров x64. В противном случае — не определяется.

- `_M_ARM` определяется как целочисленное литеральное значение 7 для компиляций, предназначенных для процессоров ARM. В противном случае — не определяется.

- `_M_ARM_ARMV7VE` — определяется как 1, если задан параметр компилятора [ **`/arch:ARMv7VE`** ](../build/reference/arch-arm.md) для компиляций под процессоры ARM. В противном случае — не определяется.

- `_M_ARM_FP` — определяется как целочисленное литеральное значение, указывающее, какой параметр компилятора [ **`/arch`** ](../build/reference/arch-arm.md) был задан для целевых платформ на процессоре ARM. В противном случае — не определяется.

  - Значение в диапазоне 30–39, если не был указан параметр **`/arch`** для ARM, что означает, что была задана архитектура для ARM по умолчанию (`VFPv3`).

  - Значение в диапазоне 40–49, если было задано **`/arch:VFPv4`** .

  - Дополнительные сведения: [ **`/arch`** (ARM)](../build/reference/arch-arm.md).

- `_M_ARM64` определяется как 1 для компиляций, предназначенных для 64-разрядных процессоров ARM. В противном случае — не определяется.

- `_M_CEE` — определяется как 001, если задан параметр компилятора [ **`/clr`** (Компиляция для среды CLR)](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_M_CEE_PURE` объявлен нерекомендуемым начиная с Visual Studio 2015. Определяется как 001, если задан параметр компилятора [ **`/clr:pure`** ](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_M_CEE_SAFE` объявлен нерекомендуемым начиная с Visual Studio 2015. Определяется как 001, если задан параметр компилятора [ **`/clr:safe`** ](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_M_FP_EXCEPT` — определяется как 1, если задан параметр компилятора [ **`/fp:except`** ](../build/reference/fp-specify-floating-point-behavior.md) или [ **`/fp:strict`** ](../build/reference/fp-specify-floating-point-behavior.md). В противном случае — не определяется.

- `_M_FP_FAST` — определяется как 1, если задан параметр компилятора [ **`/fp:fast`** ](../build/reference/fp-specify-floating-point-behavior.md). В противном случае — не определяется.

- `_M_FP_PRECISE` — определяется как 1, если задан параметр компилятора [ **`/fp:precise`** ](../build/reference/fp-specify-floating-point-behavior.md). В противном случае — не определяется.

- `_M_FP_STRICT` — определяется как 1, если задан параметр компилятора [ **`/fp:strict`** ](../build/reference/fp-specify-floating-point-behavior.md). В противном случае — не определяется.

- `_M_IX86` определяется как целочисленное литеральное значение 600 для компиляций, предназначенных для процессоров x86. Этот макрос не определяется для целевых объектов компиляции x64 или ARM.

- `_M_IX86_FP` — определяется как целочисленное литеральное значение, указывающее заданный параметр компилятора [ **`/arch`** ](../build/reference/arch-arm.md) либо значение по умолчанию. Этот макрос всегда определяется, если целевым объектом компиляции является процессор x86. В противном случае — не определяется. Когда определен, значение равно:

  - 0, если задан параметр компилятора `/arch:IA32`.

  - 1, если задан параметр компилятора `/arch:SSE`.

  - 2, если задан параметр компилятора `/arch:SSE2`, `/arch:AVX`, `/arch:AVX2` или `/arch:AVX512`. Это значение используется по умолчанию, если не был указан параметр компилятора `/arch`. Если указан `/arch:AVX`, также определяется макрос `__AVX__`. Если указан `/arch:AVX2`, также определяются `__AVX__` и `__AVX2__`. Если указано `/arch:AVX512`, также определяются `__AVX__`, `__AVX2__`, `__AVX512BW__`, `__AVX512CD__`, `__AVX512DQ__`, `__AVX512F__` и `__AVX512VL__`.

  - Дополнительные сведения: [ **`/arch`** (x86)](../build/reference/arch-x86.md).

- `_M_X64` определяется как целочисленное литеральное значение 100 для компиляций, предназначенных для процессоров x64. В противном случае — не определяется.

- `_MANAGED` — определяется как 1, если задан параметр компилятора [ **`/clr`** ](../build/reference/clr-common-language-runtime-compilation.md). В противном случае — не определяется.

- `_MSC_BUILD` определяется как целочисленный литерал, содержащий элемент номера редакции номера версии компилятора. Номер редакции — это четвертый элемент разделенного точками номера версии. Например, для номера версии компилятора Microsoft C/C++ 15.00.20706.01 макрос `_MSC_BUILD` дает значение 1. Этот макрос определяется всегда.

- `_MSC_EXTENSIONS` — определяется как 1, если задан включенный по умолчанию параметр компилятора [ **`/Ze`** (Включить расширения языка)](../build/reference/za-ze-disable-language-extensions.md). В противном случае — не определяется.

- `_MSC_FULL_VER` определяется как целочисленный литерал, кодирующий такие элементы номера версии компилятора, как основной номер версии, дополнительный номер версии и номер сборки. Основной номер — это первый элемент номера версии с разделителями точками, дополнительный номер — второй элемент, а номер сборки — третий. Например, для номера версии компилятора Microsoft C/C++ 15.00.20706.01 макрос `_MSC_FULL_VER` дает значение 150020706. Для просмотра номера версии компилятора введите `cl /?` в командной строке. Этот макрос определяется всегда.

- `_MSC_VER` определяется как целочисленный литерал, кодирующий такие элементы номера версии компилятора, как основной номер версии и дополнительный номер версии. Основной номер — это первый элемент номера версии с разделителями точками, а дополнительный номер — это второй элемент. Например, для номера версии компилятора Microsoft C/C++ 17.00.51106.1 макрос `_MSC_VER` дает значение 1700. Для просмотра номера версии компилятора введите `cl /?` в командной строке. Этот макрос определяется всегда.

   | Версия Visual Studio | `_MSC_VER` |
   |--|--|
   | Visual Studio 6.0 | 1200 |
   | Visual Studio .NET 2002 (7.0) | 1300 |
   | Visual Studio .NET 2003 (7.1) | 1310 |
   | Visual Studio 2005 (8.0) | 1400 |
   | Visual Studio 2008 (9.0) | 1500 |
   | Visual Studio 2010 (10.0) | 1600 |
   | Visual Studio 2012 (11.0) | 1700 |
   | Visual Studio 2013 (12.0) | 1800 |
   | Visual Studio 2015 (14.0) | 1900 |
   | Visual Studio 2017 RTW (15.0) | 1910 |
   | Visual Studio 2017 версия 15.3 | 1911 |
   | Visual Studio 2017 версии 15.5 | 1912 |
   | Visual Studio 2017 версии 15.6 | 1913 |
   | Visual Studio 2017 версии 15.7 | 1914 |
   | Visual Studio 2017 версии 15.8 | 1915 |
   | Visual Studio 2017 версии 15.9 | 1916 |
   | Visual Studio 2019 RTW (16.0) | 1920 |
   | Visual Studio 2019 версии 16.1 | 1921 |
   | Visual Studio 2019 версии 16.2 | 1922 |
   | Visual Studio 2019 версии 16.3 | 1923 |
   | Visual Studio 2019 версии 16.4 | 1924 |
   | Visual Studio 2019, версия 16.5 | 1925 |
   | Visual Studio 2019 версии 16.6 | 1926 |
   | Visual Studio 2019 версии 16.7 | 1927 |
   | Visual Studio 2019 версии 16.8 | 1928 |

   Чтобы проверить наличие выпусков или обновлений компилятора в заданной версии Visual Studio или более поздних, используйте оператор `>=`. Его можно использовать в условной директиве для сравнения `_MSC_VER` с этой известной версией. При сравнении нескольких взаимоисключающих версий упорядочите сравнения в порядке убывания номера версии. Например, этот код проверяет компиляторы, выпущенные в Visual Studio 2017 и более поздних версиях. Затем он проверяет компиляторы, выпущенные в Visual Studio 2015 или более поздних версиях. Затем он проверяет все компиляторы, выпущенные до Visual Studio 2015:

   ```cpp
   #if _MSC_VER >= 1910
   // . . .
   #elif _MSC_VER >= 1900
   // . . .
   #else
   // . . .
   #endif
   ```

   Дополнительные сведения см. в статье [Visual C++ Compiler Version](https://devblogs.microsoft.com/cppblog/visual-c-compiler-version/) (Версия компилятора Visual C++) в блоге команды разработчиков Microsoft C++.

- `_MSVC_LANG` определяется как целочисленный литерал, указывающий стандарт языка C++, на который ориентируется компилятор. Он задается только в коде, компилируемом как C++. Этот макрос представляет собой целочисленное литеральное значение 201402L по умолчанию или при указании параметра компилятора [ **`/std:c++14`** ](../build/reference/std-specify-language-standard-version.md). Макрос имеет значение 201703L, если указан параметр компилятора [ **`/std:c++17`** ](../build/reference/std-specify-language-standard-version.md). Если указан параметр [ **`/std:c++latest`** ](../build/reference/std-specify-language-standard-version.md), макросу присваивается более высокое неопределенное значение. В противном случае макрос не определяется. Макрос `_MSVC_LANG` и параметр компилятора [ **`/std`** (Определить версию стандарта языка)](../build/reference/std-specify-language-standard-version.md) доступны начиная с Visual Studio 2015 с обновлением 3.

- `__MSVC_RUNTIME_CHECKS` — определяется как 1, если задан один из параметров компилятора [ **`/RTC`** ](../build/reference/rtc-run-time-error-checks.md). В противном случае — не определяется.

- `_MSVC_TRADITIONAL` — определяется как 0, если задан параметр компилятора [ **`/experimental:preprocessor`** ](../build/reference/experimental-preprocessor.md) для режима соответствия препроцессора. Определяется как 1 по умолчанию или при заданном параметре компилятора [ **`/experimental:preprocessor-`** ](../build/reference/experimental-preprocessor.md), указывая на использование традиционного препроцессора. Макрос `_MSVC_TRADITIONAL` и параметр компилятора [ **`/experimental:preprocessor`** (Включить режим соответствия препроцессора)](../build/reference/experimental-preprocessor.md) доступны начиная с Visual Studio 2017 версии 15.8.

   ```cpp
   #if defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL
   // Logic using the traditional preprocessor
   #else
   // Logic using cross-platform compatible preprocessor
   #endif
   ```

- `_MT` — определяется как 1, если задан параметр [ **`/MD`** или **`/MDd`** (Многопоточная библиотека DLL)](../build/reference/md-mt-ld-use-run-time-library.md) либо [ **`/MT`** или **`/MTd`** (Многопоточная библиотека)](../build/reference/md-mt-ld-use-run-time-library.md). В противном случае — не определяется.

- `_NATIVE_WCHAR_T_DEFINED` — определяется как 1, если задан параметр компилятора [ **`/Zc:wchar_t`** ](../build/reference/zc-wchar-t-wchar-t-is-native-type.md). В противном случае — не определяется.

- `_OPENMP` — определяется как целочисленный литерал 200203, если задан параметр компилятора [ **`/openmp`** (Включить поддержку OpenMP 2.0)](../build/reference/openmp-enable-openmp-2-0-support.md). Это значение представляет дату спецификации OpenMP, реализуемой компилятором MSVC. В противном случае — не определяется.

   ```cpp
   // _OPENMP_dir.cpp
   // compile with: /openmp
   #include <stdio.h>
   int main() {
      printf("%d\n", _OPENMP);
   }
   ```

- `_PREFAST_` — определяется как 1, если задан параметр компилятора [ **`/analyze`** ](../build/reference/analyze-code-analysis.md). В противном случае — не определяется.

- `__TIMESTAMP__` — определяется как строковый литерал, содержащий дату и время последнего изменения текущего исходного файла в сокращенной форме с постоянной длиной, которые возвращаются функцией [`asctime`](../c-runtime-library/reference/asctime-wasctime.md) библиотеки CRT, например: `Fri 19 Aug 13:32:58 2016`. Этот макрос определяется всегда.

- `_VC_NODEFAULTLIB` — определяется как 1, если задан параметр компилятора [ **`/Zl`** (Пропускать имена стандартных библиотек)](../build/reference/zl-omit-default-library-name.md). В противном случае — не определяется.

- `_WCHAR_T_DEFINED` — определяется как 1, если задан параметр компилятора [ **`/Zc:wchar_t`** ](../build/reference/zc-wchar-t-wchar-t-is-native-type.md), используемый по умолчанию. Макрос `_WCHAR_T_DEFINED` определен, но не имеет значения, если задан параметр компилятора **`/Zc:wchar_t-`** , а в системном файле заголовка, включенном в ваш проект, определен параметр **`wchar_t`** . В противном случае — не определяется.

- `_WIN32` определяется как 1, если целевой объект компиляции — 32-разрядная архитектура ARM, 64-разрядная архитектура ARM, x86 или x64. В противном случае — не определяется.

- `_WIN64` определяется как 1, если целевой объект компиляции — 64-разрядная архитектура ARM или x64. В противном случае — не определяется.

- `_WINRT_DLL` — определяется как 1 при компиляции в виде C++ и при заданных параметрах компилятора [ **`/ZW`** (Компиляция для среды выполнения Windows)](../build/reference/zw-windows-runtime-compilation.md) и [ **`/LD`** или **`/LDd`** ](../build/reference/md-mt-ld-use-run-time-library.md). В противном случае — не определяется.

Нет предопределенных компилятором макросов препроцессора, которые определяют версию библиотеки ATL или MFC. Заголовки библиотек ATL и MFC определяют эти макросы версий внутренним образом. Они не определены в директивах препроцессора, выполняемых до включения необходимого заголовка.

- `_ATL_VER` — определяется в \<atldef.h> как целочисленный литерал, который кодирует номер версии библиотеки ATL.

- `_MFC_VER` — определяется в \<afxver_.h> как целочисленный литерал, который кодирует номер версии библиотеки MFC.

## <a name="see-also"></a>См. также

[Макросы (C/C++)](../preprocessor/macros-c-cpp.md)<br/>
[Операторы препроцессора](../preprocessor/preprocessor-operators.md)<br/>
[Директивы препроцессора](../preprocessor/preprocessor-directives.md)
